📦 Dumping from: C:\Workspaces\Zigadel\code\Applications\docz
📤 Output: C:\Workspaces\Zigadel\code\Applications\docz\project_dump.txt
📁 Max file size: 104857600 bytes
🚫 Ignore rules (in order):
  .git/
  zig-out/
  .zig-cache/
  .github
  .github/
  project_dump.txt

🧱 Filtered Tree:
- .dpignore
- .gitignore
- build.zig
- docs
  - docs/DEPENDENCIES.md
  - docs/DEVELOPMENT.md
  - docs/GAMEPLAN.md
  - docs/old
    - docs/old/README-old.md
    - docs/old/README.dcz
  - docs/PLUGIN_GUIDE.md
  - docs/ROADMAP.md
  - docs/SPEC.dcz
  - docs/STYLE_GUIDE.md
  - docs/WORKFLOW.md
- examples
  - examples/all-directives.dcz
  - examples/example.dcz
  - examples/minimal.dcz
  - examples/minimal.dcz.html
  - examples/sample.dcz
  - examples/youtube.md
- out
  - out/spec-inline.html
- README.md
- root.zig
- src
  - src/cli
    - src/cli/build_cmd.zig
    - src/cli/common.zig
    - src/cli/convert.zig
    - src/cli/enable_wasm.zig
    - src/cli/preview.zig
    - src/cli/run.zig
  - src/convert
    - src/convert/html
      - src/convert/html/export.zig
      - src/convert/html/import.zig
    - src/convert/latex
      - src/convert/latex/export.zig
      - src/convert/latex/import.zig
    - src/convert/markdown
      - src/convert/markdown/export.zig
      - src/convert/markdown/import.zig
  - src/core
  - src/main.zig
  - src/parser
    - src/parser/ast.zig
    - src/parser/parser.zig
    - src/parser/tokenizer.zig
  - src/plugins
    - src/plugins/manager.zig
  - src/renderer
    - src/renderer/html.zig
  - src/testutil.zig
- tests
  - tests/e2e
    - tests/e2e/cli_usage.zig
    - tests/e2e/convert_cli.zig
    - tests/e2e/enable_wasm.zig
    - tests/e2e/file_to_html.zig
  - tests/integration
    - tests/integration/convert_html_import.zig
    - tests/integration/latex_roundtrip.zig
    - tests/integration/parser.zig
    - tests/integration/pipeline.zig
    - tests/integration/renderer.zig
    - tests/integration/tokenizer.zig
  - tests/test_all_e2e.zig
  - tests/test_all_integration.zig
- vscode-extension
  - vscode-extension/package.json
  - vscode-extension/src
    - vscode-extension/src/extension.ts
    - vscode-extension/src/syntax
- web-preview
  - web-preview/handler.zig
  - web-preview/hot_reload.zig
  - web-preview/server.zig

📄 File Contents:

`.dpignore`: >>>

.git/
zig-out/
.zig-cache/
.github
.github/
<<<

`.gitignore`: >>>

.DS_Store

.zig-cache/
.zig-cache
zig-out/
zig-out
.env
out
out/
<<<

`build.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");

// Link platform-specific networking deps based on the *artifact's* target.
// Works for native and cross builds.
fn linkPlatformNetDeps(artifact: *std.Build.Step.Compile) void {
    const rt = artifact.root_module.resolved_target orelse return;
    if (rt.result.os.tag == .windows) {
        // std.net/std.http on Windows requires Winsock
        artifact.linkSystemLibrary("ws2_32");
    }
    // Other OSes: nothing extra needed.
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // Optional verbosity for tests
    const verbose_tests = b.option(bool, "verbose-tests", "Print debug logs in tests") orelse false;

    const build_opts = b.addOptions();
    build_opts.addOption(bool, "verbose_tests", verbose_tests);

    // ─────────────────────────────────────────────
    // 📦 Public module: docz (root.zig)
    // ─────────────────────────────────────────────
    const docz_module = b.createModule(.{
        .root_source_file = b.path("root.zig"),
        .target = target,
        .optimize = optimize,
    });
    docz_module.addOptions("build_options", build_opts);

    // ─────────────────────────────────────────────
    // 🖥 CLI module (attach converter imports before creating the exe)
    // ─────────────────────────────────────────────
    const cli_root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_root_module.addImport("docz", docz_module);
    cli_root_module.addOptions("build_options", build_opts);

    // ─────────────────────────────────────────────
    // 🔒 Internal converter modules (not exported via root.zig)
    // ─────────────────────────────────────────────
    const html_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/html/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    html_import_mod.addOptions("build_options", build_opts);
    html_import_mod.addImport("docz", docz_module);

    const html_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/html/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    html_export_mod.addOptions("build_options", build_opts);
    html_export_mod.addImport("docz", docz_module);
    docz_module.addImport("html_export", html_export_mod);

    const md_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/markdown/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    md_import_mod.addOptions("build_options", build_opts);
    md_import_mod.addImport("docz", docz_module);

    const md_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/markdown/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    md_export_mod.addOptions("build_options", build_opts);
    md_export_mod.addImport("docz", docz_module);

    const latex_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/latex/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    latex_import_mod.addOptions("build_options", build_opts);
    latex_import_mod.addImport("docz", docz_module);

    const latex_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/latex/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    latex_export_mod.addOptions("build_options", build_opts);
    latex_export_mod.addImport("docz", docz_module);

    // Expose converters to the CLI
    cli_root_module.addImport("html_import", html_import_mod);
    cli_root_module.addImport("html_export", html_export_mod);
    cli_root_module.addImport("md_import", md_import_mod);
    cli_root_module.addImport("md_export", md_export_mod);
    cli_root_module.addImport("latex_import", latex_import_mod);
    cli_root_module.addImport("latex_export", latex_export_mod);

    // ─────────────────────────────────────────────
    // 🖥 CLI executable
    // ─────────────────────────────────────────────
    const exe = b.addExecutable(.{
        .name = "docz",
        .root_module = cli_root_module,
    });
    // Link Winsock on Windows automatically
    linkPlatformNetDeps(exe);

    // Normal install (zig build install)
    b.installArtifact(exe);

    // Names (OS-aware)
    const exe_name = if (builtin.os.tag == .windows) "docz.exe" else "docz";
    const e2e_name = if (builtin.os.tag == .windows) "docz-e2e.exe" else "docz-e2e";

    // Install a separate e2e launcher so tests never lock the main binary
    const e2e_install = b.addInstallArtifact(exe, .{
        .dest_sub_path = e2e_name,
    });

    // Relative + absolute paths (helpful for tests)
    const docz_rel = b.fmt("zig-out/bin/{s}", .{exe_name});
    const e2e_rel = b.fmt("zig-out/bin/{s}", .{e2e_name});
    const docz_abs = b.getInstallPath(.bin, exe_name);
    const e2e_abs = b.getInstallPath(.bin, e2e_name);

    build_opts.addOption([]const u8, "docz_relpath", docz_rel);
    build_opts.addOption([]const u8, "e2e_relpath", e2e_rel);
    build_opts.addOption([]const u8, "docz_abspath", docz_abs);
    build_opts.addOption([]const u8, "e2e_abspath", e2e_abs);

    // Convenience run step (general)
    const run_cmd = b.addRunArtifact(exe);
    if (b.args) |args| run_cmd.addArgs(args);
    const run_step = b.step("run", "Run the Docz CLI");
    run_step.dependOn(&run_cmd.step);

    // Preview convenience: `zig build preview -- <args>`
    const prev = b.addRunArtifact(exe);
    prev.addArg("preview");
    if (b.args) |args| prev.addArgs(args);
    const prev_step = b.step("preview", "Run the web preview server");
    prev_step.dependOn(&prev.step);

    // ─────────────────────────────────────────────
    // 🧪 Unit tests (docz + each internal converter)
    // ─────────────────────────────────────────────
    const unit_tests = b.addTest(.{ .root_module = docz_module });
    const unit_run = b.addRunArtifact(unit_tests);

    const html_import_unit = b.addTest(.{ .root_module = html_import_mod });
    const html_import_unit_run = b.addRunArtifact(html_import_unit);

    const html_export_unit = b.addTest(.{ .root_module = html_export_mod });
    const html_export_unit_run = b.addRunArtifact(html_export_unit);

    const md_import_unit = b.addTest(.{ .root_module = md_import_mod });
    const md_import_unit_run = b.addRunArtifact(md_import_unit);

    const md_export_unit = b.addTest(.{ .root_module = md_export_mod });
    const md_export_unit_run = b.addRunArtifact(md_export_unit);

    const latex_import_unit = b.addTest(.{ .root_module = latex_import_mod });
    const latex_import_unit_run = b.addRunArtifact(latex_import_unit);

    const latex_export_unit = b.addTest(.{ .root_module = latex_export_mod });
    const latex_export_unit_run = b.addRunArtifact(latex_export_unit);

    const unit_step = b.step("test", "Run unit tests");
    unit_step.dependOn(&unit_run.step);
    unit_step.dependOn(&html_import_unit_run.step);
    unit_step.dependOn(&html_export_unit_run.step);
    unit_step.dependOn(&md_import_unit_run.step);
    unit_step.dependOn(&md_export_unit_run.step);
    unit_step.dependOn(&latex_import_unit_run.step);
    unit_step.dependOn(&latex_export_unit_run.step);

    // ─────────────────────────────────────────────
    // 🧪 CLI unit tests (each CLI file is its own module-under-test)
    // ─────────────────────────────────────────────
    const cli_common_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/common.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_common_mod.addOptions("build_options", build_opts);
    cli_common_mod.addImport("docz", docz_module);

    const cli_convert_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/convert.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_convert_mod.addOptions("build_options", build_opts);
    cli_convert_mod.addImport("docz", docz_module);
    cli_convert_mod.addImport("html_import", html_import_mod);
    cli_convert_mod.addImport("html_export", html_export_mod);
    cli_convert_mod.addImport("md_import", md_import_mod);
    cli_convert_mod.addImport("md_export", md_export_mod);
    cli_convert_mod.addImport("latex_import", latex_import_mod);
    cli_convert_mod.addImport("latex_export", latex_export_mod);

    const cli_build_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/build_cmd.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_build_mod.addOptions("build_options", build_opts);
    cli_build_mod.addImport("docz", docz_module);

    const cli_preview_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/preview.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_preview_mod.addOptions("build_options", build_opts);
    cli_preview_mod.addImport("docz", docz_module);

    const cli_enable_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/enable_wasm.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_enable_mod.addOptions("build_options", build_opts);
    cli_enable_mod.addImport("docz", docz_module);

    const cli_common_unit = b.addTest(.{ .root_module = cli_common_mod });
    const cli_convert_unit = b.addTest(.{ .root_module = cli_convert_mod });
    const cli_build_unit = b.addTest(.{ .root_module = cli_build_mod });
    const cli_preview_unit = b.addTest(.{ .root_module = cli_preview_mod });
    const cli_enable_unit = b.addTest(.{ .root_module = cli_enable_mod });

    const cli_common_run = b.addRunArtifact(cli_common_unit);
    const cli_convert_run = b.addRunArtifact(cli_convert_unit);
    const cli_build_run = b.addRunArtifact(cli_build_unit);
    const cli_preview_run = b.addRunArtifact(cli_preview_unit);
    const cli_enable_run = b.addRunArtifact(cli_enable_unit);

    const cli_unit_step = b.step("test-cli", "Run CLI unit tests");
    cli_unit_step.dependOn(&cli_common_run.step);
    cli_unit_step.dependOn(&cli_convert_run.step);
    cli_unit_step.dependOn(&cli_build_run.step);
    cli_unit_step.dependOn(&cli_preview_run.step);
    cli_unit_step.dependOn(&cli_enable_run.step);

    // ─────────────────────────────────────────────
    // 🧪 Integration tests
    // ─────────────────────────────────────────────
    const integration_module = b.createModule(.{
        .root_source_file = b.path("tests/test_all_integration.zig"),
        .target = target,
        .optimize = optimize,
    });
    integration_module.addImport("docz", docz_module);
    integration_module.addOptions("build_options", build_opts);
    integration_module.addImport("html_import", html_import_mod);
    integration_module.addImport("html_export", html_export_mod);
    integration_module.addImport("md_import", md_import_mod);
    integration_module.addImport("md_export", md_export_mod);
    integration_module.addImport("latex_import", latex_import_mod);
    integration_module.addImport("latex_export", latex_export_mod);

    const integration_tests = b.addTest(.{ .root_module = integration_module });
    const integration_run = b.addRunArtifact(integration_tests);
    const integration_step = b.step("test-integration", "Run integration tests");
    integration_step.dependOn(&integration_run.step);

    // ─────────────────────────────────────────────
    // 🧪 End-to-end tests
    // ─────────────────────────────────────────────
    const e2e_module = b.createModule(.{
        .root_source_file = b.path("tests/test_all_e2e.zig"),
        .target = target,
        .optimize = optimize,
    });
    e2e_module.addImport("docz", docz_module);
    e2e_module.addOptions("build_options", build_opts);

    const e2e_tests = b.addTest(.{ .root_module = e2e_module });
    const e2e_run = b.addRunArtifact(e2e_tests);

    // Give tests an ABSOLUTE path to the e2e launcher and ensure it exists first.
    e2e_run.setEnvironmentVariable("DOCZ_BIN", e2e_abs);
    e2e_run.step.dependOn(&e2e_install.step);

    const e2e_step = b.step("test-e2e", "Run end-to-end tests");
    e2e_step.dependOn(&e2e_run.step);

    // ─────────────────────────────────────────────
    // 🔁 Aggregate
    // ─────────────────────────────────────────────
    const all_tests = b.step("test-all", "Run unit + integration + e2e tests");
    all_tests.dependOn(unit_step);
    all_tests.dependOn(integration_step);
    all_tests.dependOn(e2e_step);
    all_tests.dependOn(cli_unit_step);
}

<<<

`README.md`: >>>

TODO
<<<

`root.zig`: >>>

// "public API surface" (internal stuff is instead hooked up via `build.zig`)
const std = @import("std");

// ── Public modules
pub const Tokenizer = @import("src/parser/tokenizer.zig");
pub const Parser = @import("src/parser/parser.zig");
pub const AST = @import("src/parser/ast.zig");
pub const Renderer = @import("src/renderer/html.zig");

// NOTE: DO NOT import src/main.zig here (avoids module ownership conflict)

// ── Plugin system
const plugin_mod = @import("src/plugins/manager.zig");
pub const PluginManager = plugin_mod.PluginManager;
pub const Plugin = plugin_mod.Plugin;

// ── Web preview
const web_preview_server = @import("web-preview/server.zig");
const web_preview_hot_reload = @import("web-preview/hot_reload.zig");
pub const web_preview = struct {
    pub const server = web_preview_server;
    pub const hot = web_preview_hot_reload;
};

// ── Namespaces for clarity
pub const parser = struct {
    pub const tokenizer = Tokenizer;
    pub const parser = Parser;
    pub const ast = AST;
};
pub const renderer = struct {
    pub const html = Renderer;
};

// ── Minimal shim for tests that read docz.main.USAGE_TEXT
pub const main = struct {
    pub const USAGE_TEXT =
        \\Docz CLI Usage:
        \\  docz build <file.dcz>       Build .dcz file to HTML
        \\  docz preview                Start local preview server
        \\  docz enable wasm            Enable WASM execution support
        \\
    ;
};

test {
    std.testing.refAllDecls(@This());
    comptime {
        _ = web_preview.server.PreviewServer;
        _ = web_preview.hot.Broadcaster;
        _ = web_preview.hot.Sink;
    }
}

<<<

`handler.zig`: >>>

const std = @import("std");

// Import core pieces directly to avoid circular imports via root.zig
const Tokenizer = @import("../src/parser/tokenizer.zig");
const Parser = @import("../src/parser/parser.zig");
const Renderer = @import("../src/renderer/html.zig");

/// Minimal HTTP-ish response struct for the server layer to use.
pub const Response = struct {
    status_code: u16,
    mime: []const u8,
    body: []u8, // owned by caller's allocator

    pub fn deinit(self: *Response, allocator: std.mem.Allocator) void {
        allocator.free(self.body);
    }
};

/// Render a `.dcz` document (as bytes) to HTML (owned slice).
pub fn renderDoczToHtml(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    const tokens = try Tokenizer.tokenize(input, allocator);
    defer {
        // Free any token-owned lexemes before freeing the slice
        Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try Parser.parse(tokens, allocator);
    defer ast.deinit();

    return try Renderer.renderHTML(&ast, allocator);
}

/// Read a `.dcz` file from disk and render it to HTML.
/// Returns an owned HTML slice.
pub fn renderFileToHtml(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    var file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const stat = try file.stat();
    const buf = try allocator.alloc(u8, stat.size);
    defer allocator.free(buf);

    _ = try file.readAll(buf);
    return try renderDoczToHtml(allocator, buf);
}

/// Basic router that decides how to respond to a request path.
/// For now:
///   - `/`               → renders provided `default_docz_path`
///   - `/*.dcz`          → renders that file
///   - anything else     → 404
pub fn route(
    allocator: std.mem.Allocator,
    path: []const u8,
    default_docz_path: []const u8,
) !Response {
    if (std.mem.eql(u8, path, "/")) {
        const html = try renderFileToHtml(allocator, default_docz_path);
        return Response{
            .status_code = 200,
            .mime = "text/html",
            .body = html,
        };
    }

    if (std.mem.endsWith(u8, path, ".dcz")) {
        // strip leading slash
        const fs_path = if (path.len > 0 and path[0] == '/') path[1..] else path;
        const html = try renderFileToHtml(allocator, fs_path);
        return Response{
            .status_code = 200,
            .mime = "text/html",
            .body = html,
        };
    }

    // TODO: later we'll serve static assets (client JS/CSS) here too.
    const msg = "Not Found";
    const body = try allocator.dupe(u8, msg);
    return Response{
        .status_code = 404,
        .mime = "text/plain",
        .body = body,
    };
}

// ─────────────────────────────────────────────────────────────
// 🧪 Tests
// ─────────────────────────────────────────────────────────────

test "renderDoczToHtml: basic doc renders expected pieces" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const input =
        \\@meta(title="Hello")
        \\@heading(level=1) Welcome @end
        \\@code(language="zig")
        \\const x = 7;
        \\@end
    ;

    const html = try renderDoczToHtml(alloc, input);
    defer alloc.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<title>Hello</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h1>Welcome</h1>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 7;"));
}

test "renderFileToHtml: writes a temp file and renders it" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    // Create a temp .dcz file in the cwd. Use a unique-ish name.
    const filename = "handler_test_temp.dcz";
    {
        var f = try std.fs.cwd().createFile(filename, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="TempDoc")
            \\@heading(level=2) Hi From File @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(filename) catch {};

    const html = try renderFileToHtml(alloc, filename);
    defer alloc.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<title>TempDoc</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h2>Hi From File</h2>"));
}

test "route: / returns HTML for default_docz_path; 404 for unknowns" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const filename = "handler_route_default.dcz";
    {
        var f = try std.fs.cwd().createFile(filename, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="IndexDoc")
            \\@heading(level=1) Index @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(filename) catch {};

    // Root route
    var resp = try route(alloc, "/", filename);
    defer resp.deinit(alloc);
    try std.testing.expectEqual(@as(u16, 200), resp.status_code);
    try std.testing.expect(std.mem.eql(u8, resp.mime, "text/html"));
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<title>IndexDoc</title>"));

    // 404 route
    var not_found = try route(alloc, "/nope", filename);
    defer not_found.deinit(alloc);
    try std.testing.expectEqual(@as(u16, 404), not_found.status_code);
    try std.testing.expect(std.mem.eql(u8, not_found.mime, "text/plain"));
    try std.testing.expect(std.mem.containsAtLeast(u8, not_found.body, 1, "Not Found"));
}

test "route: /foo.dcz renders that explicit file" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const fname = "explicit_file.dcz";
    {
        var f = try std.fs.cwd().createFile(fname, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="Explicit")
            \\@heading(level=3) Explicit Route @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(fname) catch {};

    var resp = try route(alloc, "/explicit_file.dcz", "ignored-for-this-test.dcz");
    defer resp.deinit(alloc);

    try std.testing.expectEqual(@as(u16, 200), resp.status_code);
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<title>Explicit</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<h3>Explicit Route</h3>"));
}

<<<

`hot_reload.zig`: >>>

const std = @import("std");

/// A lightweight Server-Sent Events (SSE) utility + broadcaster
/// used by the web-preview server to push hot-reload notifications.
///
/// Usage sketch:
///   var bc = Broadcaster.init(allocator);
///   defer bc.deinit();
///   const id = try bc.add(my_sink); // where my_sink implements `Sink`
///   try bc.broadcast("reload", "examples/minimal.dcz");
///   _ = bc.remove(id);
/// A write target for SSE payloads (e.g., an HTTP response writer).
/// Implementors provide a `writeFn` that accepts the raw SSE bytes.
/// If `writeFn` errors, the broadcaster will drop that sink.
pub const Sink = struct {
    ctx: *anyopaque,
    writeFn: *const fn (ctx: *anyopaque, bytes: []const u8) anyerror!void,
};

/// Build a valid SSE event payload. Splits `data` by lines and prefixes
/// each with `data: `. Includes an `event:` line when `event` is non-empty.
/// Returns an owned buffer; caller must free.
pub fn formatSseEvent(allocator: std.mem.Allocator, event: []const u8, data: []const u8) ![]u8 {
    var buf = std.ArrayList(u8).init(allocator);
    errdefer buf.deinit();

    const w = buf.writer();

    if (event.len != 0) {
        try w.print("event: {s}\n", .{event});
    }

    var it = std.mem.splitScalar(u8, data, '\n');
    while (it.next()) |line| {
        try w.print("data: {s}\n", .{line});
    }

    // SSE event terminator: exactly one blank line
    try w.writeAll("\n");

    // 👇 unwrap the error union
    var out: []u8 = try buf.toOwnedSlice();

    // Normalize: ensure exactly one trailing '\n'
    var n = out.len;
    var tail: usize = 0;
    while (n > 0 and out[n - 1] == '\n') : (n -= 1) {
        tail += 1;
    }
    if (tail > 1) {
        out = try allocator.realloc(out, out.len - (tail - 1));
    }

    return out;
}

/// Broadcasts events to a dynamic set of sinks. On write error,
/// the failing sink is removed.
pub const Broadcaster = struct {
    const Client = struct {
        id: u64,
        sink: Sink,
    };

    allocator: std.mem.Allocator,
    clients: std.ArrayList(Client),
    next_id: u64 = 1,

    pub fn init(allocator: std.mem.Allocator) Broadcaster {
        return .{
            .allocator = allocator,
            .clients = std.ArrayList(Client).init(allocator),
            .next_id = 1,
        };
    }

    pub fn deinit(self: *Broadcaster) void {
        self.clients.deinit();
    }

    /// Add a sink; returns a unique client id.
    pub fn add(self: *Broadcaster, sink: Sink) !u64 {
        const id = self.next_id;
        self.next_id += 1;
        try self.clients.append(.{ .id = id, .sink = sink });
        return id;
    }

    /// Remove a sink by id; returns true if it existed.
    pub fn remove(self: *Broadcaster, id: u64) bool {
        var i: usize = 0;
        while (i < self.clients.items.len) : (i += 1) {
            if (self.clients.items[i].id == id) {
                _ = self.clients.orderedRemove(i);
                return true;
            }
        }
        return false;
    }

    /// Send one SSE event to all active sinks. Any sink that errors is pruned.
    pub fn broadcast(self: *Broadcaster, event: []const u8, data: []const u8) !void {
        const payload = try formatSseEvent(self.allocator, event, data);
        defer self.allocator.free(payload);

        var i: usize = 0;
        while (i < self.clients.items.len) {
            const sink = self.clients.items[i].sink;

            // Attempt write; if it errors, drop this client and DON'T advance i.
            sink.writeFn(sink.ctx, payload) catch {
                _ = self.clients.orderedRemove(i);
                continue;
            };

            // Success: advance
            i += 1;
        }
    }
};

///////////////////////
//        Tests      //
///////////////////////

test "formatSseEvent: with event and multi-line data" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try formatSseEvent(A, "reload", "a\nb\n");
    defer A.free(out);

    const expected =
        \\event: reload
        \\data: a
        \\data: b
        \\data: 
        \\
    ;
    try std.testing.expectEqualStrings(expected, out);
}

test "formatSseEvent: data only (no event line)" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try formatSseEvent(A, "", "hello");
    defer A.free(out);

    const expected =
        \\data: hello
        \\
    ;
    try std.testing.expectEqualStrings(expected, out);
}

const TestBuffer = struct {
    list: std.ArrayList(u8),

    fn init(allocator: std.mem.Allocator) TestBuffer {
        return .{ .list = std.ArrayList(u8).init(allocator) };
    }
    fn deinit(self: *TestBuffer) void {
        self.list.deinit();
    }

    fn sink(self: *TestBuffer) Sink {
        return .{
            .ctx = self,
            .writeFn = write,
        };
    }

    fn write(ctx: *anyopaque, bytes: []const u8) !void {
        var self: *TestBuffer = @ptrCast(@alignCast(ctx));
        try self.list.appendSlice(bytes);
    }
};

test "Broadcaster: add, broadcast to two sinks, remove" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var bc = Broadcaster.init(A);
    defer bc.deinit();

    var buf1 = TestBuffer.init(A);
    defer buf1.deinit();
    var buf2 = TestBuffer.init(A);
    defer buf2.deinit();

    const id1 = try bc.add(buf1.sink());
    const id2 = try bc.add(buf2.sink());

    try bc.broadcast("ping", "X");

    const expected =
        \\event: ping
        \\data: X
        \\
    ;

    try std.testing.expectEqualStrings(expected, buf1.list.items);
    try std.testing.expectEqualStrings(expected, buf2.list.items);

    try std.testing.expect(bc.remove(id1));
    try std.testing.expect(bc.remove(id2));
    try std.testing.expect(!bc.remove(9999));
}

test "Broadcaster: auto-prunes a failing sink" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var bc = Broadcaster.init(A);
    defer bc.deinit();

    // good sink
    var good = TestBuffer.init(A);
    defer good.deinit();
    _ = try bc.add(good.sink());

    // bad sink that always errors
    const Bad = struct {
        fn make() Sink {
            return .{ .ctx = undefined, .writeFn = fail };
        }
        fn fail(_: *anyopaque, _: []const u8) !void {
            return error.Disconnected;
        }
    };
    _ = try bc.add(Bad.make());

    try bc.broadcast("tick", "ok");
    // After broadcast, the bad sink should have been removed; a second broadcast still succeeds.
    try bc.broadcast("tock", "ok");

    const expected_first =
        \\event: tick
        \\data: ok
        \\
    ;
    const expected_second =
        \\event: tock
        \\data: ok
        \\
    ;
    // good buffer should have both concatenated writes
    try std.testing.expect(std.mem.indexOf(u8, good.list.items, expected_first) != null);
    try std.testing.expect(std.mem.indexOf(u8, good.list.items, expected_second) != null);
}

<<<

`server.zig`: >>>

const std = @import("std");
const hot = @import("hot_reload.zig");

// Import core pieces directly to avoid circular/self import of "docz"
const Tokenizer = @import("../src/parser/tokenizer.zig");
const Parser = @import("../src/parser/parser.zig");
const Renderer = @import("../src/renderer/html.zig");
const HtmlExport = @import("html_export");

/// Writes SSE bytes to an in-flight streaming HTTP response (currently unused).
const SinkWrap = struct {
    res_ptr: *std.http.Server.Response,

    fn make(self: *SinkWrap) hot.Sink {
        return .{ .ctx = self, .writeFn = write };
    }

    fn write(ctx: *anyopaque, bytes: []const u8) !void {
        var self: *SinkWrap = @ptrCast(@alignCast(ctx));
        try self.res_ptr.writer().writeAll(bytes);
        try self.res_ptr.flush();
    }
};

pub const PreviewServer = struct {
    allocator: std.mem.Allocator,
    doc_root: []const u8,
    broadcaster: hot.Broadcaster,

    pub fn init(allocator: std.mem.Allocator, doc_root: []const u8) !PreviewServer {
        const trimmed = try trimTrailingSlash(allocator, doc_root);
        errdefer allocator.free(trimmed);

        return .{
            .allocator = allocator,
            .doc_root = trimmed,
            .broadcaster = hot.Broadcaster.init(allocator),
        };
    }

    pub fn deinit(self: *PreviewServer) void {
        self.broadcaster.deinit();
        self.allocator.free(self.doc_root);
    }

    pub fn listenAndServe(self: *PreviewServer, port: u16) !void {
        const addr = try std.net.Address.parseIp4("127.0.0.1", port);

        var tcp = try std.net.Address.listen(addr, .{ .reuse_address = true });
        defer tcp.deinit();

        std.debug.print("🔎 web-preview listening on http://127.0.0.1:{d}\n", .{port});

        // (Optional) background watcher — harmless if the file doesn't exist.
        _ = try std.Thread.spawn(.{}, pollFileAndBroadcast, .{ &self.broadcaster, "docs/SPEC.dcz", 250 });

        while (true) {
            const t_accept = std.time.milliTimestamp();
            const net_conn = try tcp.accept();
            defer net_conn.stream.close();

            var read_buf: [16 * 1024]u8 = undefined;
            var http = std.http.Server.init(net_conn, &read_buf);

            // Serve exactly one request per TCP connection so we never “hang” on keep-alive.
            var req = http.receiveHead() catch |e| {
                std.debug.print("❌ receiveHead error after accept (+{d}ms): {s}\n", .{ std.time.milliTimestamp() - t_accept, @errorName(e) });
                continue;
            };

            // Basic request line logging
            std.debug.print("→ {s} {s}\n", .{ @tagName(req.head.method), req.head.target });

            // Handle; if it throws, send 500 so the client doesn’t spin forever.
            self.handle(&http, &req) catch |e| {
                std.debug.print("❌ handler error: {s}\n", .{@errorName(e)});
                const msg = "Internal server error\n";
                // Best-effort: try to reply; if this fails, we just close the socket.
                _ = req.respond(msg, .{
                    .status = .internal_server_error,
                    .extra_headers = &.{.{ .name = "Content-Type", .value = "text/plain; charset=utf-8" }},
                }) catch {};
            };
        }
    }

    fn handle(self: *PreviewServer, _srv: *std.http.Server, req: *std.http.Server.Request) !void {
        _ = _srv;
        const path = req.head.target;

        if (std.mem.eql(u8, stripQuery(path), "/ping")) {
            // Quick sanity check endpoint
            return req.respond("pong\n", .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/plain; charset=utf-8" }},
            });
        }

        if (std.mem.eql(u8, stripQuery(path), "/favicon.ico")) {
            return req.respond("", .{
                .status = .no_content,
                .extra_headers = &.{.{ .name = "Cache-Control", .value = "no-store" }},
            });
        }

        if (std.mem.startsWith(u8, path, "/render")) {
            const fs_path = queryParam(path, "path") orelse "docs/SPEC.dcz";
            std.debug.print("  route=/render path={s}\n", .{fs_path});
            return self.serveRenderedFragment(req, fs_path);
        }

        if (std.mem.startsWith(u8, path, "/view")) {
            const fs_path = queryParam(path, "path") orelse "docs/SPEC.dcz";
            std.debug.print("  route=/view path={s}\n", .{fs_path});
            return self.serveRenderedDcz(req, fs_path);
        }

        const safe_rel = try sanitizePath(self.allocator, path);
        defer self.allocator.free(safe_rel);

        if (safe_rel.len == 0 or std.mem.eql(u8, safe_rel, ".")) {
            std.debug.print("  route=/ (index)\n", .{});
            return self.serveIndex(req);
        }

        const candidate_a = try join2(self.allocator, self.doc_root, safe_rel);
        defer self.allocator.free(candidate_a);
        if (fileExists(candidate_a)) {
            std.debug.print("  route=static hit={s}\n", .{candidate_a});
            return self.serveFile(req, candidate_a);
        }

        const rel_html = try withHtmlExt(self.allocator, safe_rel);
        defer self.allocator.free(rel_html);
        const candidate_b = try join2(self.allocator, self.doc_root, rel_html);
        defer self.allocator.free(candidate_b);
        if (fileExists(candidate_b)) {
            std.debug.print("  route=static hit={s}\n", .{candidate_b});
            return self.serveFile(req, candidate_b);
        }

        std.debug.print("  route=fallback → index\n", .{});
        return self.serveIndex(req);
    }

    // Placeholder (no streaming in this snapshot).
    fn handleSSE(self: *PreviewServer, req: *std.http.Server.Request) !void {
        _ = self;
        const body = "SSE not enabled on this Zig build.\n";
        return req.respond(body, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/plain; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
                .{ .name = "Connection", .value = "keep-alive" },
                .{ .name = "Access-Control-Allow-Origin", .value = "*" },
            },
        });
    }

    fn serveIndex(self: *PreviewServer, req: *std.http.Server.Request) !void {
        const html = try buildIndexHtml(self.allocator);
        defer self.allocator.free(html);

        const cl = try u64ToTmp(self.allocator, html.len);
        // It's fine to leak per-request a tiny header string for now; you can pool later.
        return req.respond(html, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Content-Length", .value = cl },
                .{ .name = "Cache-Control", .value = "no-cache" },
                .{ .name = "Connection", .value = "close" },
            },
        });
    }

    fn serveRenderedDcz(self: *PreviewServer, req: *std.http.Server.Request, fs_path: []const u8) !void {
        const A = self.allocator;

        const t0 = std.time.milliTimestamp();
        const input = readFileAlloc(A, fs_path) catch |e| {
            std.debug.print("  read FAIL {s}: {s}\n", .{ fs_path, @errorName(e) });
            const body = try std.fmt.allocPrint(A, "<pre>Failed to read {s}: {s}</pre>", .{ fs_path, @errorName(e) });
            defer A.free(body);
            return req.respond(body, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer A.free(input);
        std.debug.print("  read ok {s} ({d} bytes, {d}ms)\n", .{ fs_path, input.len, std.time.milliTimestamp() - t0 });

        const t1 = std.time.milliTimestamp();
        const tokens = Tokenizer.tokenize(input, A) catch |e| {
            const msg = try std.fmt.allocPrint(
                A,
                "<pre>Tokenizer error: {s}\n(unterminated directive params or invalid syntax?)</pre>",
                .{@errorName(e)},
            );
            defer A.free(msg);
            return req.respond(msg, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer {
            Tokenizer.freeTokens(A, tokens);
            A.free(tokens);
        }
        std.debug.print("  tokenize ok ({d} tokens, {d}ms)\n", .{ tokens.len, std.time.milliTimestamp() - t1 });

        const t2 = std.time.milliTimestamp();
        var ast = try Parser.parse(tokens, A);
        defer ast.deinit();
        std.debug.print("  parse ok ({d} nodes, {d}ms)\n", .{ ast.children.items.len, std.time.milliTimestamp() - t2 });

        const t3 = std.time.milliTimestamp();
        const html = try HtmlExport.exportHtml(&ast, A);
        defer A.free(html);
        std.debug.print("  render ok ({d} bytes, {d}ms)\n", .{ html.len, std.time.milliTimestamp() - t3 });

        return req.respond(html, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
            },
        });
    }

    fn serveRenderedFragment(self: *PreviewServer, req: *std.http.Server.Request, fs_path: []const u8) !void {
        const A = self.allocator;

        const t0 = std.time.milliTimestamp();
        const input = readFileAlloc(A, fs_path) catch |e| {
            std.debug.print("  read FAIL {s}: {s}\n", .{ fs_path, @errorName(e) });
            const body = try std.fmt.allocPrint(A, "<pre>Failed to read {s}: {s}</pre>", .{ fs_path, @errorName(e) });
            defer A.free(body);
            return req.respond(body, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer A.free(input);
        std.debug.print("  read ok {s} ({d} bytes, {d}ms)\n", .{ fs_path, input.len, std.time.milliTimestamp() - t0 });

        const t1 = std.time.milliTimestamp();
        const tokens = Tokenizer.tokenize(input, A) catch |e| {
            const msg = try std.fmt.allocPrint(
                A,
                "<pre>Tokenizer error: {s}\n(unterminated directive params or invalid syntax?)</pre>",
                .{@errorName(e)},
            );
            defer A.free(msg);
            return req.respond(msg, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer {
            Tokenizer.freeTokens(A, tokens);
            A.free(tokens);
        }
        std.debug.print("  tokenize ok ({d} tokens, {d}ms)\n", .{ tokens.len, std.time.milliTimestamp() - t1 });

        const t2 = std.time.milliTimestamp();
        var ast = try Parser.parse(tokens, A);
        defer ast.deinit();
        std.debug.print("  parse ok ({d} nodes, {d}ms)\n", .{ ast.children.items.len, std.time.milliTimestamp() - t2 });

        const t3 = std.time.milliTimestamp();
        const full = try Renderer.renderHTML(&ast, A);
        defer A.free(full);
        std.debug.print("  render ok ({d} bytes, {d}ms)\n", .{ full.len, std.time.milliTimestamp() - t3 });

        const t4 = std.time.milliTimestamp();
        const frag = try extractBodyFragment(A, full);
        defer A.free(frag);
        std.debug.print("  extract body ok ({d} bytes, {d}ms)\n", .{ frag.len, std.time.milliTimestamp() - t4 });

        return req.respond(frag, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
            },
        });
    }

    fn serveFile(self: *PreviewServer, req: *std.http.Server.Request, abs_path: []const u8) !void {
        var file = try std.fs.cwd().openFile(abs_path, .{});
        defer file.close();

        const stat = try file.stat();
        const buf = try self.allocator.alloc(u8, stat.size);
        defer self.allocator.free(buf);

        const n = try file.readAll(buf);
        const ctype = mimeFromPath(abs_path);

        return req.respond(buf[0..n], .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = ctype },
                .{ .name = "Content-Length", .value = try u64ToTmp(self.allocator, n) },
            },
        });
    }
};

/////////////////////////////
//   Helper functions     //
/////////////////////////////

fn u64ToTmp(allocator: std.mem.Allocator, v: u64) ![]const u8 {
    return std.fmt.allocPrint(allocator, "{d}", .{v});
}

fn trimTrailingSlash(allocator: std.mem.Allocator, s: []const u8) ![]const u8 {
    var end = s.len;
    while (end > 0 and s[end - 1] == '/') end -= 1;
    return allocator.dupe(u8, s[0..end]);
}

/// Prevent path traversal. Returns normalized relative path without leading '/'.
fn sanitizePath(allocator: std.mem.Allocator, raw: []const u8) ![]u8 {
    var norm = std.ArrayList(u8).init(allocator);
    defer norm.deinit();
    try norm.ensureTotalCapacity(raw.len);
    for (raw) |c| try norm.append(if (c == '\\') '/' else c);

    var segs = std.ArrayList([]const u8).init(allocator);
    defer segs.deinit();

    var it = std.mem.splitScalar(u8, norm.items, '/');
    var depth: usize = 0;
    while (it.next()) |seg| {
        if (seg.len == 0 or std.mem.eql(u8, seg, ".")) continue;
        if (std.mem.eql(u8, seg, "..")) {
            if (depth == 0) return allocator.alloc(u8, 0);
            segs.items.len -= 1;
            depth -= 1;
            continue;
        }
        var ok = true;
        for (seg) |ch| {
            if (!(std.ascii.isAlphanumeric(ch) or ch == '-' or ch == '_' or ch == '.')) {
                ok = false;
                break;
            }
        }
        if (!ok) return allocator.alloc(u8, 0);
        try segs.append(seg);
        depth += 1;
    }

    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    var first = true;
    for (segs.items) |seg| {
        if (!first) try out.append('/');
        first = false;
        try out.appendSlice(seg);
    }
    return out.toOwnedSlice();
}

fn withHtmlExt(allocator: std.mem.Allocator, rel: []const u8) ![]const u8 {
    return std.fmt.allocPrint(allocator, "{s}.html", .{rel});
}

fn join2(allocator: std.mem.Allocator, a: []const u8, b: []const u8) ![]const u8 {
    if (a.len == 0) return allocator.dupe(u8, b);
    if (b.len == 0) return allocator.dupe(u8, a);
    if (a[a.len - 1] == '/') return std.fmt.allocPrint(allocator, "{s}{s}", .{ a, b });
    return std.fmt.allocPrint(allocator, "{s}/{s}", .{ a, b });
}

fn fileExists(abs_path: []const u8) bool {
    std.fs.cwd().access(abs_path, .{}) catch return false;
    return true;
}

fn mimeFromPath(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, ".html")) return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".htm")) return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".css")) return "text/css; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".js")) return "text/javascript; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".json")) return "application/json; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".svg")) return "image/svg+xml";
    if (std.mem.endsWith(u8, path, ".png")) return "image/png";
    if (std.mem.endsWith(u8, path, ".jpg") or std.mem.endsWith(u8, path, ".jpeg")) return "image/jpeg";
    if (std.mem.endsWith(u8, path, ".gif")) return "image/gif";
    if (std.mem.endsWith(u8, path, ".txt")) return "text/plain; charset=utf-8";
    return "application/octet-stream";
}

fn stripQuery(p: []const u8) []const u8 {
    return p[0 .. std.mem.indexOfScalar(u8, p, '?') orelse p.len];
}

fn queryParam(target: []const u8, key: []const u8) ?[]const u8 {
    const qpos = std.mem.indexOfScalar(u8, target, '?') orelse return null;
    var it = std.mem.splitScalar(u8, target[qpos + 1 ..], '&');
    while (it.next()) |kv| {
        if (kv.len == 0) continue;
        const eq = std.mem.indexOfScalar(u8, kv, '=') orelse continue;
        if (std.mem.eql(u8, kv[0..eq], key)) return kv[eq + 1 ..];
    }
    return null;
}

fn readFileAlloc(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    return try f.readToEndAlloc(allocator, 1 << 26);
}

// Poll a file and broadcast "reload" on mtime change (kept for future SSE use).
fn pollFileAndBroadcast(b: *hot.Broadcaster, path: []const u8, ms: u64) !void {
    var last: u64 = 0;
    while (true) {
        const mt = fileMtime(path) catch 0;
        if (mt != 0 and mt != last) {
            if (last != 0) try b.broadcast("reload", path);
            last = mt;
        }
        std.Thread.sleep(ms * std.time.ns_per_ms);
    }
}

fn fileMtime(path: []const u8) !u64 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    const s = try f.stat();
    return @intCast(s.mtime);
}

/// Extract inner <body>…</body> from full HTML; if no <body>, return whole.
fn extractBodyFragment(allocator: std.mem.Allocator, full: []const u8) ![]u8 {
    const open_idx = std.mem.indexOf(u8, full, "<body");
    if (open_idx == null) return allocator.dupe(u8, full);

    const after_open_gt = std.mem.indexOfScalarPos(u8, full, open_idx.?, '>') orelse return allocator.dupe(u8, full);
    const rest = full[after_open_gt + 1 ..];
    const close_idx_rel = std.mem.indexOf(u8, rest, "</body>");
    if (close_idx_rel == null) return allocator.dupe(u8, rest);

    const inner = rest[0..close_idx_rel.?];
    return allocator.dupe(u8, inner);
}

fn buildIndexHtml(allocator: std.mem.Allocator) ![]u8 {
    const tpl =
        \\<!DOCTYPE html>
        \\<html>
        \\<head>
        \\  <meta charset="UTF-8" />
        \\  <meta name="viewport" content="width=device-width, initial-scale=1" />
        \\  <title>Docz Web Preview</title>
        \\  <script>
        \\    (function () {
        \\      // Allow ?path=... override; default to docs/SPEC.dcz
        \\      const qs = new URLSearchParams(location.search);
        \\      const path = qs.get('path') || 'docs/SPEC.dcz';
        \\      const url = '/view?path=' + encodeURIComponent(path);
        \\      // Use replace() so Back button doesn’t bounce through the index shell
        \\      location.replace(url);
        \\    })();
        \\  </script>
        \\</head>
        \\<body>
        \\  <noscript>
        \\    <p>Preview requires JS to redirect. Open <code>/view?path=docs/SPEC.dcz</code>.</p>
        \\  </noscript>
        \\</body>
        \\</html>
    ;
    return allocator.dupe(u8, tpl);
}

fn isClientStillRegistered(bc: *const hot.Broadcaster, id: u64) bool {
    for (bc.clients.items) |c| if (c.id == id) return true;
    return false;
}

test "mimeFromPath basics" {
    try std.testing.expectEqualStrings("text/html; charset=utf-8", mimeFromPath("x.html"));
    try std.testing.expectEqualStrings("text/css; charset=utf-8", mimeFromPath("x.css"));
    try std.testing.expectEqualStrings("image/png", mimeFromPath("x.png"));
    try std.testing.expectEqualStrings("application/octet-stream", mimeFromPath("x.bin"));
}

<<<

`package.json`: >>>


<<<

`extension.ts`: >>>


<<<

`test_all_e2e.zig`: >>>

const std = @import("std");

comptime {
    _ = @import("e2e/cli_usage.zig");
    _ = @import("e2e/file_to_html.zig");
    _ = @import("e2e/enable_wasm.zig");
    _ = @import("e2e/convert_cli.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`test_all_integration.zig`: >>>

const std = @import("std");

comptime {
    _ = @import("integration/tokenizer.zig");
    _ = @import("integration/parser.zig");
    _ = @import("integration/renderer.zig");
    _ = @import("integration/pipeline.zig");
    _ = @import("integration/convert_html_import.zig");
    _ = @import("integration/latex_roundtrip.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`convert_html_import.zig`: >>>

const std = @import("std");
const html_import = @import("html_import"); // wired in build.zig

test "integration: HTML import produces expected dcz" {
    const html =
        \\<html><head><title>T</title>
        \\  <meta name="author" content="Docz Team">
        \\</head>
        \\<body><h1>Hi</h1><p>Para</p></body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try html_import.importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "@meta(title=\"T\") @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@meta(author=\"Docz Team\") @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@heading(level=1) Hi @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "Para\n") != null);
}

test "integration: images and <pre><code class=language-*> blocks" {
    const html =
        \\<html><body>
        \\  <img src="/img/logo.png" alt="x">
        \\  <pre><code class="language-zig">const x = 42;</code></pre>
        \\</body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try html_import.importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "@image(src=\"/img/logo.png\") @end") != null);

    // minimal check for a code block with the right language and body
    try std.testing.expect(std.mem.indexOf(u8, out,
        \\@code(language="zig")
    ) != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "const x = 42;") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@end\n") != null);
}

<<<

`latex_roundtrip.zig`: >>>

const std = @import("std");
const docz = @import("docz");

// internal converter modules from build.zig
const latex_import = @import("latex_import");
const latex_export = @import("latex_export");

// ── helpers ──────────────────────────────────────────────────────────────────

fn trimRightSpaces(line: []const u8) []const u8 {
    return std.mem.trimRight(u8, line, " \t\r");
}

/// Normalize LaTeX for comparison:
/// - Trim trailing spaces per line
/// - Collapse 3+ consecutive newlines → 2 newlines
/// - Trim leading/trailing blank lines
/// - Ensure single trailing newline
fn normalizeLatex(alloc: std.mem.Allocator, s: []const u8) ![]u8 {
    var tmp = std.ArrayList(u8).init(alloc);
    defer tmp.deinit();

    // 1) trim trailing spaces line-by-line
    var it = std.mem.tokenizeScalar(u8, s, '\n');
    var first_line = true;
    while (it.next()) |line| {
        const t = trimRightSpaces(line);
        if (!first_line) try tmp.append('\n');
        try tmp.appendSlice(t);
        first_line = false;
    }

    // 2) collapse >2 newlines → exactly 2
    var out = std.ArrayList(u8).init(alloc);
    var i: usize = 0;
    var nl_count: usize = 0;
    while (i < tmp.items.len) : (i += 1) {
        const c = tmp.items[i];
        if (c == '\n') {
            nl_count += 1;
            if (nl_count <= 2) try out.append('\n');
        } else {
            nl_count = 0;
            try out.append(c);
        }
    }

    // 3) trim leading/trailing newlines
    var start: usize = 0;
    while (start < out.items.len and out.items[start] == '\n') start += 1;

    var end: usize = out.items.len;
    while (end > start and out.items[end - 1] == '\n') end -= 1;

    // 4) build final buffer; deinit 'out' to avoid leaks
    var final_buf = std.ArrayList(u8).init(alloc);
    if (end > start) try final_buf.appendSlice(out.items[start..end]);
    try final_buf.append('\n');
    out.deinit();

    return final_buf.toOwnedSlice();
}

// ── tests ────────────────────────────────────────────────────────────────────

test "integration: LaTeX ↔ DCZ round-trip via AST (baseline sample)" {
    // Use plain strings + '\n' to avoid confusion with Zig's '\\' line-prefix macro.
    const tex_input =
        \\\title{Roundtrip Spec}
        \\\author{Docz}
        \\
        \\\section{Intro}
        \\Hello world paragraph.
        \\
        \\\subsection{Code}
        \\\begin{verbatim}
        \\const x = 1;
        \\\end{verbatim}
        \\
        \\\begin{equation}
        \\E = mc^2
        \\\end{equation}
        \\
        \\\includegraphics{img/logo.png}
        \\
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    // 1) LaTeX → DCZ
    const dcz = try latex_import.importLatexToDcz(A, tex_input);
    defer A.free(dcz);

    // 2) DCZ → tokens → AST
    const tokens = try docz.Tokenizer.tokenize(dcz, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }
    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit();

    // 3) AST → LaTeX
    const tex_output = try latex_export.exportAstToLatex(&ast, A);
    defer A.free(tex_output);

    // 4) Normalize + compare
    const n_in = try normalizeLatex(A, tex_input);
    defer A.free(n_in);
    const n_out = try normalizeLatex(A, tex_output);
    defer A.free(n_out);

    try std.testing.expectEqualStrings(n_in, n_out);
}

test "integration: heading level clamp (>=4 → \\subsubsection{})" {
    const tex_input =
        \\\title{Clamp}
        \\
        \\\section{Top}
        \\Para.
        \\
        \\\subsubsection{Deep A}
        \\\subsubsection{Deep B}
        \\
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const dcz = try latex_import.importLatexToDcz(A, tex_input);
    defer A.free(dcz);

    const tokens = try docz.Tokenizer.tokenize(dcz, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }
    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit();

    const tex_output = try latex_export.exportAstToLatex(&ast, A);
    defer A.free(tex_output);

    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\section{Top}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\subsubsection{Deep A}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\subsubsection{Deep B}") != null);

    const n_in = try normalizeLatex(A, tex_input);
    defer A.free(n_in);
    const n_out = try normalizeLatex(A, tex_output);
    defer A.free(n_out);
    try std.testing.expectEqualStrings(n_in, n_out);
}

<<<

`parser.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "integration: parser builds AST from token list" {
    const input =
        \\@heading(level=2) Heading @end
        \\Some paragraph text with *emphasis*.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit();

    // std.debug.print("🌲 AST has {d} top-level nodes\n", .{ast.children.items.len});
    try std.testing.expect(ast.children.items.len >= 1);
}

<<<

`pipeline.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "🔁 Full pipeline integration: .dcz input → HTML output" {
    const input_docz =
        \\@meta(title="Integration Test", author="Docz Team") @end
        \\@heading(level=2) Hello, Docz! @end
        \\@code(language="zig")
        \\const x = 123;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    // std.debug.print("\n🔧 Tokenizing...\n", .{});
    const tokens = try docz.Tokenizer.tokenize(input_docz, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens); // frees any heap-allocated lexemes
        allocator.free(tokens); // frees the tokens slice itself ✅
    }

    // std.debug.print("✅ Tokenized {d} tokens\n", .{tokens.len});

    // std.debug.print("\n🧠 Parsing to AST...\n", .{});
    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit();
    // std.debug.print("✅ AST contains {d} top-level nodes\n", .{ast.children.items.len});

    // std.debug.print("\n🎨 Rendering HTML...\n", .{});
    const html = try docz.Renderer.renderHTML(&ast, allocator);
    defer allocator.free(html);
    // std.debug.print("✅ HTML output size: {d} bytes\n", .{html.len});

    // std.debug.print("\n🔍 Checking HTML contents...\n", .{});
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h2>Hello, Docz!</h2>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 123;"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "Integration Test"));
    // std.debug.print("✅ All checks passed.\n", .{});
}

<<<

`renderer.zig`: >>>

const std = @import("std");
const docz = @import("docz");

pub const _force_test_discovery = true;

test "integration: renderer produces HTML from simple AST" {
    const input =
        \\@heading(level=3) Render Test @end
        \\Code below:
        \\@code(language="zig")
        \\const x = 9;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    // Tokenize
    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    // IMPORTANT: since we'll parse, the AST owns any lexeme strings.
    // Only free the *slice* here (no Tokenizer.freeTokens).
    defer allocator.free(tokens);

    // Parse → AST takes ownership of token lexemes
    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit();

    // Render
    const html = try docz.Renderer.renderHTML(&ast, allocator);
    defer allocator.free(html);

    // std.debug.print("🖨️  Rendered HTML:\n{s}\n", .{html});

    // Assertions
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h3>Render Test</h3>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 9;"));
}

<<<

`tokenizer.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "integration: tokenizer produces correct tokens from .dcz input" {
    const input =
        \\@heading(level=1) Hello, Docz! @end
        \\This is a **test** of the tokenizer.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer std.debug.assert(gpa.deinit() == .ok);

    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    defer {
        // IMPORTANT: free allocated lexemes first, then the slice itself
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    // std.debug.print("📦 Tokenizer produced {d} tokens:\n", .{tokens.len});
    // for (tokens, 0..) |tok, i| {
    //     std.debug.print("  [{d}] {s} : {s}\n", .{ i, @tagName(tok.kind), tok.lexeme });
    // }

    try std.testing.expect(tokens.len > 2);
}

<<<

`cli_usage.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "🧪 CLI Usage Text Contains 'docz build'" {
    const usage = docz.main.USAGE_TEXT;

    // std.debug.print("\n📋 CLI USAGE TEXT:\n{s}\n", .{usage});
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "docz build"));
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "docz preview"));
}

<<<

`convert_cli.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");
const build_options = @import("build_options");

// ─────────────────────────────────────────────────────────────────────────────
// Small path helpers (owned results)
// ─────────────────────────────────────────────────────────────────────────────

fn pathJoin2(alloc: std.mem.Allocator, a: []const u8, b: []const u8) ![]u8 {
    var list = std.ArrayList([]const u8).init(alloc);
    defer list.deinit();
    try list.append(a);
    try list.append(b);
    return std.fs.path.join(alloc, list.items);
}

fn pathJoin3(alloc: std.mem.Allocator, a: []const u8, b: []const u8, c: []const u8) ![]u8 {
    var list = std.ArrayList([]const u8).init(alloc);
    defer list.deinit();
    try list.append(a);
    try list.append(b);
    try list.append(c);
    return std.fs.path.join(alloc, list.items);
}

fn dirExistsAbs(abs_path: []const u8) bool {
    var d = std.fs.openDirAbsolute(abs_path, .{}) catch return false;
    d.close();
    return true;
}

// ─────────────────────────────────────────────────────────────────────────────
// Repo/CWD anchor (stable for test runner)
// ─────────────────────────────────────────────────────────────────────────────

fn repoRootFromCwd(alloc: std.mem.Allocator) ![]u8 {
    return std.fs.cwd().realpathAlloc(alloc, ".");
}

// ─────────────────────────────────────────────────────────────────────────────
// Launcher discovery (no nested functions)
// Strategy:
//   1) Prefer build_options.e2e_abspath (absolute, set by build.zig)
//   2) Find-up from CWD for zig-out/bin/docz-e2e(.exe)
//   3) Find-up from CWD for zig-out/bin/docz(.exe)
//   4) Fallback to build_options.docz_abspath (absolute)
// Emits strong diagnostics on failure.
// ─────────────────────────────────────────────────────────────────────────────

fn tryOpenAbs(p: []const u8) bool {
    if (!std.fs.path.isAbsolute(p)) return false;
    const f = std.fs.openFileAbsolute(p, .{}) catch return false;
    f.close();
    return true;
}

fn findUpFile(
    alloc: std.mem.Allocator,
    start_abs: []const u8,
    rel: []const u8,
    max_up: usize,
) !?[]u8 {
    if (!std.fs.path.isAbsolute(start_abs)) return null;

    var cur = try alloc.dupe(u8, start_abs);
    defer alloc.free(cur);

    var i: usize = 0;
    while (true) : (i += 1) {
        if (i > max_up) break;

        const cand = try std.fs.path.join(alloc, &[_][]const u8{ cur, rel });
        if (std.fs.openFileAbsolute(cand, .{})) |f| {
            f.close();
            return cand; // owned
        } else |e| {
            switch (e) {
                error.FileNotFound => {},
                else => {},
            }
        }
        alloc.free(cand);

        const parent_opt = std.fs.path.dirname(cur);
        if (parent_opt == null) break;

        const parent = parent_opt.?;
        const dup = try alloc.dupe(u8, parent);
        alloc.free(cur);
        cur = dup;
    }
    return null;
}

fn ensureE2ELauncher(alloc: std.mem.Allocator) ![]u8 {
    const e2e_name = if (builtin.os.tag == .windows) "docz-e2e.exe" else "docz-e2e";
    const docz_name = if (builtin.os.tag == .windows) "docz.exe" else "docz";

    // 1) baked e2e absolute (most reliable)
    if (@hasDecl(build_options, "e2e_abspath")) {
        const baked = build_options.e2e_abspath;
        if (tryOpenAbs(baked)) return try alloc.dupe(u8, baked);
    }

    // 2) find-up: zig-out/bin/docz-e2e*
    const cwd_abs = try std.fs.cwd().realpathAlloc(alloc, ".");
    defer alloc.free(cwd_abs);

    const rel_e2e = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", "bin", e2e_name });
    defer alloc.free(rel_e2e);
    if (try findUpFile(alloc, cwd_abs, rel_e2e, 8)) |hit| return hit;

    // 3) find-up: zig-out/bin/docz*  (use docz directly if e2e isn’t present)
    const rel_docz = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", "bin", docz_name });
    defer alloc.free(rel_docz);
    if (try findUpFile(alloc, cwd_abs, rel_docz, 8)) |hit| return hit;

    // 4) baked docz absolute
    if (@hasDecl(build_options, "docz_abspath")) {
        const baked_docz = build_options.docz_abspath;
        if (tryOpenAbs(baked_docz)) return try alloc.dupe(u8, baked_docz);
    }

    // diagnostics
    std.debug.print(
        "[ensureE2ELauncher] Could not find a runnable CLI.\n" ++
            "  Tried (in order):\n" ++
            "    • build_options.e2e_abspath\n" ++
            "    • find-up from CWD for \"zig-out/bin/{s}\"\n" ++
            "    • find-up from CWD for \"zig-out/bin/{s}\"\n" ++
            "    • build_options.docz_abspath\n" ++
            "  CWD: {s}\n",
        .{ e2e_name, docz_name, cwd_abs },
    );

    return error.FileNotFound;
}

// ─────────────────────────────────────────────────────────────────────────────
// Test workspace helper (under <repo>/zig-out)
// ─────────────────────────────────────────────────────────────────────────────

fn makeWorkDir(alloc: std.mem.Allocator) !struct { dir: std.fs.Dir, abs: []u8 } {
    const repo_abs = try repoRootFromCwd(alloc);
    defer alloc.free(repo_abs);

    const base_abs = if (dirExistsAbs(repo_abs))
        try alloc.dupe(u8, repo_abs)
    else
        try std.fs.cwd().realpathAlloc(alloc, ".");
    defer alloc.free(base_abs);

    var base_dir = try std.fs.openDirAbsolute(base_abs, .{});
    defer base_dir.close();

    try base_dir.makePath("zig-out");

    var name_buf: [64]u8 = undefined;
    const sub = try std.fmt.bufPrint(&name_buf, "e2e_cli_test-{d}", .{std.time.milliTimestamp()});
    const sub_rel = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", sub });
    defer alloc.free(sub_rel);

    try base_dir.makePath(sub_rel);

    const abs = try pathJoin3(alloc, base_abs, "zig-out", sub);
    const dir = try std.fs.openDirAbsolute(abs, .{ .iterate = false });

    return .{ .dir = dir, .abs = abs };
}

// ─────────────────────────────────────────────────────────────────────────────
// The actual e2e test
// ─────────────────────────────────────────────────────────────────────────────

test "e2e: docz convert dcz→tex and tex→dcz" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const dcz_input =
        \\@meta(title="T") @end
        \\@heading(level=1) Hello @end
        \\Para
        \\
    ;

    var work_bundle = try makeWorkDir(A);
    defer {
        work_bundle.dir.close();
        A.free(work_bundle.abs);
    }
    const work = work_bundle.dir;
    const work_abs = work_bundle.abs;

    const in_path = try pathJoin2(A, work_abs, "in.dcz");
    defer A.free(in_path);
    const out_path = try pathJoin2(A, work_abs, "out.tex");
    defer A.free(out_path);
    const back_path = try pathJoin2(A, work_abs, "back.dcz");
    defer A.free(back_path);

    {
        var f = try work.createFile("in.dcz", .{ .truncate = true });
        defer f.close();
        _ = try f.writeAll(dcz_input);
    }

    const exe_path = try ensureE2ELauncher(A);
    defer A.free(exe_path);

    {
        var child = std.process.Child.init(
            &[_][]const u8{ exe_path, "convert", in_path, "--to", out_path },
            A,
        );
        try child.spawn();
        const term = try child.wait();
        try std.testing.expectEqual(std.process.Child.Term{ .Exited = 0 }, term);
    }

    const tex = blk: {
        var f = try work.openFile("out.tex", .{});
        defer f.close();
        break :blk try f.readToEndAlloc(A, 1 << 20);
    };
    defer A.free(tex);

    try std.testing.expect(std.mem.indexOf(u8, tex, "\\title{T}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\section{Hello}") != null);

    {
        var child = std.process.Child.init(
            &[_][]const u8{ exe_path, "convert", out_path, "--to", back_path },
            A,
        );
        try child.spawn();
        const term = try child.wait();
        try std.testing.expectEqual(std.process.Child.Term{ .Exited = 0 }, term);
    }

    const back = blk2: {
        var f = try work.openFile("back.dcz", .{});
        defer f.close();
        break :blk2 try f.readToEndAlloc(A, 1 << 20);
    };
    defer A.free(back);

    try std.testing.expect(std.mem.indexOf(u8, back, "@heading(level=1) Hello @end") != null);
}

<<<

`enable_wasm.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "🔧 Enable WASM Command Listed in Usage" {
    const usage = docz.main.USAGE_TEXT;

    std.debug.print("\n🔍 Verifying 'enable wasm' appears in help output...\n", .{});
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "enable wasm"));
}

<<<

`file_to_html.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const tokenizer = docz.parser.tokenizer;
const parser = docz.parser.parser;
const renderer = docz.renderer.html;

test "📄 Parse and render a basic .dcz file to HTML" {
    const input =
        \\@meta(title="Hello")
        \\@heading(level=1) Welcome to Docz @end
        \\@code(language="zig")
        \\const x = 42;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer std.debug.assert(gpa.deinit() == .ok);

    const tokens = try tokenizer.tokenize(input, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try parser.parse(tokens, allocator);
    defer ast.deinit();

    const html = try renderer.renderHTML(&ast, allocator);
    defer allocator.free(html);

    // std.debug.print("\n🖨️ Rendered HTML Output:\n{s}\n", .{html});

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h1>Welcome to Docz</h1>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 42;"));
}

<<<

`main.zig`: >>>

const std = @import("std");

// Thin CLI dispatcher: each subcommand lives in src/cli/*.zig
const cli_convert = @import("cli/convert.zig");
const cli_build_cmd = @import("cli/build_cmd.zig");
const cli_preview = @import("cli/preview.zig");
const cli_enable = @import("cli/enable_wasm.zig");
const cli_run = @import("cli/run.zig"); // ← new

/// Global constant for CLI usage text (keeps original lines; adds convert/export + run)
pub const USAGE_TEXT =
    \\Docz CLI Usage:
    \\  docz build <file.dcz>       Build .dcz file to HTML
    \\  docz preview                Start local preview server
    \\  docz run <file.dcz>         Convert to temp dir and serve; rebuild on change
    \\                               Options: [--port <num>] [--css inline|file] [--no-pretty]
    \\  docz enable wasm            Enable WASM execution support
    \\  docz convert <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]
    \\  docz export  <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]
    \\
;

/// CLI entry point: parse args → dispatch to subcommand module.
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var it = try std.process.argsWithAllocator(A);
    defer it.deinit();

    _ = it.next(); // program name
    const cmd = it.next() orelse {
        printUsage();
        return;
    };

    // Dispatch table
    if (std.mem.eql(u8, cmd, "build")) {
        try cli_build_cmd.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "preview")) {
        try cli_preview.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "run")) {
        try cli_run.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "enable")) {
        // enable_wasm expects the next token to be "wasm"
        try cli_enable.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "convert") or std.mem.eql(u8, cmd, "export")) {
        try cli_convert.run(A, &it);
        return;
    }

    printUsage();
}

/// Prints usage help text (no std.io handles → portable across nightlies)
fn printUsage() void {
    // std.debug.print writes to stderr on most toolchains; that’s fine for usage/help.
    std.debug.print("{s}", .{USAGE_TEXT});
}

// Simple test for CLI usage message
test "CLI usage message prints" {
    var buffer: [1024]u8 = undefined;
    var fbs = std.io.fixedBufferStream(&buffer);
    const writer = fbs.writer();

    try writer.writeAll(USAGE_TEXT);

    const written = fbs.getWritten();
    try std.testing.expect(std.mem.indexOf(u8, written, "docz build") != null);
}

<<<

`testutil.zig`: >>>

const std = @import("std");

pub const VERBOSE = @import("build_options").verbose_tests;

pub inline fn vprint(comptime fmt: []const u8, args: anytype) void {
    if (!VERBOSE) return;
    std.debug.print(fmt, args);
}

<<<

`html.zig`: >>>

const std = @import("std");
const ASTNode = @import("../parser/ast.zig").ASTNode;
const NodeType = @import("../parser/ast.zig").NodeType;

// ---- helpers ----
fn lessStr(_: void, a: []const u8, b: []const u8) bool {
    return std.mem.lessThan(u8, a, b);
}

fn styleKeyPriority(k: []const u8) u8 {
    if (std.mem.eql(u8, k, "font-size")) return 0; // ensure font-size first
    if (std.mem.eql(u8, k, "color")) return 1; // then color
    return 100; // others later
}

fn styleKeyLess(_: void, a: []const u8, b: []const u8) bool {
    const pa = styleKeyPriority(a);
    const pb = styleKeyPriority(b);
    if (pa != pb) return pa < pb; // priority first
    return std.mem.lessThan(u8, a, b); // then lexicographic
}

/// Converts attributes → inline CSS string; excludes non-style keys (like "mode")
fn buildInlineStyle(attributes: std.StringHashMap([]const u8), allocator: std.mem.Allocator) ![]u8 {
    var keys = std.ArrayList([]const u8).init(allocator);
    defer keys.deinit();

    var it = attributes.iterator();
    while (it.next()) |entry| {
        const k = entry.key_ptr.*;
        if (std.mem.eql(u8, k, "mode")) continue; // exclude control key
        try keys.append(k);
    }

    // sort with priority
    std.mem.sort([]const u8, keys.items, {}, styleKeyLess);

    var out = std.ArrayList(u8).init(allocator);
    const w = out.writer();

    var first = true;
    for (keys.items) |k| {
        const v = attributes.get(k).?;
        if (!first) try w.print(";", .{});
        try w.print("{s}:{s}", .{ k, v });
        first = false;
    }
    try w.print(";", .{}); // trailing ; expected by the test

    return out.toOwnedSlice();
}

/// Converts style-def content into CSS
fn buildGlobalCSS(styleContent: []const u8, allocator: std.mem.Allocator) ![]u8 {
    var builder = std.ArrayList(u8).init(allocator);
    const writer = builder.writer();

    var lines = std.mem.tokenizeScalar(u8, styleContent, '\n');
    while (lines.next()) |line| {
        var trimmed = std.mem.trim(u8, line, " \t\r");
        if (trimmed.len == 0) continue;

        const colonIndex = std.mem.indexOfScalar(u8, trimmed, ':') orelse continue;
        const className = std.mem.trim(u8, trimmed[0..colonIndex], " \t");
        const propsRaw = std.mem.trim(u8, trimmed[colonIndex + 1 ..], " \t");

        try writer.print(".{s} {{ ", .{className});

        var propsIter = std.mem.tokenizeScalar(u8, propsRaw, ',');
        var first = true;
        while (propsIter.next()) |prop| {
            var cleanProp = std.mem.trim(u8, prop, " \t");
            const eqIndex = std.mem.indexOfScalar(u8, cleanProp, '=') orelse continue;
            const key = std.mem.trim(u8, cleanProp[0..eqIndex], " \t");
            const value = std.mem.trim(u8, cleanProp[eqIndex + 1 ..], " \t\"");

            if (!first) try writer.print(" ", .{});
            try writer.print("{s}:{s};", .{ key, value });
            first = false;
        }

        try writer.print(" }}\n", .{});
    }

    return builder.toOwnedSlice();
}

pub fn renderHTML(root: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var list = std.ArrayList(u8).init(allocator);
    const writer = list.writer();

    try writer.print("<!DOCTYPE html>\n<html>\n<head>\n", .{});

    // Meta information
    for (root.children.items) |node| {
        if (node.node_type == .Meta) {
            var it = node.attributes.iterator();
            while (it.next()) |entry| {
                if (std.mem.eql(u8, entry.key_ptr.*, "title")) {
                    try writer.print("<title>{s}</title>\n", .{entry.value_ptr.*});
                } else {
                    try writer.print("<meta name=\"{s}\" content=\"{s}\">\n", .{
                        entry.key_ptr.*, entry.value_ptr.*,
                    });
                }
            }
        }
    }

    // Global CSS
    var globalCSSBuilder = std.ArrayList(u8).init(allocator);
    const globalWriter = globalCSSBuilder.writer();

    for (root.children.items) |node| {
        if (node.node_type == .Style) {
            if (node.attributes.get("mode")) |mode| {
                if (std.mem.eql(u8, mode, "global")) {
                    const css = try buildGlobalCSS(node.content, allocator);
                    defer allocator.free(css);
                    try globalWriter.print("{s}\n", .{css});
                }
            }
        }
    }

    if (globalCSSBuilder.items.len > 0) {
        try writer.print("<style>\n{s}</style>\n", .{globalCSSBuilder.items});
    }
    globalCSSBuilder.deinit();

    try writer.print("</head>\n<body>\n", .{});

    // Body rendering
    for (root.children.items) |node| {
        switch (node.node_type) {
            .Meta => {
                // Meta already emitted into <head>; skip in body to avoid noise.
            },
            .Heading => {
                const level = node.attributes.get("level") orelse "1";
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                try writer.print("<h{s}>{s}</h{s}>\n", .{ level, text, level });
            },
            .Content => {
                try writer.print("<p>{s}</p>\n", .{node.content});
            },
            .CodeBlock => {
                try writer.print("<pre><code>{s}</code></pre>\n", .{node.content});
            },
            .Math => {
                try writer.print("<div class=\"math\">{s}</div>\n", .{node.content});
            },
            .Media => {
                const src = node.attributes.get("src") orelse "";
                try writer.print("<img src=\"{s}\" />\n", .{src});
            },
            .Import => {
                const path = node.attributes.get("href") orelse "";
                try writer.print("<link rel=\"stylesheet\" href=\"{s}\">\n", .{path});
            },
            .Style => {
                if (node.attributes.get("mode")) |mode| {
                    if (std.mem.eql(u8, mode, "inline")) {
                        const inlineCSS = try buildInlineStyle(node.attributes, allocator);
                        defer allocator.free(inlineCSS);
                        try writer.print("<span style=\"{s}\">{s}</span>\n", .{ inlineCSS, node.content });
                    }
                }
            },
            else => {
                try writer.print("<!-- Unhandled node: {s} -->\n", .{@tagName(node.node_type)});
            },
        }
    }

    try writer.print("</body>\n</html>\n", .{});
    return list.toOwnedSlice();
}

// ----------------------
// ✅ Tests
// ----------------------

test "Render HTML with inline style" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var root = ASTNode.init(allocator, NodeType.Document);
    defer root.deinit();

    var styleNode = ASTNode.init(allocator, NodeType.Style);
    try styleNode.attributes.put("mode", "inline");
    try styleNode.attributes.put("font-size", "18px");
    try styleNode.attributes.put("color", "blue");
    styleNode.content = "Styled Text";
    try root.children.append(styleNode);

    const html = try renderHTML(&root, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "style=\"font-size:18px;color:blue;\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "Styled Text") != null);
}

test "Render HTML with global style-def" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var root = ASTNode.init(allocator, NodeType.Document);
    defer root.deinit();

    var globalStyleNode = ASTNode.init(allocator, NodeType.Style);
    try globalStyleNode.attributes.put("mode", "global");
    globalStyleNode.content =
        \\heading-level-1: font-size=36px, font-weight=bold
        \\body-text: font-family="Inter", line-height=1.6
    ;
    try root.children.append(globalStyleNode);

    const html = try renderHTML(&root, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, ".heading-level-1") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, ".body-text") != null);
}

<<<

`manager.zig`: >>>

const std = @import("std");

pub const Plugin = struct {
    name: []const u8,
    onRegister: ?*const fn () void,
    onRender: ?*const fn ([]u8) []u8,
};

pub const PluginManager = struct {
    allocator: std.mem.Allocator,
    plugins: std.ArrayList(Plugin),

    /// Initialize the PluginManager with a given allocator
    pub fn init(allocator: std.mem.Allocator) PluginManager {
        return PluginManager{
            .allocator = allocator,
            .plugins = std.ArrayList(Plugin).init(allocator),
        };
    }

    /// Properly free all allocated resources
    pub fn deinit(self: *PluginManager) void {
        self.plugins.deinit(); // Free the ArrayList memory
    }

    /// Add a new plugin to the manager
    pub fn addPlugin(self: *PluginManager, plugin: Plugin) !void {
        try self.plugins.append(plugin);
    }

    /// Execute all registered onRegister hooks
    pub fn registerHooks(self: *PluginManager) void {
        for (self.plugins.items) |plugin| {
            if (plugin.onRegister) |hook| {
                hook();
            }
        }
    }

    /// Apply all onRender hooks to the given HTML input
    /// Returns a duplicated mutable buffer, caller must free
    pub fn applyRenderHooks(self: *PluginManager, html: []const u8) ![]u8 {
        var result = try self.allocator.dupe(u8, html); // Create mutable copy
        // IMPORTANT: We return this buffer to caller; caller must free it
        for (self.plugins.items) |plugin| {
            if (plugin.onRender) |hook| {
                result = hook(result);
            }
        }
        return result;
    }
};

// ----------------------
// Tests
// ----------------------
var called_register: bool = false;
var called_render: bool = false;

fn onRegisterHook() void {
    called_register = true;
}

fn onRenderHook(html: []u8) []u8 {
    called_render = true;
    return html;
}

test "PluginManager adds and applies hooks" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var manager = PluginManager.init(allocator);
    defer manager.deinit(); // ✅ Ensure no leaks

    // Reset global flags
    called_register = false;
    called_render = false;

    const plugin = Plugin{
        .name = "test-plugin",
        .onRegister = onRegisterHook,
        .onRender = onRenderHook,
    };

    try manager.addPlugin(plugin);
    manager.registerHooks();

    const output = try manager.applyRenderHooks("dummy");
    defer allocator.free(output); // ✅ Free the duplicated result buffer

    try std.testing.expect(called_register);
    try std.testing.expect(called_render);
}

<<<

`ast.zig`: >>>

const std = @import("std");

pub const NodeType = enum {
    Document,
    Meta,
    Heading,
    Content,
    CodeBlock,
    Math,
    Media,
    Import,
    Style, // semantic style application: @style(name) ... @end
    Css, // raw CSS block: @css() ... @end
    StyleDef, // semantic alias definitions: @style-def() ... @end
    Unknown, // future-proofing: retain unknown directives losslessly
};

pub const ASTNode = struct {
    node_type: NodeType,
    content: []const u8 = "",
    owns_content: bool = false,
    allocator: ?std.mem.Allocator = null,
    attributes: std.StringHashMap([]const u8),
    children: std.ArrayList(ASTNode),

    pub fn init(allocator: std.mem.Allocator, node_type: NodeType) ASTNode {
        return ASTNode{
            .node_type = node_type,
            .content = "",
            .owns_content = false,
            .allocator = allocator,
            .attributes = std.StringHashMap([]const u8).init(allocator),
            .children = std.ArrayList(ASTNode).init(allocator),
        };
    }

    pub fn deinit(self: *ASTNode) void {
        // children first
        var i: usize = 0;
        while (i < self.children.items.len) : (i += 1) {
            self.children.items[i].deinit();
        }
        self.children.deinit();
        self.attributes.deinit();

        // free content if we own it
        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        // make dangling use obvious in debug
        self.content = "";
        self.owns_content = false;
    }

    pub fn addChild(self: *ASTNode, child: ASTNode) !void {
        try self.children.append(child);
    }

    /// Convenience: borrow a slice as content (caller keeps ownership).
    pub fn setContentBorrowed(self: *ASTNode, slice: []const u8) void {
        // if we previously owned, free first
        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        self.content = slice;
        self.owns_content = false;
    }

    /// Convenience: copy a slice into node-owned memory.
    pub fn setContentOwned(self: *ASTNode, allocator: std.mem.Allocator, slice: []const u8) !void {
        // if we previously owned, free first
        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        const dup = try allocator.dupe(u8, slice);
        self.content = dup;
        self.owns_content = true;
        self.allocator = allocator;
    }

    /// Add or overwrite an attribute.
    pub fn addAttr(self: *ASTNode, key: []const u8, value: []const u8) !void {
        try self.attributes.put(key, value);
    }

    /// Get attribute by key.
    pub fn getAttr(self: *const ASTNode, key: []const u8) ?[]const u8 {
        if (self.attributes.get(key)) |v| return v;
        return null;
    }

    /// Whether this node is a block-style node that consumes a body until @end.
    pub fn isBlockLike(self: *const ASTNode) bool {
        return switch (self.node_type) {
            .CodeBlock, .Math, .Style, .Css, .StyleDef => true,
            else => false,
        };
    }

    /// Whether this node contributes to <head> in HTML (helps exporter).
    pub fn isHeadAsset(self: *const ASTNode) bool {
        return switch (self.node_type) {
            .Import, .Css, .Meta => true,
            else => false,
        };
    }

    /// Deep clone onto a target allocator.
    pub fn cloneDeep(self: *const ASTNode, allocator: std.mem.Allocator) !ASTNode {
        var out = ASTNode.init(allocator, self.node_type);
        // copy content (owned in clone)
        if (self.content.len > 0) {
            try out.setContentOwned(allocator, self.content);
        }
        // copy attributes
        var it = self.attributes.iterator();
        while (it.next()) |entry| {
            // values are borrowed by map here; store borrowed slices from original
            // To make the clone independent, dupe both k and v.
            const k = try allocator.dupe(u8, entry.key_ptr.*);
            const v = try allocator.dupe(u8, entry.value_ptr.*);
            try out.attributes.put(k, v);
        }
        // copy children
        for (self.children.items) |child| {
            const dup_child = try child.cloneDeep(allocator);
            try out.children.append(dup_child);
        }
        return out;
    }

    // ─────────────────────────────────────────────────────────────
    // StyleDef utilities
    // Parses StyleDef content lines of the form:
    //   alias: class1 class2 class3
    // Ignores empty/comment lines (starting with '#').
    // Returns a map alias → class-string (owned by returned map).
    // Caller owns and must deinit the returned map.
    // ─────────────────────────────────────────────────────────────
    pub fn parseStyleAliases(self: *const ASTNode, allocator: std.mem.Allocator) !std.StringHashMap([]const u8) {
        var map = std.StringHashMap([]const u8).init(allocator);
        errdefer {
            var it_free = map.iterator();
            while (it_free.next()) |e| {
                allocator.free(e.key_ptr.*);
                allocator.free(e.value_ptr.*);
            }
            map.deinit();
        }

        if (self.node_type != .StyleDef or self.content.len == 0) {
            return map; // empty
        }

        var it = std.mem.splitScalar(u8, self.content, '\n');
        while (it.next()) |line_raw| {
            const line = std.mem.trim(u8, line_raw, " \t\r");
            if (line.len == 0 or line[0] == '#') continue;

            const colon_idx_opt = std.mem.indexOfScalar(u8, line, ':');
            if (colon_idx_opt == null) continue;
            const colon_idx = colon_idx_opt.?;

            const alias_trim = std.mem.trim(u8, line[0..colon_idx], " \t");
            const rhs = std.mem.trim(u8, line[colon_idx + 1 ..], " \t");
            if (alias_trim.len == 0 or rhs.len == 0) continue;

            const alias_owned = try allocator.dupe(u8, alias_trim);
            const classes_owned = try allocator.dupe(u8, rhs);

            const gop = try map.getOrPut(alias_owned);
            if (gop.found_existing) {
                // We won’t store alias_owned; free it.
                allocator.free(alias_owned);
                // Replace existing value, freeing the old one.
                allocator.free(gop.value_ptr.*);
                gop.value_ptr.* = classes_owned;
            } else {
                // First time for this alias: store both key and value.
                gop.key_ptr.* = alias_owned;
                gop.value_ptr.* = classes_owned;
            }
        }

        return map;
    }
};

// -------------
// Unit Tests
// -------------
test "ASTNode init and deinit with attributes and children" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var root = ASTNode.init(allocator, .Document);
    defer root.deinit();

    var heading = ASTNode.init(allocator, .Heading);
    heading.content = "Docz Title";
    try heading.attributes.put("level", "2");
    try root.addChild(heading);

    try std.testing.expect(root.children.items.len == 1);
    try std.testing.expect(std.mem.eql(u8, root.children.items[0].content, "Docz Title"));
    try std.testing.expect(root.children.items[0].attributes.contains("level"));
}

test "Css node isBlockLike and head asset" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var css = ASTNode.init(A, .Css);
    defer css.deinit();
    try css.setContentOwned(A,
        \\.card { border: 1px solid #ccc; }
    );

    try std.testing.expect(css.isBlockLike());
    try std.testing.expect(css.isHeadAsset());
    try std.testing.expect(css.owns_content);
    try std.testing.expect(std.mem.indexOfScalar(u8, css.content, '{') != null);
}

test "StyleDef parsing: alias → classes" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var def = ASTNode.init(A, .StyleDef);
    defer def.deinit();
    try def.setContentOwned(A,
        \\# comment
        \\heading-1: h1-xl h1-weight
        \\body-text: prose max-w-none
        \\  malformed line without colon
        \\title:   text-2xl   font-bold
    );

    var aliases = try def.parseStyleAliases(A);
    defer {
        var it = aliases.iterator();
        while (it.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        aliases.deinit();
    }

    try std.testing.expect(aliases.count() == 3);
    try std.testing.expect(std.mem.eql(u8, aliases.get("heading-1").?, "h1-xl h1-weight"));
    try std.testing.expect(std.mem.eql(u8, aliases.get("body-text").?, "prose max-w-none"));
    try std.testing.expect(std.mem.eql(u8, aliases.get("title").?, "text-2xl   font-bold"));
}

<<<

`parser.zig`: >>>

const std = @import("std");
const Token = @import("tokenizer.zig").Token;
const TokenType = @import("tokenizer.zig").TokenType;
const ASTNode = @import("ast.zig").ASTNode;
const NodeType = @import("ast.zig").NodeType;

/// Maps a directive string (e.g. "@meta") to a NodeType
fn directiveToNodeType(directive: []const u8) NodeType {
    if (std.mem.eql(u8, directive, "@meta")) return NodeType.Meta;
    if (std.mem.eql(u8, directive, "@heading")) return NodeType.Heading;
    if (std.mem.eql(u8, directive, "@code")) return NodeType.CodeBlock;
    if (std.mem.eql(u8, directive, "@math")) return NodeType.Math;
    if (std.mem.eql(u8, directive, "@image")) return NodeType.Media;
    if (std.mem.eql(u8, directive, "@import")) return NodeType.Import;
    if (std.mem.eql(u8, directive, "@style")) return NodeType.Style;

    // NEW:
    if (std.mem.eql(u8, directive, "@css")) return NodeType.Css;
    if (std.mem.eql(u8, directive, "@style-def")) return NodeType.StyleDef;

    // Fallback: treat as paragraph-ish content (unknown-by-core can be upgraded later)
    return NodeType.Content;
}

fn isBlockDirective(nt: NodeType) bool {
    return switch (nt) {
        .CodeBlock, .Math, .Style, .Css, .StyleDef => true, // NEW: Css, StyleDef
        else => false,
    };
}

/// Parses tokens into an ASTNode tree
pub fn parse(tokens: []const Token, allocator: std.mem.Allocator) !ASTNode {
    var root = ASTNode.init(allocator, .Document);

    var i: usize = 0;
    while (i < tokens.len) {
        const tok = tokens[i];

        if (tok.kind == .Directive) {
            const node_type = directiveToNodeType(tok.lexeme);
            var node = ASTNode.init(allocator, node_type);
            i += 1;

            // parameters
            while (i + 1 < tokens.len and tokens[i].kind == .ParameterKey and tokens[i + 1].kind == .ParameterValue) {
                try node.attributes.put(tokens[i].lexeme, tokens[i + 1].lexeme);
                i += 2;
            }

            // inline content (e.g. heading title)
            if (i < tokens.len and tokens[i].kind == .Content) {
                node.content = tokens[i].lexeme; // not owned
                node.owns_content = false;
                i += 1;
            }

            // block content only for block directives
            if (isBlockDirective(node_type)) {
                var block = std.ArrayList(u8).init(allocator);
                defer block.deinit();

                while (i < tokens.len and tokens[i].kind != .BlockEnd) : (i += 1) {
                    try block.appendSlice(tokens[i].lexeme);
                    try block.append('\n');
                }
                if (i < tokens.len and tokens[i].kind == .BlockEnd) {
                    i += 1; // skip @end
                }

                if (block.items.len > 0) {
                    node.content = try block.toOwnedSlice();
                    node.owns_content = true; // we allocated it
                }
            }

            try root.children.append(node);
            continue;
        }

        if (tok.kind == .Content) {
            var content_node = ASTNode.init(allocator, .Content);
            content_node.content = tok.lexeme; // not owned
            try root.children.append(content_node);
            i += 1;
            continue;
        }

        i += 1;
    }

    return root;
}

// ----------------------
// Tests
// ----------------------
test "Parse multiple directives" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokenizer = @import("tokenizer.zig");
    const input =
        \\@meta(title="Docz Guide", author="Team") @end
        \\@heading(level=2) Welcome to Docz @end
        \\@code(language="zig")
        \\const x = 42;
        \\@end
    ;
    const tokens = try tokenizer.tokenize(input, allocator);
    defer allocator.free(tokens);

    var ast = try parse(tokens, allocator);
    defer ast.deinit();

    try std.testing.expectEqual(ast.children.items.len, 3);
    try std.testing.expectEqual(ast.children.items[0].node_type, .Meta);
    try std.testing.expectEqual(ast.children.items[1].node_type, .Heading);
    try std.testing.expectEqual(ast.children.items[2].node_type, .CodeBlock);

    try std.testing.expect(std.mem.containsAtLeast(u8, ast.children.items[2].content, 1, "const x = 42;"));
}

<<<

`tokenizer.zig`: >>>

const std = @import("std");

pub const TokenType = enum {
    Directive,
    ParameterKey,
    ParameterValue,
    Content,
    BlockEnd,
};

pub const Token = struct {
    kind: TokenType,
    lexeme: []const u8,
    is_allocated: bool = false, // track ownership for @@ case
};

/// True iff there is a directive introducer at position `i`.
/// A directive must start at the beginning of the file or immediately after '\n',
/// and be followed by an alphabetic name (e.g. "@meta", "@end").
fn isDirectiveStart(input: []const u8, i: usize) bool {
    if (i >= input.len) return false;
    if (input[i] != '@') return false;
    if (i > 0 and input[i - 1] != '\n') return false;
    if (i + 1 >= input.len) return false;
    return std.ascii.isAlphabetic(input[i + 1]);
}

/// Return index of end-of-line (position of '\n' or input.len).
fn lineEnd(input: []const u8, pos: usize) usize {
    var j = pos;
    while (j < input.len and input[j] != '\n') : (j += 1) {}
    return j;
}

/// Compare slice (trimmed of spaces/tabs/CR) with needle.
fn trimmedEq(slice: []const u8, needle: []const u8) bool {
    const t = std.mem.trim(u8, slice, " \t\r");
    return std.mem.eql(u8, t, needle);
}

/// Tokenize `.dcz` input into an array of tokens.
/// Caller owns returned slice; must free allocated lexemes where `is_allocated=true`.
pub fn tokenize(input: []const u8, allocator: std.mem.Allocator) ![]Token {
    var tokens = std.ArrayList(Token).init(allocator);
    errdefer tokens.deinit();

    var i: usize = 0;

    // Fence state: when non-empty, we are inside a raw block until a line that is "@end"
    // or ends with "@end" (after optional whitespace).
    var fence_name: []const u8 = "";

    // Global no-progress guard (defensive)
    var prev_i: usize = ~@as(usize, 0);
    var stuck_iters: usize = 0;

    while (i < input.len) : ({
        if (i == prev_i) {
            stuck_iters += 1;
            if (stuck_iters >= 10_000_000) return error.TokenizerStuck;
        } else {
            prev_i = i;
            stuck_iters = 0;
        }
    }) {
        // ── Fenced mode: slurp raw content until a closer appears.
        if (fence_name.len != 0) {
            // Skip a single leading newline so fenced content begins on its own line.
            if (i < input.len) {
                if (input[i] == '\r') {
                    if (i + 1 < input.len and input[i + 1] == '\n') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                } else if (input[i] == '\n') {
                    i += 1;
                }
            }

            // NEW: for math blocks only, strip leading indentation on the first content line.
            if (std.mem.eql(u8, fence_name, "@math")) {
                while (i < input.len and (input[i] == ' ' or input[i] == '\t')) : (i += 1) {}
            }

            const content_start = i;

            while (i < input.len) {
                const eol = lineEnd(input, i);
                const line = input[i..eol];

                // Case 1: whole trimmed line is "@end"
                if (trimmedEq(line, "@end")) {
                    if (content_start < i) {
                        try tokens.append(.{ .kind = .Content, .lexeme = input[content_start..i] });
                    }
                    try tokens.append(.{ .kind = .BlockEnd, .lexeme = "@end" });
                    i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                    fence_name = "";
                    break;
                }

                // Case 2: inline closer at end-of-line: "...something... @end[WS]"
                if (std.mem.indexOf(u8, line, "@end")) |pos| {
                    const after = line[pos..];
                    if (trimmedEq(after, "@end")) {
                        // trim any spaces/tabs immediately before "@end"
                        var cut_abs = i + pos;
                        while (cut_abs > content_start and (input[cut_abs - 1] == ' ' or input[cut_abs - 1] == '\t')) {
                            cut_abs -= 1;
                        }

                        if (content_start < cut_abs) {
                            try tokens.append(.{ .kind = .Content, .lexeme = input[content_start..cut_abs] });
                        }
                        try tokens.append(.{ .kind = .BlockEnd, .lexeme = "@end" });
                        // consume the rest of this line including newline
                        i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                        fence_name = "";
                        break;
                    }
                }

                // Not a closer: advance to next line
                i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
            }

            // EOF with no @end: emit remainder and exit fence
            if (fence_name.len != 0 and content_start < input.len) {
                try tokens.append(.{ .kind = .Content, .lexeme = input[content_start..input.len] });
                fence_name = "";
                i = input.len;
            }
            continue;
        }

        const c = input[i];

        // 1) Escaped literal '@' — "@@" + word → emit as Content("@word")
        if (c == '@' and i + 1 < input.len and input[i + 1] == '@') {
            i += 2; // skip "@@"
            const start = i;
            while (i < input.len and !std.ascii.isWhitespace(input[i])) : (i += 1) {}
            const word = input[start..i];

            const combined = try std.fmt.allocPrint(allocator, "@{s}", .{word});
            try tokens.append(.{
                .kind = .Content,
                .lexeme = combined,
                .is_allocated = true,
            });
            continue;
        }

        // 2) Standalone @end: only when the rest of this line (trimmed) is exactly "@end"
        if (c == '@' and i + 4 <= input.len and std.mem.eql(u8, input[i .. i + 4], "@end")) {
            const eol = lineEnd(input, i);
            if (trimmedEq(input[i..eol], "@end")) {
                try tokens.append(.{ .kind = .BlockEnd, .lexeme = "@end" });
                i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                continue;
            }
            // else: literal "`@end`" in prose → fall through
        }

        // 3) Directives at SOL (allow leading spaces/tabs)
        if (c == '@') {
            var j = i;
            while (j > 0 and (input[j - 1] == ' ' or input[j - 1] == '\t')) : (j -= 1) {}
            const at_sol = (j == 0) or (input[j - 1] == '\n' or input[j - 1] == '\r');

            if (at_sol) {
                const d_start = i;
                i += 1; // skip '@'

                while (i < input.len and std.ascii.isAlphabetic(input[i])) : (i += 1) {}
                const directive_full = input[d_start..i]; // e.g. "@meta", "@code", "@heading"

                if (directive_full.len == 1) {
                    try tokens.append(.{ .kind = .Content, .lexeme = "@" });
                    continue;
                }

                try tokens.append(.{ .kind = .Directive, .lexeme = directive_full });

                // Optional parameter list: (...)
                if (i < input.len and input[i] == '(') {
                    i += 1;

                    var inner_prev: usize = ~@as(usize, 0);
                    var inner_stuck: usize = 0;

                    while (i < input.len and input[i] != ')') : ({
                        if (i == inner_prev) {
                            inner_stuck += 1;
                            if (inner_stuck >= 10_000_000) return error.TokenizerStuck;
                        } else {
                            inner_prev = i;
                            inner_stuck = 0;
                        }
                    }) {
                        // skip whitespace
                        while (i < input.len and std.ascii.isWhitespace(input[i])) : (i += 1) {}
                        if (i >= input.len) break;

                        // commas
                        if (input[i] == ',') {
                            i += 1;
                            continue;
                        }

                        // key
                        const key_start = i;
                        while (i < input.len and std.ascii.isAlphabetic(input[i])) : (i += 1) {}
                        if (i > key_start) {
                            try tokens.append(.{ .kind = .ParameterKey, .lexeme = input[key_start..i] });
                        } else {
                            if (i < input.len and input[i] != ')' and input[i] != ',') i += 1;
                            continue;
                        }

                        // '=' and value
                        if (i < input.len and input[i] == '=') {
                            i += 1;

                            if (i < input.len and input[i] == '"') {
                                i += 1; // opening quote
                                const str_start = i;
                                while (i < input.len and input[i] != '"') : (i += 1) {}
                                const str_end = if (i < input.len) i else input.len;
                                try tokens.append(.{ .kind = .ParameterValue, .lexeme = input[str_start..str_end] });
                                if (i < input.len and input[i] == '"') i += 1;
                            } else {
                                const v_start = i;
                                while (i < input.len) : (i += 1) {
                                    const ch = input[i];
                                    if (std.ascii.isWhitespace(ch) or ch == ')' or ch == ',') break;
                                }
                                if (i > v_start) {
                                    try tokens.append(.{ .kind = .ParameterValue, .lexeme = input[v_start..i] });
                                }
                            }
                        }
                    }
                    if (i < input.len and input[i] == ')') i += 1;
                }

                // Fence-opening directives for v0
                if (std.mem.eql(u8, directive_full, "@code") or
                    std.mem.eql(u8, directive_full, "@math") or
                    std.mem.eql(u8, directive_full, "@style"))
                {
                    fence_name = directive_full; // any non-empty marker works
                }

                continue;
            }
        }

        // 4) Line comments starting with "#:" (to end of line)
        if (c == '#' and i + 1 < input.len and input[i + 1] == ':') {
            while (i < input.len and input[i] != '\n') : (i += 1) {}
            continue;
        }

        // 5) Whitespace: skip (includes newlines)
        if (std.ascii.isWhitespace(c)) {
            i += 1;
            continue;
        }

        // 6) Raw content until newline OR a standalone "@end" OR a SOL directive
        const content_start = i;
        while (i < input.len) : (i += 1) {
            const ch = input[i];
            if (ch == '\n' or ch == '\r') break;

            if (ch == '@') {
                // Break on "@@" so outer loop can emit the literal-@ token
                if (i + 1 < input.len and input[i + 1] == '@') break;

                // If remainder of this line (trimmed) is exactly "@end", stop here
                const eol2 = lineEnd(input, i);
                if (eol2 > i and trimmedEq(input[i..eol2], "@end")) break;

                // If it's a start-of-line directive (allowing indentation), let outer loop handle it.
                var k = i;
                while (k > 0 and (input[k - 1] == ' ' or input[k - 1] == '\t')) : (k -= 1) {}
                const sol = (k == 0) or (input[k - 1] == '\n' or input[k - 1] == '\r');
                if (sol) break;
            }
        }
        if (i > content_start) {
            try tokens.append(.{ .kind = .Content, .lexeme = input[content_start..i] });
        }
        // newline (if any) handled next iteration
    }

    return tokens.toOwnedSlice();
}

/// Free all heap allocations in token list.
pub fn freeTokens(allocator: std.mem.Allocator, tokens: []Token) void {
    for (tokens) |t| {
        if (t.is_allocated) allocator.free(t.lexeme);
    }
}

// ----------------------
// Tests
// ----------------------
test "Tokenize escape sequence @@ as literal @" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    var allocator = gpa.allocator();

    const input = "Contact @@support@example.com";
    const toks = try tokenize(input, allocator);
    defer {
        freeTokens(allocator, toks);
        allocator.free(toks);
    }

    try std.testing.expectEqual(@as(usize, 2), toks.len);
    try std.testing.expectEqualStrings("Contact ", toks[0].lexeme);
    try std.testing.expectEqualStrings("@support@example.com", toks[1].lexeme);
}

test "Unclosed parameter list does not hang" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@meta(title="Hello"
        \\Content after
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // We at least see the directive and some content; exact count is not strict.
    try std.testing.expect(toks.len >= 2);
}

test "Fenced code block captures raw until standalone or inline @end" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@code(language="txt")
        \\line 1
        \\line 2 @end
        \\After
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // Expect: Directive, ParamKey, ParamValue, Content("line 1\nline 2"), BlockEnd, Content("After")
    try std.testing.expect(toks.len >= 5);
    try std.testing.expect(toks[0].kind == .Directive);
    try std.testing.expect(toks[3].kind == .Content);
    try std.testing.expect(std.mem.indexOf(u8, toks[3].lexeme, "line 2") != null);
    // Ensure "@end" not included in content
    try std.testing.expect(std.mem.indexOf(u8, toks[3].lexeme, "@end") == null);
}

test "Inline `@end` in prose does not become BlockEnd (outside fence)" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\This paragraph mentions `@end` and continues.
        \\@heading(level=2) Title
        \\@end
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    var found_inline = false;
    var found_blockend = false;
    for (toks) |t| {
        if (t.kind == .Content and std.mem.indexOf(u8, t.lexeme, "`@end`") != null) found_inline = true;
        if (t.kind == .BlockEnd) found_blockend = true;
    }
    try std.testing.expect(found_inline);
    try std.testing.expect(found_blockend);
}

<<<

`export.zig`: >>>

const std = @import("std");
const docz = @import("docz"); // <— instead of ../../parser/ast.zig
const ASTNode = docz.AST.ASTNode;
const NodeType = docz.AST.NodeType;

// -------------------------
// Helpers
// -------------------------

fn stripSingleTrailingNewline(buf: *std.ArrayList(u8)) void {
    if (buf.items.len != 0 and buf.items[buf.items.len - 1] == '\n') {
        _ = buf.pop();
    }
}

fn writeNewline(w: anytype) !void {
    try w.writeAll("\n");
}

fn writeBlankLine(w: anytype) !void {
    try w.writeAll("\n\n");
}

fn clampHeadingLevel(raw: usize) usize {
    return if (raw == 0) 1 else if (raw > 6) 6 else raw;
}

fn repeatChar(w: anytype, c: u8, n: usize) !void {
    var i: usize = 0;
    while (i < n) : (i += 1) try w.writeByte(c);
}

fn writeHeading(w: anytype, level_str: []const u8, text: []const u8) !void {
    const raw_level = std.fmt.parseUnsigned(usize, level_str, 10) catch 1;
    const lvl = clampHeadingLevel(raw_level);
    try repeatChar(w, '#', lvl);
    try w.writeByte(' ');
    try w.writeAll(text);
    try writeBlankLine(w);
}

fn writeParagraph(w: anytype, text: []const u8) !void {
    const t = std.mem.trim(u8, text, " \t\r\n");
    if (t.len == 0) return;
    try w.writeAll(t);
    try writeBlankLine(w);
}

/// Pick a fence for code blocks. If the body contains any backticks,
/// switch to tildes to avoid the need for escaping.
fn chooseFence(body: []const u8) []const u8 {
    return if (std.mem.indexOfScalar(u8, body, '`') != null) "~~~" else "```";
}

fn writeCodeBlock(w: anytype, lang_opt: ?[]const u8, body: []const u8) !void {
    const fence = chooseFence(body);
    try w.writeAll(fence);
    if (lang_opt) |lang| {
        if (lang.len > 0) {
            try w.writeByte(' ');
            try w.writeAll(lang);
        }
    }
    try writeNewline(w);
    try w.writeAll(body);
    try writeNewline(w);
    try w.writeAll(fence);
    try writeBlankLine(w);
}

fn writeMathBlock(w: anytype, body: []const u8) !void {
    // Block math as $$ ... $$
    try w.writeAll("$$\n");
    try w.writeAll(body);
    try w.writeAll("\n$$");
    try writeBlankLine(w);
}

fn writeImage(w: anytype, src: []const u8) !void {
    const s = std.mem.trim(u8, src, " \t\r\n");
    if (s.len == 0) return;
    try w.writeAll("![image](");
    try w.writeAll(s);
    try w.writeByte(')');
    try writeBlankLine(w);
}

// -------------------------
// Export API
// -------------------------

/// Export AST → GitHub-flavored Markdown (minimal).
/// - Meta(title) becomes a top-level `# Title`
/// - Headings map to `#`, `##`, ...
/// - Content becomes paragraphs
/// - CodeBlock uses fences; language goes after a space: "``` zig\n"
///   If body contains backticks, fence switches to `~~~`.
/// - Math is emitted inline as `$...$` on its own paragraph
/// - Media (src) becomes `![](<src>)`
pub fn exportAstToMarkdown(doc: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    const w = out.writer();

    var last_was_code = false;

    for (doc.children.items) |node| {
        switch (node.node_type) {
            .Meta => {
                if (node.attributes.get("title")) |title| {
                    try w.print("# {s}\n", .{title});
                    const s = out.items;
                    if (!std.mem.endsWith(u8, s, "\n\n")) {
                        if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                    }
                    last_was_code = false;
                }
            },
            .Heading => {
                const level_str = node.attributes.get("level") orelse "1";
                var lvl: u8 = 1;
                if (level_str.len > 0 and level_str[0] >= '1' and level_str[0] <= '6')
                    lvl = @intCast(level_str[0] - '0');
                if (lvl < 1) lvl = 1;
                if (lvl > 6) lvl = 6;

                var i: usize = 0;
                while (i < lvl) : (i += 1) try w.print("#", .{});
                try w.print(" {s}\n", .{std.mem.trimRight(u8, node.content, " \t\r\n")});

                const s = out.items;
                if (!std.mem.endsWith(u8, s, "\n\n")) {
                    if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                }
                last_was_code = false;
            },
            .Content => {
                const txt = std.mem.trimRight(u8, node.content, " \t\r\n");
                if (txt.len != 0) {
                    try w.print("{s}\n", .{txt});
                    const s = out.items;
                    if (!std.mem.endsWith(u8, s, "\n\n")) {
                        if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                    }
                    last_was_code = false;
                }
            },
            .CodeBlock => {
                const lang = node.attributes.get("language") orelse "";
                const use_tildes = std.mem.indexOf(u8, node.content, "```") != null;
                const fence = if (use_tildes) "~~~" else "```";

                if (lang.len != 0) {
                    try w.print("{s} {s}\n{s}\n{s}\n", .{ fence, lang, node.content, fence });
                } else {
                    try w.print("{s}\n{s}\n{s}\n", .{ fence, node.content, fence });
                }

                // Ensure blank line after block
                const s = out.items;
                if (!std.mem.endsWith(u8, s, "\n\n")) {
                    if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                }
                last_was_code = true;
            },
            .Math => {
                // Keep $$...$$ blocks (tests look for this form)
                try w.print("$$\n{s}\n$$\n", .{node.content});

                // Ensure blank line after block
                const s = out.items;
                if (!std.mem.endsWith(u8, s, "\n\n")) {
                    if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                }
                last_was_code = false;
            },
            .Media => {
                const src = node.attributes.get("src") orelse "";
                if (src.len != 0) {
                    const alt = node.attributes.get("alt") orelse "image";
                    try w.print("![{s}]({s})\n", .{ alt, src });

                    const s = out.items;
                    if (!std.mem.endsWith(u8, s, "\n\n")) {
                        if (std.mem.endsWith(u8, s, "\n")) try out.append('\n') else try out.appendSlice("\n\n");
                    }
                    last_was_code = false;
                }
            },
            .Import, .Style => {},
            else => {},
        }
    }

    // EOF normalization
    if (out.items.len > 0) {
        if (std.mem.endsWith(u8, out.items, "\n\n")) {
            if (!last_was_code) {
                _ = out.pop(); // collapse to single newline if last block wasn’t code
            }
        } else if (!std.mem.endsWith(u8, out.items, "\n")) {
            try out.append('\n');
        }
    }

    return out.toOwnedSlice();
}

// -------------------------
// Unit tests
// -------------------------

test "markdown export: title meta + headings + paragraph" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    // Meta title
    {
        var meta = ASTNode.init(A, NodeType.Meta);
        try meta.attributes.put("title", "My Doc");
        try root.children.append(meta);
    }
    // H2
    {
        var h = ASTNode.init(A, NodeType.Heading);
        try h.attributes.put("level", "2");
        h.content = "Section";
        try root.children.append(h);
    }
    // Paragraph
    {
        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Hello **world**!";
        try root.children.append(p);
    }

    const md = try exportAstToMarkdown(&root, A);
    defer A.free(md);

    const expected =
        \\# My Doc
        \\
        \\## Section
        \\
        \\Hello **world**!
        \\
    ;
    try std.testing.expectEqualStrings(expected, md);
}

test "markdown export: code, math, image, and spacing" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    // Code block with language
    {
        var code = ASTNode.init(A, NodeType.CodeBlock);
        try code.attributes.put("language", "zig");
        code.content =
            \\const x: u8 = 42;
        ;
        try root.children.append(code);
    }

    // Math block
    {
        var math = ASTNode.init(A, NodeType.Math);
        math.content = "E = mc^2";
        try root.children.append(math);
    }

    // Image
    {
        var img = ASTNode.init(A, NodeType.Media);
        try img.attributes.put("src", "/img/logo.png");
        try root.children.append(img);
    }

    const md = try exportAstToMarkdown(&root, A);
    defer A.free(md);

    const snippet_code =
        \\``` zig
        \\const x: u8 = 42;
        \\```
    ;
    try std.testing.expect(std.mem.indexOf(u8, md, snippet_code) != null);
    try std.testing.expect(std.mem.indexOf(u8, md, "$$\nE = mc^2\n$$") != null);
    try std.testing.expect(std.mem.indexOf(u8, md, "![image](/img/logo.png)") != null);
}

test "markdown export: fence selection switches to tildes when body contains backticks" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    var code = ASTNode.init(A, NodeType.CodeBlock);
    try code.attributes.put("language", "txt");
    code.content =
        \\here are three backticks: ```
        \\and more text
    ;
    try root.children.append(code);

    const md = try exportAstToMarkdown(&root, A);
    defer A.free(md);

    // Should use ~~~ fences
    try std.testing.expect(std.mem.indexOf(u8, md, "~~~ txt\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, md, "\n~~~\n\n") != null);
}

<<<

`import.zig`: >>>

const std = @import("std");

pub fn importMarkdownToDcz(allocator: std.mem.Allocator, md: []const u8) ![]u8 {
    // Tiny placeholder: turn "# Title" into @heading, blank lines into paragraph breaks.
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    const w = out.writer();

    var it = std.mem.splitScalar(u8, md, '\n');
    while (it.next()) |line_in| {
        const line = std.mem.trim(u8, line_in, " \t\r");
        if (line.len == 0) {
            // blank -> paragraph break; keep simple for demo
            _ = try w.write("\n");
            continue;
        }
        if (std.mem.startsWith(u8, line, "# ")) {
            try w.print("@heading(level=1) {s} @end\n", .{line[2..]});
        } else if (std.mem.startsWith(u8, line, "## ")) {
            try w.print("@heading(level=2) {s} @end\n", .{line[3..]});
        } else {
            try w.print("{s}\n", .{line});
        }
    }

    return out.toOwnedSlice();
}

// -----------------
// Unit tests (in-file)
// -----------------
test "markdown import: basic headings + paragraph" {
    const md =
        \\# Title
        \\para line
        \\## Sub
        \\more text
        \\
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importMarkdownToDcz(A, md);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "@heading(level=1) Title @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "para line\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@heading(level=2) Sub @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "more text\n") != null);
}

<<<

`export.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const ASTNode = docz.AST.ASTNode;
const NodeType = docz.AST.NodeType;

// -------------------------
// Helpers
// -------------------------

fn trimRightNl(s: []const u8) []const u8 {
    return std.mem.trimRight(u8, s, " \t\r\n");
}

fn clampHeadingLevel(lvl_raw: u8) u8 {
    return if (lvl_raw < 1) 1 else if (lvl_raw > 6) 6 else lvl_raw;
}

/// Escape LaTeX special characters in normal text (headings/paragraphs).
/// Code/Math/Media are NOT escaped.
fn latexEscape(alloc: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    errdefer out.deinit();

    var i: usize = 0;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        switch (c) {
            '\\' => try out.appendSlice("\\textbackslash{}"),
            '{' => try out.appendSlice("\\{"),
            '}' => try out.appendSlice("\\}"),
            '%' => try out.appendSlice("\\%"),
            '&' => try out.appendSlice("\\&"),
            '$' => try out.appendSlice("\\$"),
            '#' => try out.appendSlice("\\#"),
            '_' => try out.appendSlice("\\_"),
            '^' => try out.appendSlice("\\textasciicircum{}"),
            '~' => try out.appendSlice("\\textasciitilde{}"),
            else => try out.append(c),
        }
    }
    return out.toOwnedSlice();
}

fn writeParagraph(w: anytype, text: []const u8, alloc: std.mem.Allocator) !void {
    const t = trimRightNl(text);
    if (t.len == 0) return;
    const esc = try latexEscape(alloc, t);
    defer alloc.free(esc);
    try std.fmt.format(w, "{s}\n\n", .{esc});
}

fn writeHeading(w: anytype, level_str: []const u8, text: []const u8, alloc: std.mem.Allocator) !void {
    const lvl_u = std.fmt.parseUnsigned(u8, level_str, 10) catch 1;
    const lvl = clampHeadingLevel(lvl_u);

    const cmd: []const u8 = switch (lvl) {
        1 => "\\section",
        2 => "\\subsection",
        else => "\\subsubsection",
    };

    const t = trimRightNl(text);
    const esc = try latexEscape(alloc, t);
    defer alloc.free(esc);
    // {cmd}{text}  →  \section{My Title}
    try std.fmt.format(w, "{s}{{{s}}}\n\n", .{ cmd, esc });
}

fn writeCodeBlock(w: anytype, body: []const u8) !void {
    // Code: raw
    try std.fmt.format(w, "\\begin{{verbatim}}\n{s}\n\\end{{verbatim}}\n\n", .{body});
}

fn writeMath(w: anytype, body: []const u8) !void {
    // Math: raw body, importer already normalizes whitespace on the way back
    const b = trimRightNl(body);
    if (b.len == 0) return;
    try std.fmt.format(w, "\\begin{{equation}}\n{s}\n\\end{{equation}}\n\n", .{b});
}

fn writeImage(w: anytype, src: []const u8) !void {
    // Media: keep src raw (filenames often contain underscores; escaping would break)
    if (src.len == 0) return;
    try std.fmt.format(w, "\\includegraphics{{{s}}}\n\n", .{src});
}

// -------------------------
// Public API
// -------------------------

/// Export AST -> minimal LaTeX.
/// Notes:
/// - Only emits \title and \author if present in Meta nodes.
/// - Headings > 3 are clamped to \subsubsection.
/// - Content/Heading text are LaTeX-escaped; Code/Math/Media are not.
/// - Unknown nodes are ignored.
pub fn exportAstToLatex(doc: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    const w = out.writer();

    var title_emitted = false;
    var author_emitted = false;

    // Pass 1: gather title/author from Meta nodes
    for (doc.children.items) |node| {
        if (node.node_type != .Meta) continue;

        if (!title_emitted) {
            if (node.attributes.get("title")) |t| {
                const esc = try latexEscape(allocator, t);
                defer allocator.free(esc);
                try std.fmt.format(w, "\\title{{{s}}}\n", .{esc});
                title_emitted = true;
            }
        }
        if (!author_emitted) {
            if (node.attributes.get("author")) |a| {
                const esc = try latexEscape(allocator, a);
                defer allocator.free(esc);
                try std.fmt.format(w, "\\author{{{s}}}\n", .{esc});
                author_emitted = true;
            }
        }
    }
    if (title_emitted or author_emitted) {
        try w.writeAll("\n");
    }

    // Pass 2: body
    for (doc.children.items) |node| {
        switch (node.node_type) {
            .Meta => {}, // handled above
            .Heading => {
                const level_str = node.attributes.get("level") orelse "1";
                try writeHeading(w, level_str, node.content, allocator);
            },
            .Content => {
                try writeParagraph(w, node.content, allocator);
            },
            .CodeBlock => {
                try writeCodeBlock(w, node.content);
            },
            .Math => {
                try writeMath(w, node.content);
            },
            .Media => {
                const src = node.attributes.get("src") orelse "";
                if (src.len != 0) try writeImage(w, src);
            },
            .Import, .Style => {
                // ignore in LaTeX export (minimal)
            },
            else => {
                // ignore unknown nodes
            },
        }
    }

    // Normalize EOF: ensure trailing single newline
    if (out.items.len == 0 or out.items[out.items.len - 1] != '\n') {
        try out.append('\n');
    }

    return out.toOwnedSlice();
}

// -------------------------
// Unit tests
// -------------------------

test "latex_export: title/author + basic body" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    // Meta
    {
        var m = ASTNode.init(A, NodeType.Meta);
        try m.attributes.put("title", "My Doc");
        try m.attributes.put("author", "Docz Team");
        try root.children.append(m);
    }
    // Body
    {
        var h = ASTNode.init(A, NodeType.Heading);
        try h.attributes.put("level", "2");
        h.content = "Section";
        try root.children.append(h);

        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Hello **world**!";
        try root.children.append(p);

        var cb = ASTNode.init(A, NodeType.CodeBlock);
        cb.content = "const x = 42;";
        try root.children.append(cb);

        var m = ASTNode.init(A, NodeType.Math);
        m.content = "E = mc^2";
        try root.children.append(m);

        var img = ASTNode.init(A, NodeType.Media);
        try img.attributes.put("src", "img/logo.png");
        try root.children.append(img);
    }

    const tex = try exportAstToLatex(&root, A);
    defer A.free(tex);

    try std.testing.expect(std.mem.indexOf(u8, tex, "\\title{My Doc}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\author{Docz Team}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\subsection{Section}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "Hello **world**!\n\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\begin{verbatim}\nconst x = 42;\n\\end{verbatim}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\begin{equation}\nE = mc^2\n\\end{equation}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\includegraphics{img/logo.png}") != null);
}

// NEW: escaping in paragraph + heading
test "latex_export: escape special chars in content and heading" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    {
        var h = ASTNode.init(A, NodeType.Heading);
        try h.attributes.put("level", "1");
        h.content = "Price is $5 & 10% off {today}";
        try root.children.append(h);
    }
    {
        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Path A\\B with #hash _under_ ^caret~tilde";
        try root.children.append(p);
    }
    // Code block should remain raw (no escaping applied)
    {
        var cb = ASTNode.init(A, NodeType.CodeBlock);
        cb.content = "printf(\"100% done\\n\"); // keep % and \\";
        try root.children.append(cb);
    }

    const tex = try exportAstToLatex(&root, A);
    defer A.free(tex);

    // Escaped in heading
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\section{Price is \\$5 \\& 10\\% off \\{today\\}}") != null);

    // Escaped in paragraph (notice textbackslash/textasciicircum/textasciitilde)
    try std.testing.expect(std.mem.indexOf(u8, tex, "Path A\\textbackslash{}B with \\#hash \\_under\\_ \\textasciicircum{}caret\\textasciitilde{}tilde") != null);

    // Code block raw
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\begin{verbatim}\nprintf(\"100% done\\n\"); // keep % and \\\n\\end{verbatim}") != null);
}

// NEW: empty blocks do not emit
test "latex_export: empty math/paragraph do not emit" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    {
        var p = ASTNode.init(A, NodeType.Content);
        p.content = "   \n";
        try root.children.append(p);
    }
    {
        var m = ASTNode.init(A, NodeType.Math);
        m.content = "  \n";
        try root.children.append(m);
    }

    const tex = try exportAstToLatex(&root, A);
    defer A.free(tex);

    // Should be only a trailing newline
    try std.testing.expectEqual(@as(usize, 1), tex.len);
    try std.testing.expectEqual(@as(u8, '\n'), tex[0]);
}

<<<

`import.zig`: >>>

const std = @import("std");

// -------------------------
// Small helpers
// -------------------------

fn flushParagraph(out: *std.ArrayList(u8), para: *std.ArrayList(u8)) !void {
    if (para.items.len == 0) return;

    // Trim leading/trailing whitespace in the paragraph buffer
    const trimmed = std.mem.trim(u8, para.items, " \t\r\n");
    if (trimmed.len != 0) {
        try out.appendSlice(trimmed);
        try out.append('\n');
    }

    para.clearRetainingCapacity();
}

fn trimSpaces(s: []const u8) []const u8 {
    return std.mem.trim(u8, s, " \t\r\n");
}

fn isIdentChar(c: u8) bool {
    return std.ascii.isAlphabetic(c);
}

/// Reads a LaTeX command name starting at `start` where `tex[start] == '\'`.
/// Returns name slice and index just after the name.
fn readCommandName(tex: []const u8, start: usize) ?struct { name: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '\\') return null;
    var j = start + 1;
    while (j < tex.len and isIdentChar(tex[j])) : (j += 1) {}
    if (j == start + 1) return null;
    return .{ .name = tex[start + 1 .. j], .next = j };
}

/// If the next non-space is `[`, read until matching `]` (no nesting).
/// Returns slice inside `[]` and index after `]`. If not present, returns null.
fn readOptionalBracket(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    var i = start;
    while (i < tex.len and std.ascii.isWhitespace(tex[i])) : (i += 1) {}
    if (i >= tex.len or tex[i] != '[') return null;

    var j = i + 1;
    while (j < tex.len and tex[j] != ']') : (j += 1) {}
    const end = if (j < tex.len) j else tex.len;
    const body = tex[i + 1 .. end];
    const next = if (j < tex.len) j + 1 else j;
    return .{ .body = body, .next = next };
}

/// Read a `{...}` group with brace-depth counting. Start must point at `{`.
/// Returns slice inside braces and index after closing `}`.
fn readBalancedBraces(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '{') return null;
    var depth: usize = 1;
    var j = start + 1;
    while (j < tex.len) : (j += 1) {
        const c = tex[j];
        if (c == '{') {
            depth += 1;
        } else if (c == '}') {
            depth -= 1;
            if (depth == 0) {
                const body = tex[start + 1 .. j];
                return .{ .body = body, .next = j + 1 };
            }
        }
    }
    return null; // unclosed
}

/// Read a \begin{name} ... \end{name} environment starting at `start` where tex[start] == '\\'.
/// Returns env name, body, and index just after the matching end.
fn readEnvironment(tex: []const u8, start: usize) ?struct {
    env: []const u8,
    body: []const u8,
    next: usize,
} {
    const begin_cmd = readCommandName(tex, start) orelse return null;
    if (!std.ascii.eqlIgnoreCase(begin_cmd.name, "begin")) return null;

    const begin_brace = readBalancedBraces(tex, begin_cmd.next) orelse return null;
    const env_name = begin_brace.body;

    var scan = begin_brace.next;
    while (scan < tex.len) {
        const maybe_cmd = readCommandName(tex, scan) orelse {
            scan += 1;
            continue;
        };
        if (std.ascii.eqlIgnoreCase(maybe_cmd.name, "end")) {
            if (readBalancedBraces(tex, maybe_cmd.next)) |end_brace| {
                if (std.ascii.eqlIgnoreCase(end_brace.body, env_name)) {
                    const body_slice = tex[begin_brace.next..scan];
                    return .{ .env = env_name, .body = body_slice, .next = end_brace.next };
                }
            }
        }
        scan = maybe_cmd.next;
    }
    return null;
}

/// Collapse all whitespace runs to a single space and trim ends.
fn collapseSpaces(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();

    var i: usize = 0;
    var in_space = false;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (c == ' ' or c == '\t' or c == '\n' or c == '\r') {
            if (!in_space) {
                in_space = true;
                try out.append(' ');
            }
        } else {
            in_space = false;
            try out.append(c);
        }
    }
    // trim leading/trailing single space
    while (out.items.len != 0 and out.items[0] == ' ')
        _ = out.orderedRemove(0);
    while (out.items.len != 0 and out.items[out.items.len - 1] == ' ')
        _ = out.pop();

    return out.toOwnedSlice();
}

/// Remove all backslashes, then trim spaces.
fn stripBackslashesAndTrim(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var tmp = std.ArrayList(u8).init(allocator);
    errdefer tmp.deinit();
    for (s) |ch| {
        if (ch != '\\') try tmp.append(ch);
    }
    const v = trimSpaces(tmp.items);
    return allocator.dupe(u8, v);
}

// -------------------------
// Emit helpers (dcz)
// -------------------------

fn emitMetaKV(w: anytype, k: []const u8, v: []const u8) !void {
    const key = trimSpaces(k);
    const val = trimSpaces(v);
    if (key.len == 0 or val.len == 0) return;
    try w.print("@meta({s}=\"{s}\") @end\n", .{ key, val });
}

fn emitTitle(w: anytype, title: []const u8) !void {
    const t = trimSpaces(title);
    if (t.len == 0) return;
    try w.print("@meta(title=\"{s}\") @end\n", .{t});
}

fn emitHeading(w: anytype, level: u8, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("@heading(level={d}) {s} @end\n", .{ level, t });
}

fn emitPara(w: anytype, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("{s}\n", .{t});
}

fn emitImage(w: anytype, src: []const u8) !void {
    const s = trimSpaces(src);
    if (s.len == 0) return;
    try w.print("@image(src=\"{s}\") @end\n", .{s});
}

fn emitCode(w: anytype, body: []const u8) !void {
    try w.print("@code(language=\"\")\n{s}\n@end\n", .{body});
}

fn emitMath(w: anytype, body: []const u8) !void {
    const t = trimSpaces(body);
    if (t.len == 0) return;
    try w.print("@math {s} @end\n", .{t});
}

fn flushPara(wr: anytype, buf: *std.ArrayList(u8)) !void {
    const t = trimSpaces(buf.items);
    if (t.len != 0) try emitPara(wr, t);
    buf.clearRetainingCapacity();
}

// -------------------------
// Core conversion
// -------------------------

/// Convert a small, practical subset of LaTeX to .dcz text.
/// Non-matching commands are skipped; plain text becomes paragraphs.
pub fn importLatexToDcz(allocator: std.mem.Allocator, tex: []const u8) ![]u8 {
    var out_buf = std.ArrayList(u8).init(allocator);
    errdefer out_buf.deinit();

    var para_buf = std.ArrayList(u8).init(allocator);
    defer para_buf.deinit();

    var i: usize = 0;
    while (i < tex.len) {
        const c = tex[i];

        // Blank line = paragraph boundary
        if (c == '\n') {
            const next_nl: u8 = if (i + 1 < tex.len) tex[i + 1] else 0;
            if (next_nl == '\n') {
                try flushParagraph(&out_buf, &para_buf);
                i += 2;
                continue;
            }
        }

        if (c == '\\') {
            // Handle "\\" disambiguation
            if (i + 1 < tex.len and tex[i + 1] == '\\') {
                if (i + 2 < tex.len and std.ascii.isAlphabetic(tex[i + 2])) {
                    i += 1; // let the next '\' start a command
                } else {
                    // Real LaTeX line break -> single space
                    const need_space =
                        para_buf.items.len == 0 or
                        (para_buf.items[para_buf.items.len - 1] != ' ' and
                            para_buf.items[para_buf.items.len - 1] != '\n');
                    if (need_space) try para_buf.append(' ');
                    i += 2;
                    continue;
                }
            }

            // 1) Environments: \begin{...} ... \end{...}
            if (readEnvironment(tex, i)) |env| {
                try flushParagraph(&out_buf, &para_buf);

                if (std.ascii.eqlIgnoreCase(env.env, "verbatim")) {
                    try emitCode(out_buf.writer(), env.body);
                } else if (std.ascii.eqlIgnoreCase(env.env, "equation") or
                    std.ascii.eqlIgnoreCase(env.env, "equation*"))
                {
                    // Normalize whitespace inside math.
                    const collapsed = try collapseSpaces(allocator, env.body);
                    defer allocator.free(collapsed);

                    // NEW: trim any trailing '\' (and spaces before it) from the math body.
                    var view = collapsed;
                    while (view.len > 0 and (view[view.len - 1] == ' ' or view[view.len - 1] == '\\')) {
                        view = view[0 .. view.len - 1];
                    }

                    if (view.len != 0) {
                        try emitMath(out_buf.writer(), view);
                    }
                } else {
                    // Unknown env: ignore for now.
                }

                i = env.next;
                continue;
            }

            // 2) Simple commands
            if (readCommandName(tex, i)) |cmd| {
                const name = cmd.name;

                // \title{...} / \author{...}
                if (std.ascii.eqlIgnoreCase(name, "title") or
                    std.ascii.eqlIgnoreCase(name, "author"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(&out_buf, &para_buf);
                        if (std.ascii.eqlIgnoreCase(name, "title")) {
                            try emitTitle(out_buf.writer(), grp.body);
                        } else {
                            try emitMetaKV(out_buf.writer(), "author", grp.body);
                        }
                        i = grp.next;
                        continue;
                    }
                }

                // \section / \subsection / \subsubsection
                if (std.ascii.eqlIgnoreCase(name, "section") or
                    std.ascii.eqlIgnoreCase(name, "subsection") or
                    std.ascii.eqlIgnoreCase(name, "subsubsection"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(&out_buf, &para_buf);
                        const lvl: u8 = if (std.ascii.eqlIgnoreCase(name, "section")) 1 else if (std.ascii.eqlIgnoreCase(name, "subsection")) 2 else 3;
                        try emitHeading(out_buf.writer(), lvl, grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // \includegraphics[...]{path}
                if (std.ascii.eqlIgnoreCase(name, "includegraphics")) {
                    const opt = readOptionalBracket(tex, cmd.next); // ignored for now
                    const after = if (opt) |o| o.next else cmd.next;
                    if (readBalancedBraces(tex, after)) |grp| {
                        try flushParagraph(&out_buf, &para_buf);
                        try emitImage(out_buf.writer(), grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // Unknown command: drop command + one braced arg if present
                if (readBalancedBraces(tex, cmd.next)) |grp| {
                    i = grp.next;
                } else {
                    i = cmd.next;
                }
                continue;
            }
        }

        // Default: accumulate paragraph text
        try para_buf.append(c);
        i += 1;
    }

    // Final flush
    try flushParagraph(&out_buf, &para_buf);
    return out_buf.toOwnedSlice();
}

// -------------------------
// Low-level bracket readers
// -------------------------

fn readBraced(allocator: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '{') return allocator.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '{') depth += 1 else if (tex[i] == '}') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return allocator.dupe(u8, tex[start .. i - 1]);
}

fn readBracketed(allocator: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '[') return allocator.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '[') depth += 1 else if (tex[i] == ']') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return allocator.dupe(u8, tex[start .. i - 1]);
}

// -------------------------
// Unit tests (with helpful failure dumps)
// -------------------------

fn assertContains(hay: []const u8, needle: []const u8) !void {
    if (std.mem.indexOf(u8, hay, needle) == null) {
        std.debug.print(
            "\nASSERT CONTAINS failed.\n--- needle ---\n{s}\n--- hay ---\n{s}\n--------------\n",
            .{ needle, hay },
        );
        return error.TestUnexpectedResult;
    }
}

test "latex_import: title and author to meta" {
    const tex =
        \\\\title{My Paper}
        \\\\author{Jane Doe}
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@meta(title=\"My Paper\") @end");
    try assertContains(out, "@meta(author=\"Jane Doe\") @end");
}

test "latex_import: sections to headings" {
    const tex =
        \\\\section{Intro}
        \\Some text.
        \\\\subsection{Background}
        \\More text.
        \\\\subsubsection{Details}
        \\End.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@heading(level=1) Intro @end");
    try assertContains(out, "@heading(level=2) Background @end");
    try assertContains(out, "@heading(level=3) Details @end");
}

test "latex_import: graphics, verbatim, equation, and paragraphs" {
    const tex =
        \\Here is an intro paragraph.
        \\
        \\\\includegraphics[width=3in]{figs/plot.pdf}
        \\
        \\\\begin{verbatim}
        \\const x = 42;
        \\\\end{verbatim}
        \\
        \\\\begin{equation}
        \\E = mc^2
        \\\\end{equation}
        \\
        \\A final paragraph.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Here is an intro paragraph.\n");
    try assertContains(out, "@image(src=\"figs/plot.pdf\") @end");
    try assertContains(out,
        \\@code(language="")
    );
    try assertContains(out, "const x = 42;");
    try assertContains(out, "@math E = mc^2 @end");
    try assertContains(out, "A final paragraph.\n");
}

test "latex_import: ignores unknown commands and keeps text" {
    const tex =
        \\Some \\unknowncmd{stuff} remains as text.
        \\And \\alpha more text.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Some  remains as text.");
    try assertContains(out, "And  more text.");
}

<<<

`export.zig`: >>>

const std = @import("std");
const docz = @import("docz"); // public module root
const ASTNode = docz.AST.ASTNode;
const NodeType = docz.AST.NodeType;

// ─────────────────────────────────────────────────────────────
// Head helpers
// ─────────────────────────────────────────────────────────────

fn writeHeadFromMeta(root: *const ASTNode, w: anytype) !void {
    var wrote_title = false;

    for (root.children.items) |node| {
        if (node.node_type != .Meta) continue;

        var it = node.attributes.iterator();
        while (it.next()) |entry| {
            const k = entry.key_ptr.*;
            const v = entry.value_ptr.*;
            if (std.ascii.eqlIgnoreCase(k, "title")) {
                if (!wrote_title) {
                    try w.print("<title>{s}</title>\n", .{v});
                    wrote_title = true;
                }
            } else {
                try w.print("<meta name=\"{s}\" content=\"{s}\">\n", .{ k, v });
            }
        }
    }
}

fn writeImports(root: *const ASTNode, w: anytype) !void {
    // Minimal: only link rel=stylesheet for Import nodes (href)
    for (root.children.items) |node| {
        if (node.node_type != .Import) continue;
        const href = node.attributes.get("href") orelse "";
        if (href.len != 0) {
            try w.print("<link rel=\"stylesheet\" href=\"{s}\">\n", .{href});
        }
    }
}

/// Optional baseline stylesheet:
/// If any Meta node contains key "default_css", insert
///   <link rel="stylesheet" href="...">
/// Example in .dcz:
///   @meta(default_css="/_docz/default.css") @end
fn writeDefaultCssLink(root: *const ASTNode, w: anytype) !void {
    var href: []const u8 = "";
    var found = false;

    // Last-write-wins across Meta nodes
    for (root.children.items) |node| {
        if (node.node_type != .Meta) continue;
        if (node.attributes.get("default_css")) |v| {
            href = v;
            found = true;
        }
    }

    if (found and href.len != 0) {
        try w.print("<link rel=\"stylesheet\" href=\"{s}\">\n", .{href});
    }
}

/// Merge all Css node bodies into a single <style>…</style> in <head>.
fn writeInlineCss(root: *const ASTNode, w: anytype) !void {
    var opened = false;
    for (root.children.items) |node| {
        if (node.node_type != .Css) continue;
        if (!opened) {
            try w.writeAll("<style>\n");
            opened = true;
        }
        if (node.content.len != 0) {
            try w.writeAll(node.content);
            try w.writeAll("\n");
        }
    }
    if (opened) try w.writeAll("</style>\n");
}

// ─────────────────────────────────────────────────────────────
// Style alias support
// ─────────────────────────────────────────────────────────────

/// Build a single alias map from all StyleDef nodes (last write wins).
fn buildStyleAliases(doc: *const ASTNode, allocator: std.mem.Allocator) !std.StringHashMap([]const u8) {
    // Output map: owns both keys and values.
    var out = std.StringHashMap([]const u8).init(allocator);
    errdefer {
        var itf = out.iterator();
        while (itf.next()) |e| {
            allocator.free(e.key_ptr.*);
            allocator.free(e.value_ptr.*);
        }
        out.deinit();
    }

    // Walk document once, merging all StyleDef blocks.
    for (doc.children.items) |node| {
        if (node.node_type != .StyleDef) continue;

        // Temporary parsed aliases: also owns its keys/values.
        var parsed = try node.parseStyleAliases(allocator);

        // Duplicate into `out`, then free `parsed` entries.
        var it = parsed.iterator();
        while (it.next()) |e| {
            const alias = e.key_ptr.*;
            const classes = e.value_ptr.*;

            // Insert/replace into `out` (duplicate to make ownership explicit).
            const gop = try out.getOrPut(try allocator.dupe(u8, alias));
            if (gop.found_existing) {
                // Free the newly allocated probe key; keep existing key
                allocator.free(gop.key_ptr.*);
                // Replace value
                allocator.free(gop.value_ptr.*);
                gop.value_ptr.* = try allocator.dupe(u8, classes);
            } else {
                gop.value_ptr.* = try allocator.dupe(u8, classes);
            }
        }

        // Free all entries owned by `parsed`, then drop the map struct.
        var itp = parsed.iterator();
        while (itp.next()) |e| {
            allocator.free(e.key_ptr.*);
            allocator.free(e.value_ptr.*);
        }
        parsed.deinit();
    }

    return out;
}

/// Resolve classes for a Style node: prefer explicit classes=, else lookup name= in alias map.
fn resolveStyleClasses(style_node: *const ASTNode, aliases: *const std.StringHashMap([]const u8)) []const u8 {
    if (style_node.attributes.get("classes")) |cls| return cls;
    if (style_node.attributes.get("name")) |alias| {
        if (aliases.get(alias)) |resolved| return resolved;
    }
    return "";
}

// ─────────────────────────────────────────────────────────────
// Debug helpers (opt-in with @meta(debug_css="true"))
// ─────────────────────────────────────────────────────────────

fn metaFlag(root: *const ASTNode, key: []const u8) bool {
    for (root.children.items) |node| {
        if (node.node_type != .Meta) continue;
        if (node.attributes.get(key)) |v| {
            if (std.ascii.eqlIgnoreCase(v, "true") or std.ascii.eqlIgnoreCase(v, "1")) return true;
        }
    }
    return false;
}

fn collectImports(root: *const ASTNode, allocator: std.mem.Allocator) !std.ArrayList([]const u8) {
    var list = std.ArrayList([]const u8).init(allocator);
    errdefer {
        for (list.items) |s| allocator.free(s);
        list.deinit();
    }
    for (root.children.items) |node| {
        if (node.node_type != .Import) continue;
        if (node.attributes.get("href")) |href| {
            try list.append(try allocator.dupe(u8, href));
        }
    }
    return list;
}

fn mergeCss(root: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var buf = std.ArrayList(u8).init(allocator);
    errdefer buf.deinit();

    for (root.children.items) |node| {
        if (node.node_type != .Css) continue;
        if (node.content.len != 0) {
            try buf.appendSlice(node.content);
            try buf.append('\n');
        }
    }
    return buf.toOwnedSlice();
}

/// Visible debug box at top of <body> showing what we emitted into <head>.
fn writeDebugCssBanner(root: *const ASTNode, w: anytype, allocator: std.mem.Allocator) !void {
    if (!metaFlag(root, "debug_css")) return;

    // Obvious style so you can *see* head CSS applied
    try w.writeAll("<style>body{background:#fffbe6}</style>\n");

    var imports = try collectImports(root, allocator);
    defer {
        for (imports.items) |s| allocator.free(s);
        imports.deinit();
    }

    const css = try mergeCss(root, allocator);
    defer allocator.free(css);

    try w.writeAll(
        \\<div style="font:13px/1.4 system-ui, sans-serif; background:#fffbcc; color:#222; border-bottom:1px solid #e6db55; padding:10px; margin:0 0 10px 0">
        \\  <strong>Docz CSS Debug</strong><br>
        \\  Css blocks: 
    );

    var css_count: usize = 0;
    for (root.children.items) |node| {
        if (node.node_type == .Css) css_count += 1;
    }
    try w.print("{d}", .{css_count});

    try w.writeAll(" &middot; Imports: ");
    try w.print("{d}", .{imports.items.len});
    try w.writeAll("<br>\n");

    if (imports.items.len > 0) {
        try w.writeAll("  <div>Links:<ul style=\"margin:4px 0 0 18px\">");
        for (imports.items) |href| try w.print("<li><code>{s}</code></li>", .{href});
        try w.writeAll("</ul></div>\n");
    }

    // Show a preview of CSS (truncated)
    const preview_len = if (css.len > 800) 800 else css.len;
    try w.writeAll("  <div>Inline &lt;style&gt; preview:</div>\n");
    try w.writeAll("  <pre style=\"white-space:pre-wrap; background:#111; color:#eee; padding:8px; border-radius:6px; margin:6px 0 0 0\">");
    try w.writeAll(css[0..preview_len]);
    if (css.len > preview_len) try w.writeAll("\n…(truncated)...");
    try w.writeAll("</pre>\n</div>\n");
}

// ─────────────────────────────────────────────────────────────
// Body writer
// ─────────────────────────────────────────────────────────────

fn writeBodyFromAst(root: *const ASTNode, w: anytype, aliases: *const std.StringHashMap([]const u8)) !void {
    for (root.children.items) |node| {
        switch (node.node_type) {
            .Meta => {
                // Meta already emitted in <head>.
            },
            .Heading => {
                const level = node.attributes.get("level") orelse "1";
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                try w.print("<h{s}>{s}</h{s}>\n", .{ level, text, level });
            },
            .Content => {
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                if (text.len != 0) try w.print("<p>{s}</p>\n", .{text});
            },
            .CodeBlock => {
                try w.print("<pre><code>{s}</code></pre>\n", .{node.content});
            },
            .Math => {
                // Minimal math wrapper; client picks renderer (KaTeX/MathJax/etc.)
                try w.print("<div class=\"math\">{s}</div>\n", .{node.content});
            },
            .Media => {
                const src = node.attributes.get("src") orelse "";
                if (src.len != 0) try w.print("<img src=\"{s}\" />\n", .{src});
            },
            .Import, .Css, .StyleDef => {
                // handled in head or pre-pass; no body output
            },
            .Style => {
                const classes = resolveStyleClasses(&node, aliases);
                if (classes.len != 0) {
                    try w.print("<div class=\"{s}\">{s}</div>\n", .{ classes, node.content });
                } else {
                    // No classes resolved; output a plain wrapper for forward-compat.
                    try w.print("<div>{s}</div>\n", .{node.content});
                }
            },
            .Unknown => {
                try w.writeAll("<!-- Unhandled node: Unknown -->\n");
            },
            else => {
                // leave a comment for any future node types
                try w.print("<!-- Unhandled node: {s} -->\n", .{@tagName(node.node_type)});
            },
        }
    }
}

// ─────────────────────────────────────────────────────────────
// Public helpers for CLI (CSS externalization path)
// ─────────────────────────────────────────────────────────────

/// Collect the concatenated contents of all Css nodes in document order.
/// Returns a newly-allocated buffer (caller frees).
pub fn collectInlineCss(root: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var buf = std.ArrayList(u8).init(allocator);
    errdefer buf.deinit();

    for (root.children.items) |node| {
        if (node.node_type != .Css) continue;
        if (node.content.len != 0) {
            try buf.appendSlice(node.content);
            try buf.append('\n');
        }
    }
    return buf.toOwnedSlice();
}

/// Remove the *first* <style ...>...</style> block from `html`.
/// If none found, returns a duplicate of `html`.
/// Robust to attributes on <style>, e.g. <style media="all">.
pub fn stripFirstStyleBlock(html: []const u8, allocator: std.mem.Allocator) ![]u8 {
    const open_tag_needle = "<style";
    const close_tag_needle = "</style>";

    const open_idx_opt = std.mem.indexOf(u8, html, open_tag_needle);
    if (open_idx_opt == null) {
        // nothing to strip; return a copy
        return try allocator.dupe(u8, html);
    }
    const open_idx = open_idx_opt.?;

    // find end of opening tag '>'
    const gt_idx_opt = std.mem.indexOfScalarPos(u8, html, open_idx, '>');
    if (gt_idx_opt == null) {
        // malformed; be conservative and return original
        return try allocator.dupe(u8, html);
    }
    const open_gt = gt_idx_opt.? + 1; // first byte after '>'

    // find the corresponding closing tag
    const close_idx_opt = std.mem.indexOfPos(u8, html, open_gt, close_tag_needle);
    if (close_idx_opt == null) {
        // malformed; return original
        return try allocator.dupe(u8, html);
    }
    const close_idx = close_idx_opt.?;
    const close_end = close_idx + close_tag_needle.len;

    // Build result = html[0..open_idx] ++ html[close_end..]
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();

    try out.appendSlice(html[0..open_idx]);

    // Optionally trim one trailing newline right before <style> to keep tidy formatting.
    if (out.items.len > 0 and out.items[out.items.len - 1] == '\n') {
        _ = out.pop();
    }

    try out.appendSlice(html[close_end..]);

    return out.toOwnedSlice();
}

// ─────────────────────────────────────────────────────────────
// Public API
// ─────────────────────────────────────────────────────────────

/// Export AST -> minimal HTML5 document with head assets:
/// - Meta → <title>/<meta>
/// - Import(href) → <link rel="stylesheet" …>
/// - Css blocks → merged <style>…</style>
/// - StyleDef → alias map; Style(name|classes) → <div class="…">…</div>
/// - Optional default_css (from @meta) → <link rel="stylesheet" href="…">
pub fn exportHtml(doc: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    const w = out.writer();

    // Build aliases once (cheap map; freed at end).
    var aliases = try buildStyleAliases(doc, allocator);
    defer {
        var it = aliases.iterator();
        while (it.next()) |e| {
            allocator.free(e.key_ptr.*);
            allocator.free(e.value_ptr.*);
        }
        aliases.deinit();
    }

    try w.writeAll("<!DOCTYPE html>\n<html>\n<head>\n");
    try writeHeadFromMeta(doc, w);
    try writeImports(doc, w);
    try writeDefaultCssLink(doc, w); // optional baseline CSS via @meta(default_css="…")
    try writeInlineCss(doc, w);
    try w.writeAll("</head>\n<body>\n");

    // Debug overlay (only if @meta(debug_css="true"))
    try writeDebugCssBanner(doc, w, allocator);

    try writeBodyFromAst(doc, w, &aliases);

    try w.writeAll("</body>\n</html>\n");
    return out.toOwnedSlice();
}

// ─────────────────────────────────────────────────────────────
// Unit tests
// ─────────────────────────────────────────────────────────────

test "html_export: emits title/meta/import/css and basic body" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    // Build a tiny AST
    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    // Meta
    {
        var meta = ASTNode.init(A, NodeType.Meta);
        try meta.attributes.put("title", "Hello");
        try meta.attributes.put("author", "Docz Team");
        try root.children.append(meta);
    }
    // Import (stylesheet)
    {
        var imp = ASTNode.init(A, NodeType.Import);
        try imp.attributes.put("href", "/styles/site.css");
        try root.children.append(imp);
    }
    // Css (inline)
    {
        var css = ASTNode.init(A, NodeType.Css);
        css.content = ".card{border:1px solid #ccc}";
        try root.children.append(css);
    }
    // Body: heading, para
    {
        var h = ASTNode.init(A, NodeType.Heading);
        try h.attributes.put("level", "1");
        h.content = "Welcome";
        try root.children.append(h);

        var p = ASTNode.init(A, NodeType.Content);
        p.content = "First paragraph.";
        try root.children.append(p);
    }

    const html = try exportHtml(&root, A);
    defer A.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "<title>Hello</title>") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "<meta name=\"author\" content=\"Docz Team\">") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "<link rel=\"stylesheet\" href=\"/styles/site.css\">") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "<style>") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, ".card{border:1px solid #ccc}") != null);

    try std.testing.expect(std.mem.indexOf(u8, html, "<h1>Welcome</h1>") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "<p>First paragraph.</p>") != null);
}

test "html_export: StyleDef + Style(name) expansion" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    // Define aliases
    {
        var def = ASTNode.init(A, NodeType.StyleDef);
        def.content =
            \\heading-1: h1-xl h1-weight
            \\body-text: prose max-w-none
        ;
        try root.children.append(def);
    }
    // Use alias via name=
    {
        var s = ASTNode.init(A, NodeType.Style);
        try s.attributes.put("name", "heading-1");
        s.content = "Title";
        try root.children.append(s);
    }
    // Direct classes=
    {
        var s2 = ASTNode.init(A, NodeType.Style);
        try s2.attributes.put("classes", "text-lg font-bold");
        s2.content = "Bold";
        try root.children.append(s2);
    }

    const html = try exportHtml(&root, A);
    defer A.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "<div class=\"h1-xl h1-weight\">Title</div>") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "<div class=\"text-lg font-bold\">Bold</div>") != null);
}

test "html_export: head assets stay in <head>, not body" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    var def = ASTNode.init(A, NodeType.StyleDef);
    def.content = "a: b";
    try root.children.append(def);

    var css = ASTNode.init(A, NodeType.Css);
    css.content = ".x{y:z}";
    try root.children.append(css);

    var imp = ASTNode.init(A, NodeType.Import);
    try imp.attributes.put("href", "/a.css");
    try root.children.append(imp);

    const html = try exportHtml(&root, A);
    defer A.free(html);

    // We should have a </head> boundary.
    const head_end_opt = std.mem.indexOf(u8, html, "</head>");
    try std.testing.expect(head_end_opt != null);
    const head_end = head_end_opt.?;

    // CSS content must exist, but only before </head>.
    const css_pos_opt = std.mem.indexOf(u8, html, ".x{y:z}");
    try std.testing.expect(css_pos_opt != null);
    try std.testing.expect(css_pos_opt.? < head_end);

    // And that CSS must not appear in the body slice.
    const body_slice = html[head_end..];
    try std.testing.expect(std.mem.indexOf(u8, body_slice, ".x{y:z}") == null);

    // StyleDef raw text should not appear anywhere (it's meta, not emitted).
    try std.testing.expect(std.mem.indexOf(u8, html, "a: b") == null);

    // Import should be present in head as a link.
    try std.testing.expect(std.mem.indexOf(u8, html, "<link rel=\"stylesheet\" href=\"/a.css\">") != null);
}

test "collectInlineCss joins Css nodes" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit();

    var c1 = ASTNode.init(A, NodeType.Css);
    c1.content = "a{color:red}";
    try root.children.append(c1);

    var c2 = ASTNode.init(A, NodeType.Css);
    c2.content = "b{font-weight:bold}";
    try root.children.append(c2);

    const css = try collectInlineCss(&root, A);
    defer A.free(css);

    try std.testing.expect(std.mem.indexOf(u8, css, "a{color:red}\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, css, "b{font-weight:bold}\n") != null);
}

test "stripFirstStyleBlock removes the first <style>...</style>" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const html =
        \\<head>
        \\<style>
        \\body{margin:0}
        \\</style>
        \\<style id="second">h1{font-weight:700}</style>
        \\</head>
    ;
    const out = try stripFirstStyleBlock(html, A);
    defer A.free(out);

    // first style removed
    try std.testing.expect(std.mem.indexOf(u8, out, "body{margin:0}") == null);
    // second remains
    try std.testing.expect(std.mem.indexOf(u8, out, "h1{font-weight:700}") != null);
}

<<<

`import.zig`: >>>

const std = @import("std");
const docz = @import("docz");

fn contains(hay: []const u8, needle: []const u8) bool {
    return std.mem.indexOf(u8, hay, needle) != null;
}

fn asciiLower(c: u8) u8 {
    return if (c >= 'A' and c <= 'Z') c + 32 else c;
}

fn startsWithInsensitive(s: []const u8, tag: []const u8) bool {
    if (s.len < tag.len) return false;
    var j: usize = 0;
    while (j < tag.len) : (j += 1) {
        if (asciiLower(s[j]) != asciiLower(tag[j])) return false;
    }
    return true;
}

fn findInsensitive(hay: []const u8, needle: []const u8) ?usize {
    if (needle.len == 0 or hay.len < needle.len) return null;
    var k: usize = 0;
    while (k + needle.len <= hay.len) : (k += 1) {
        if (startsWithInsensitive(hay[k..], needle)) return k;
    }
    return null;
}

fn trimSpaces(s: []const u8) []const u8 {
    return std.mem.trim(u8, s, " \t\r\n");
}

fn extractBetweenInsensitive(hay: []const u8, start_pat: []const u8, end_pat: []const u8) ?[]const u8 {
    const a = findInsensitive(hay, start_pat) orelse return null;
    const rest = hay[a + start_pat.len ..];
    const b_rel = findInsensitive(rest, end_pat) orelse return null;
    return rest[0..b_rel];
}

fn getAttrLower(tag_inner: []const u8, attr: []const u8) ?[]const u8 {
    // very small attribute scanner: attr="value" or attr='value'
    var j: usize = 0;
    while (j < tag_inner.len) : (j += 1) {
        while (j < tag_inner.len and std.ascii.isWhitespace(tag_inner[j])) : (j += 1) {}
        const key_start = j;
        while (j < tag_inner.len and (std.ascii.isAlphabetic(tag_inner[j]) or tag_inner[j] == '-' or tag_inner[j] == ':')) : (j += 1) {}
        const key = tag_inner[key_start..j];
        if (key.len == 0) break;

        while (j < tag_inner.len and std.ascii.isWhitespace(tag_inner[j])) : (j += 1) {}
        if (j >= tag_inner.len or tag_inner[j] != '=') {
            while (j < tag_inner.len and !std.ascii.isWhitespace(tag_inner[j])) : (j += 1) {}
            continue;
        }
        j += 1; // '='
        while (j < tag_inner.len and std.ascii.isWhitespace(tag_inner[j])) : (j += 1) {}
        if (j >= tag_inner.len) break;

        var quote: u8 = 0;
        if (tag_inner[j] == '"' or tag_inner[j] == '\'') {
            quote = tag_inner[j];
            j += 1;
        }
        const v_start = j;
        if (quote != 0) {
            while (j < tag_inner.len and tag_inner[j] != quote) : (j += 1) {}
            const v = tag_inner[v_start..@min(j, tag_inner.len)];
            if (j < tag_inner.len) j += 1;
            if (std.ascii.eqlIgnoreCase(key, attr)) return v;
        } else {
            while (j < tag_inner.len and !std.ascii.isWhitespace(tag_inner[j]) and tag_inner[j] != '>' and tag_inner[j] != '/') : (j += 1) {}
            const v = tag_inner[v_start..j];
            if (std.ascii.eqlIgnoreCase(key, attr)) return v;
        }
    }
    return null;
}

// ---- emit helpers ----

fn emitMetaKV(w: anytype, k: []const u8, v: []const u8) !void {
    try w.print("@meta({s}=\"{s}\") @end\n", .{ k, v });
}

fn emitTitle(w: anytype, title: []const u8) !void {
    try w.print("@meta(title=\"{s}\") @end\n", .{title});
}

fn emitHeading(w: anytype, level: u8, text: []const u8) !void {
    try w.print("@heading(level={d}) {s} @end\n", .{ level, text });
}

fn emitPara(w: anytype, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("{s}\n", .{t});
}

fn emitImage(w: anytype, src: []const u8) !void {
    try w.print("@image(src=\"{s}\") @end\n", .{src});
}

fn emitImportCss(w: anytype, href: []const u8) !void {
    try w.print("@import(href=\"{s}\") @end\n", .{href});
}

fn emitCode(w: anytype, lang: []const u8, body: []const u8) !void {
    if (lang.len > 0) {
        try w.print("@code(language=\"{s}\")\n{s}\n@end\n", .{ lang, body });
    } else {
        try w.print("@code(language=\"\")\n{s}\n@end\n", .{body});
    }
}

// ---- main API ----

pub fn importHtmlToDcz(allocator: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8).init(allocator);
    errdefer out.deinit();
    const w = out.writer();

    // HEAD: title/meta/stylesheet
    if (extractBetweenInsensitive(html, "<head", "</head>")) |head| {
        if (extractBetweenInsensitive(head, "<title", "</title>")) |tchunk| {
            const gt = std.mem.indexOfScalar(u8, tchunk, '>') orelse 0;
            const t = trimSpaces(tchunk[gt + 1 ..]);
            if (t.len > 0) try emitTitle(w, t);
        }

        // meta
        var scan: usize = 0;
        while (true) {
            const mpos = findInsensitive(head[scan..], "<meta") orelse break;
            const mstart = scan + mpos;
            const mend_rel = std.mem.indexOfScalar(u8, head[mstart..], '>') orelse break;
            const mend = mstart + mend_rel;
            const inner = head[mstart + "<meta".len .. mend];
            const name = getAttrLower(inner, "name") orelse "";
            const content = getAttrLower(inner, "content") orelse "";
            if (name.len > 0 and content.len > 0) {
                try emitMetaKV(w, name, content);
            }
            scan = mend + 1;
        }

        // link rel=stylesheet
        scan = 0;
        while (true) {
            const lpos = findInsensitive(head[scan..], "<link") orelse break;
            const lstart = scan + lpos;
            const lend_rel = std.mem.indexOfScalar(u8, head[lstart..], '>') orelse break;
            const lend = lstart + lend_rel;
            const inner = head[lstart + "<link".len .. lend];
            const rel = getAttrLower(inner, "rel") orelse "";
            if (rel.len != 0 and std.ascii.eqlIgnoreCase(rel, "stylesheet")) {
                if (getAttrLower(inner, "href")) |href| {
                    if (href.len > 0) try emitImportCss(w, href);
                }
            }
            scan = lend + 1;
        }
    }

    // BODY-ish scan for headings/paras/code/img
    var i: usize = 0;
    while (i < html.len) {
        const lt = std.mem.indexOfScalarPos(u8, html, i, '<') orelse break;

        if (lt > i) {
            const text = trimSpaces(html[i..lt]);
            if (text.len != 0) try emitPara(w, text);
        }

        const rest = html[lt..];

        // headings h1..h6
        var matched_heading = false;
        inline for (.{ 1, 2, 3, 4, 5, 6 }) |lvl| {
            if (!matched_heading) {
                const open_tag = switch (lvl) {
                    1 => "<h1",
                    2 => "<h2",
                    3 => "<h3",
                    4 => "<h4",
                    5 => "<h5",
                    else => "<h6",
                };
                const close_tag = switch (lvl) {
                    1 => "</h1>",
                    2 => "</h2>",
                    3 => "</h3>",
                    4 => "</h4>",
                    5 => "</h5>",
                    else => "</h6>",
                };

                if (startsWithInsensitive(rest, open_tag)) {
                    const gt_rel = std.mem.indexOfScalar(u8, rest, '>') orelse 0;
                    const after = rest[gt_rel + 1 ..];
                    if (findInsensitive(after, close_tag)) |end_rel| {
                        const inner = trimSpaces(after[0..end_rel]);
                        if (inner.len != 0) try emitHeading(w, @intCast(lvl), inner);
                        i = lt + gt_rel + 1 + end_rel + close_tag.len;
                        matched_heading = true;
                    }
                }
            }
        }
        if (matched_heading) continue;

        // <img ...>
        if (startsWithInsensitive(rest, "<img")) {
            const gt_rel = std.mem.indexOfScalar(u8, rest, '>') orelse 0;
            const inner = rest["<img".len..gt_rel];
            if (getAttrLower(inner, "src")) |src| {
                try emitImage(w, src);
            }
            i = lt + gt_rel + 1;
            continue;
        }

        // <pre> ... <code ...>BODY</code> ... </pre>
        if (startsWithInsensitive(rest, "<pre")) {
            const pre_end_rel = findInsensitive(rest, "</pre>") orelse {
                i = lt + 1;
                continue;
            };
            const pre_block = rest[0 .. pre_end_rel + "</pre>".len];
            if (extractBetweenInsensitive(pre_block, "<code", "</code>")) |code_chunk| {
                const gt_rel = std.mem.indexOfScalar(u8, code_chunk, '>') orelse 0;
                const attrs = code_chunk[0..gt_rel];
                const body = code_chunk[gt_rel + 1 ..];
                var lang: []const u8 = "";
                if (getAttrLower(attrs, "class")) |cls| {
                    if (std.mem.startsWith(u8, cls, "language-")) {
                        lang = cls["language-".len..];
                    } else if (std.mem.startsWith(u8, cls, "lang-")) {
                        lang = cls["lang-".len..];
                    }
                }
                try emitCode(w, lang, body);
            }
            i = lt + pre_end_rel + "</pre>".len;
            continue;
        }

        // <p>...</p>
        if (startsWithInsensitive(rest, "<p")) {
            const gt_rel = std.mem.indexOfScalar(u8, rest, '>') orelse 0;
            const after = rest[gt_rel + 1 ..];
            if (findInsensitive(after, "</p>")) |end_rel| {
                try emitPara(w, after[0..end_rel]);
                i = lt + gt_rel + 1 + end_rel + "</p>".len;
                continue;
            }
        }

        // default: skip tag
        const gt_rel = std.mem.indexOfScalar(u8, rest, '>') orelse 0;
        i = lt + gt_rel + 1;
    }

    return out.toOwnedSlice();
}

test "html_import: extracts <title>, <meta>, and <link rel=stylesheet>" {
    const html =
        \\<!doctype html>
        \\<html>
        \\<head>
        \\  <meta name="author" content="Docz Team">
        \\  <meta name="keywords" content="zig,docz">
        \\  <title>My Doc</title>
        \\  <link rel="stylesheet" href="/styles/main.css">
        \\</head>
        \\<body></body>
        \\</html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(contains(out, "@meta(title=\"My Doc\") @end"));
    try std.testing.expect(contains(out, "@meta(author=\"Docz Team\") @end"));
    try std.testing.expect(contains(out, "@meta(keywords=\"zig,docz\") @end"));
    try std.testing.expect(contains(out, "@import(href=\"/styles/main.css\") @end"));
}

test "html_import: headings and paragraphs" {
    const html =
        \\<html>
        \\<body>
        \\  <h1>Top</h1>
        \\  <p>First paragraph.</p>
        \\  <h2>Sub</h2>
        \\  <p>Second paragraph.</p>
        \\</body>
        \\</html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(contains(out, "@heading(level=1) Top @end"));
    try std.testing.expect(contains(out, "First paragraph.\n"));
    try std.testing.expect(contains(out, "@heading(level=2) Sub @end"));
    try std.testing.expect(contains(out, "Second paragraph.\n"));
}

test "html_import: <img src> and <pre><code class=language-*> blocks" {
    const html =
        \\<html>
        \\<body>
        \\  <img src="img/logo.png" alt="x">
        \\  <pre><code class="language-zig">const x = 42;</code></pre>
        \\  <pre><code class="lang-python">print(1)</code></pre>
        \\</body>
        \\</html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(contains(out, "@image(src=\"img/logo.png\") @end"));

    try std.testing.expect(contains(out,
        \\@code(language="zig")
    ));
    try std.testing.expect(contains(out, "const x = 42;"));
    try std.testing.expect(contains(out, "@end\n"));

    try std.testing.expect(contains(out,
        \\@code(language="python")
    ));
    try std.testing.expect(contains(out, "print(1)"));
}

test "html_import: case-insensitive tags and loose whitespace" {
    const html =
        \\<HTML>
        \\<HeAd>
        \\  <TiTlE>  Mixed Case  </TiTlE>
        \\</HeAd>
        \\<BoDy>
        \\  <H3>  Trim Me  </H3>
        \\  <P>   spaced text   </P>
        \\</BoDy>
        \\</HTML>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(contains(out, "@meta(title=\"Mixed Case\") @end"));
    try std.testing.expect(contains(out, "@heading(level=3) Trim Me @end"));
    try std.testing.expect(contains(out, "spaced text\n"));
}

test "html_import: unknown tags are skipped safely" {
    const html =
        \\<html>
        \\<body>
        \\  <div><span>keep this text</span></div>
        \\  <weirdtag foo=bar>ignore me</weirdtag>
        \\  <p>and this too</p>
        \\</body>
        \\</html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    // We don’t generate a directive for generic DIV/SPAN; we should still grab
    // free text around tags as paragraphs where possible.
    // Minimal parser behavior: at least see the <p> text.
    try std.testing.expect(contains(out, "and this too\n"));
}

<<<

`build_cmd.zig`: >>>

const std = @import("std");
const docz = @import("docz"); // exposes Tokenizer, Parser, Renderer (HTML)

pub fn run(A: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const in_path = it.next() orelse {
        std.debug.print("Usage: docz build <file.dcz>\n", .{});
        return error.Invalid;
    };

    // 1) Read input
    const input = try readFileAlloc(A, in_path);
    defer A.free(input);

    // 2) DCZ -> tokens -> AST
    const tokens = try docz.Tokenizer.tokenize(input, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }

    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit();

    // 3) Render HTML
    const html = try docz.Renderer.renderHTML(&ast, A);
    defer A.free(html);

    // 4) Write <in>.html
    const out_path = try std.fmt.allocPrint(A, "{s}.html", .{in_path});
    defer A.free(out_path);

    try writeFile(out_path, html);

    // 5) Match existing CLI message shape
    std.debug.print("✔ Built {s} → {s}\n", .{ in_path, out_path });
}

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    return try f.readToEndAlloc(alloc, 1 << 26);
}

fn writeFile(path: []const u8, data: []const u8) !void {
    var f = try std.fs.cwd().createFile(path, .{ .truncate = true });
    defer f.close();
    _ = try f.writeAll(data);
}

<<<

`common.zig`: >>>

const std = @import("std");

pub const Kind = enum { dcz, md, html, tex };

// ---------- stderr helper ----------
fn errW() std.fs.File.Writer {
    var f = std.fs.File{ .handle = std.io.getStdErrHandle() };
    return f.writer();
}

pub fn detectKindFromPath(p: []const u8) ?Kind {
    const ext = std.fs.path.extension(p);
    if (ext.len == 0) return null;
    if (std.ascii.eqlIgnoreCase(ext, ".dcz")) return .dcz;
    if (std.ascii.eqlIgnoreCase(ext, ".md")) return .md;
    if (std.ascii.eqlIgnoreCase(ext, ".html") or std.ascii.eqlIgnoreCase(ext, ".htm")) return .html;
    if (std.ascii.eqlIgnoreCase(ext, ".tex")) return .tex;
    return null;
}

pub fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    return try f.readToEndAlloc(alloc, 1 << 26);
}

pub fn writeFile(path: []const u8, data: []const u8) !void {
    const cwd = std.fs.cwd();
    if (std.fs.path.dirname(path)) |dirpart| {
        try cwd.makePath(dirpart);
    }
    var f = try cwd.createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

pub fn parseTo(it: *std.process.ArgIterator) !?[]const u8 {
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--to") or std.mem.eql(u8, arg, "-t")) {
            return it.next() orelse {
                try errW().writeAll("--to requires a value\n");
                return error.Invalid;
            };
        } else {
            try errW().print("unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }
    return null;
}

test "common.detectKindFromPath: case-insensitive mapping" {
    try std.testing.expect(detectKindFromPath("x.dcz") == .dcz);
    try std.testing.expect(detectKindFromPath("x.DCZ") == .dcz);

    try std.testing.expect(detectKindFromPath("x.md") == .md);
    try std.testing.expect(detectKindFromPath("x.MD") == .md);

    try std.testing.expect(detectKindFromPath("x.html") == .html);
    try std.testing.expect(detectKindFromPath("x.htm") == .html);
    try std.testing.expect(detectKindFromPath("x.HTML") == .html);
    try std.testing.expect(detectKindFromPath("x.HTM") == .html);

    try std.testing.expect(detectKindFromPath("x.tex") == .tex);
    try std.testing.expect(detectKindFromPath("x.TEX") == .tex);

    try std.testing.expect(detectKindFromPath("x") == null);
    try std.testing.expect(detectKindFromPath("x.unknown") == null);
}

<<<

`convert.zig`: >>>

const std = @import("std");
const docz = @import("docz");

// internal converters (wired via build.zig)
const html_import = @import("html_import");
const html_export = @import("html_export");
const md_import = @import("md_import");
const md_export = @import("md_export");
const latex_import = @import("latex_import");
const latex_export = @import("latex_export");

pub const Kind = enum { dcz, md, html, tex };

fn detectKindFromPath(p: []const u8) ?Kind {
    const ext = std.fs.path.extension(p);
    if (ext.len == 0) return null;
    if (std.ascii.eqlIgnoreCase(ext, ".dcz")) return .dcz;
    if (std.ascii.eqlIgnoreCase(ext, ".md")) return .md;
    if (std.ascii.eqlIgnoreCase(ext, ".html") or std.ascii.eqlIgnoreCase(ext, ".htm")) return .html;
    if (std.ascii.eqlIgnoreCase(ext, ".tex")) return .tex;
    return null;
}

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    return try f.readToEndAlloc(alloc, 1 << 26);
}

fn writeFile(path: []const u8, data: []const u8) !void {
    const cwd = std.fs.cwd();
    if (std.fs.path.dirname(path)) |dirpart| {
        try cwd.makePath(dirpart);
    }
    var f = try cwd.createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

// Robust: same directory as input; just replace extension.
fn replaceExt(alloc: std.mem.Allocator, path: []const u8, new_ext_with_dot: []const u8) ![]u8 {
    const dir = std.fs.path.dirname(path);
    const stem = std.fs.path.stem(path); // base name without extension

    if (dir) |d| {
        // docs/spec-file.html -> docs/spec-file.css
        return try std.fmt.allocPrint(alloc, "{s}{c}{s}{s}", .{ d, std.fs.path.sep, stem, new_ext_with_dot });
    } else {
        // spec-file.html -> spec-file.css
        return try std.fmt.allocPrint(alloc, "{s}{s}", .{ stem, new_ext_with_dot });
    }
}

fn insertCssLinkBeforeHeadClose(alloc: std.mem.Allocator, html: []const u8, href: []const u8) ![]u8 {
    const needle = "</head>";
    const idx_opt = std.mem.indexOf(u8, html, needle);
    if (idx_opt == null) {
        // no </head>? prepend for robustness
        return try std.fmt.allocPrint(alloc, "<link rel=\"stylesheet\" href=\"{s}\">\n{s}", .{ href, html });
    }
    const idx = idx_opt.?;
    var out = std.ArrayList(u8).init(alloc);
    errdefer out.deinit();

    try out.appendSlice(html[0..idx]);
    try out.appendSlice("<link rel=\"stylesheet\" href=\"");
    try out.appendSlice(href);
    try out.appendSlice("\">\n");
    try out.appendSlice(html[idx..]);

    return out.toOwnedSlice();
}

fn writeIndent(w: anytype, n: usize) !void {
    var k: usize = 0;
    while (k < n) : (k += 1) try w.writeByte(' ');
}

// ── Pretty-printer helpers (only what we use) ────────────────
fn isWs(b: u8) bool {
    return b == ' ' or b == '\t' or b == '\r';
}
fn lowerAscii(c: u8) u8 {
    return if (c >= 'A' and c <= 'Z') c + 32 else c;
}
fn eqLower(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    var i: usize = 0;
    while (i < a.len) : (i += 1) {
        if (lowerAscii(a[i]) != lowerAscii(b[i])) return false;
    }
    return true;
}
fn isVoidTag(name: []const u8) bool {
    // HTML5 void elements
    return eqLower(name, "area") or eqLower(name, "base") or eqLower(name, "br") or
        eqLower(name, "col") or eqLower(name, "embed") or eqLower(name, "hr") or
        eqLower(name, "img") or eqLower(name, "input") or eqLower(name, "link") or
        eqLower(name, "meta") or eqLower(name, "param") or eqLower(name, "source") or
        eqLower(name, "track") or eqLower(name, "wbr");
}

// ── Pretty printer (single implementation) ───────────────────
fn prettyHtml(alloc: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    errdefer out.deinit();

    var indent: usize = 0;
    var i: usize = 0;

    while (i < html.len) {
        const line_start = i;
        while (i < html.len and html[i] != '\n') : (i += 1) {}
        const raw = html[line_start..i];
        if (i < html.len and html[i] == '\n') i += 1; // consume newline

        const line = std.mem.trim(u8, raw, " \t\r");
        if (line.len == 0) {
            try out.append('\n');
            continue;
        }

        // Analyze the line
        var j: usize = 0;
        while (j < line.len and isWs(line[j])) : (j += 1) {}

        const starts_with_lt = (j < line.len and line[j] == '<');

        var pre_decr: usize = 0;
        var post_incr: usize = 0;

        if (starts_with_lt) {
            const after_lt = j + 1;
            const is_close = after_lt < line.len and line[after_lt] == '/';
            const is_decl_or_comment = after_lt < line.len and (line[after_lt] == '!' or line[after_lt] == '?');

            // Parse tag name
            var name_start: usize = after_lt;
            if (is_close) name_start += 1; // runtime increment only

            while (name_start < line.len and isWs(line[name_start])) : (name_start += 1) {}

            var name_end = name_start;
            while (name_end < line.len) : (name_end += 1) {
                const ch = line[name_end];
                if (ch == '>' or ch == '/' or isWs(ch) or ch == '\n') break;
            }
            const tag_name = if (name_end > name_start) line[name_start..name_end] else line[name_start..name_start];

            // Self-close syntax and void detection
            const self_closed_syntax = line.len >= 2 and line[line.len - 2] == '/' and line[line.len - 1] == '>';
            const voidish = isVoidTag(tag_name);

            // Does this same line contain a closing tag too? (e.g., <h1>hi</h1>)
            const has_inline_close = std.mem.indexOf(u8, line, "</") != null;

            if (is_close and !is_decl_or_comment) {
                if (indent > 0) pre_decr = 1;
            } else if (!is_decl_or_comment and !self_closed_syntax and !voidish) {
                if (!has_inline_close) {
                    post_incr = 1;
                }
            }
        }

        if (pre_decr > 0 and indent >= pre_decr) indent -= pre_decr;

        // Emit line with current indent
        try out.appendNTimes(' ', indent * 2);
        try out.appendSlice(line);
        try out.append('\n');

        indent += post_incr;
    }

    return out.toOwnedSlice();
}

// ─────────────────────────────────────────────────────────────
// PUBLIC ENTRY (called by main.zig)
// ─────────────────────────────────────────────────────────────
pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const usage =
        "Usage: docz convert <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]\n" ++
        "       [--css inline|file] [--css-file <path>] [--pretty|--no-pretty]\n";

    const in_path = it.next() orelse {
        std.debug.print("{s}", .{usage});
        return error.Invalid;
    };

    // flags
    var out_path: ?[]const u8 = null;

    // NOTE: identifier can't be named "inline" in Zig; use inline_css
    const CssMode = enum { inline_css, file };
    var css_mode: CssMode = .inline_css;
    var css_file: ?[]const u8 = null;

    // pretty printing: default ON
    var pretty: bool = true;

    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--to") or std.mem.eql(u8, arg, "-t")) {
            out_path = it.next() orelse {
                std.debug.print("convert: --to requires a value\n", .{});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--css")) {
            const v = it.next() orelse {
                std.debug.print("convert: --css requires a value: inline|file\n", .{});
                return error.Invalid;
            };
            if (std.mem.eql(u8, v, "inline")) {
                css_mode = .inline_css;
            } else if (std.mem.eql(u8, v, "file")) {
                css_mode = .file;
            } else {
                std.debug.print("convert: --css must be 'inline' or 'file' (got '{s}')\n", .{v});
                return error.Invalid;
            }
        } else if (std.mem.eql(u8, arg, "--css-file")) {
            css_file = it.next() orelse {
                std.debug.print("convert: --css-file requires a value\n", .{});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--pretty")) {
            pretty = true;
        } else if (std.mem.eql(u8, arg, "--no-pretty")) {
            pretty = false;
        } else {
            std.debug.print("convert: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    const in_kind = detectKindFromPath(in_path) orelse {
        std.debug.print("convert: unsupported input type: {s}\n", .{in_path});
        return error.Invalid;
    };

    const input = readFileAlloc(alloc, in_path) catch |e| {
        const cwd_buf: ?[]u8 = std.fs.cwd().realpathAlloc(alloc, ".") catch null;
        defer if (cwd_buf) |buf| alloc.free(buf);
        const cwd = cwd_buf orelse "<?>";

        std.debug.print("convert: failed to read '{s}' (cwd: {s}): {s}\n", .{ in_path, cwd, @errorName(e) });
        return e;
    };
    defer alloc.free(input);

    var out_buf: []u8 = &[_]u8{};
    defer if (out_buf.len != 0 and out_buf.ptr != input.ptr) alloc.free(out_buf);

    if (in_kind == .dcz) {
        // DCZ -> AST
        const tokens = try docz.Tokenizer.tokenize(input, alloc);
        defer {
            docz.Tokenizer.freeTokens(alloc, tokens);
            alloc.free(tokens);
        }

        var ast = try docz.Parser.parse(tokens, alloc);
        defer ast.deinit();

        const out_kind = if (out_path) |p| detectKindFromPath(p) else null;

        if (out_kind == null or out_kind.? == .dcz) {
            out_buf = try alloc.dupe(u8, input);
        } else switch (out_kind.?) {
            .md => out_buf = try md_export.exportAstToMarkdown(&ast, alloc),

            .html => {
                // 1) start with inline <style> included by the exporter
                const html_inline = try html_export.exportHtml(&ast, alloc);
                errdefer alloc.free(html_inline);

                if (css_mode == .file) {
                    // 2) decide CSS path (+ ownership)
                    var css_path: []const u8 = undefined;
                    var css_path_needs_free = false;
                    if (css_file) |p| {
                        css_path = p; // user-provided; not owned
                    } else if (out_path) |to_path| {
                        css_path = try replaceExt(alloc, to_path, ".css");
                        css_path_needs_free = true; // owned
                    } else {
                        css_path = "docz.css"; // fallback; not owned
                    }
                    defer if (css_path_needs_free) alloc.free(css_path);

                    // 3) validate extension if present
                    const ext = std.fs.path.extension(css_path);
                    if (ext.len != 0 and !std.ascii.eqlIgnoreCase(ext, ".css")) {
                        std.debug.print("convert: --css-file should end with .css (got {s})\n", .{css_path});
                        return error.Invalid;
                    }

                    // 4) collect CSS from AST and write it
                    const css_blob = try html_export.collectInlineCss(&ast, alloc);
                    defer alloc.free(css_blob);
                    try writeFile(css_path, css_blob);

                    // 5) strip first <style>…</style> from HTML
                    const html_no_style = try html_export.stripFirstStyleBlock(html_inline, alloc);
                    alloc.free(html_inline);

                    // 6) inject <link> before </head>
                    const html_linked = try insertCssLinkBeforeHeadClose(alloc, html_no_style, css_path);
                    alloc.free(html_no_style);

                    // 7) pretty if requested
                    if (pretty) {
                        const pretty_buf = try prettyHtml(alloc, html_linked);
                        alloc.free(html_linked);
                        out_buf = pretty_buf;
                    } else {
                        out_buf = html_linked;
                    }
                } else {
                    // inline mode (default)
                    if (pretty) {
                        const pretty_buf = try prettyHtml(alloc, html_inline);
                        alloc.free(html_inline);
                        out_buf = pretty_buf;
                    } else {
                        out_buf = html_inline;
                    }
                }
            },

            .tex => out_buf = try latex_export.exportAstToLatex(&ast, alloc),
            .dcz => unreachable,
        }
    } else {
        // Import -> DCZ
        switch (in_kind) {
            .md => out_buf = try md_import.importMarkdownToDcz(alloc, input),
            .html => out_buf = try html_import.importHtmlToDcz(alloc, input),
            .tex => out_buf = try latex_import.importLatexToDcz(alloc, input),
            .dcz => unreachable,
        }
    }

    if (out_path) |p| {
        if (detectKindFromPath(p) == null) {
            std.debug.print("convert: unsupported output type: {s}\n", .{p});
            return error.Invalid;
        }
        try writeFile(p, out_buf);
    } else {
        // Print buffer
        std.debug.print("{s}", .{out_buf});
    }
}

test "convert.detectKindFromPath: basic mapping" {
    try std.testing.expect(detectKindFromPath("a.dcz") == .dcz);
    try std.testing.expect(detectKindFromPath("a.MD") == .md);
    try std.testing.expect(detectKindFromPath("a.html") == .html);
    try std.testing.expect(detectKindFromPath("a.HTM") == .html);
    try std.testing.expect(detectKindFromPath("a.tex") == .tex);
    try std.testing.expect(detectKindFromPath("noext") == null);
}

<<<

`enable_wasm.zig`: >>>

const std = @import("std");

/// `docz enable wasm`
pub fn run(_: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    // Expect exactly one arg: "wasm"
    const sub = it.next() orelse {
        std.debug.print("Usage: docz enable wasm\n", .{});
        return error.Invalid;
    };

    if (!std.mem.eql(u8, sub, "wasm")) {
        std.debug.print("Usage: docz enable wasm\n", .{});
        return error.Invalid;
    }

    // Do whatever enabling would mean later; for now just a friendly confirmation.
    std.debug.print("Enabling WASM execution support...\n", .{});
}

<<<

`preview.zig`: >>>

const std = @import("std");
const docz = @import("docz");

pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    // Defaults
    var doc_root: []const u8 = ".";
    var port: u16 = 5173;
    var path: []const u8 = "docs/SPEC.dcz";
    var have_positional = false;

    // Parse: [<path>] [--root|-r DIR] [--port|-p N] [--help|-h]
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--help") or std.mem.eql(u8, arg, "-h")) {
            return printUsage();
        } else if (std.mem.eql(u8, arg, "--root") or std.mem.eql(u8, arg, "-r")) {
            const v = it.next() orelse {
                std.debug.print("preview: --root requires a value\n", .{});
                return error.Invalid;
            };
            doc_root = v;
        } else if (std.mem.eql(u8, arg, "--port") or std.mem.eql(u8, arg, "-p")) {
            const v = it.next() orelse {
                std.debug.print("preview: --port requires a value\n", .{});
                return error.Invalid;
            };
            port = std.fmt.parseUnsigned(u16, v, 10) catch {
                std.debug.print("preview: invalid port: {s}\n", .{v});
                return error.Invalid;
            };
        } else if (arg.len > 0 and arg[0] != '-') {
            if (have_positional) {
                std.debug.print("preview: unknown arg: {s}\n", .{arg});
                return error.Invalid;
            }
            path = arg;
            have_positional = true;
        } else {
            std.debug.print("preview: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    // Start server
    var server = try docz.web_preview.server.PreviewServer.init(alloc, doc_root);
    defer server.deinit();

    // Open the browser (best-effort, non-blocking)
    try openBrowser(alloc, port, path);

    // Block and serve
    try server.listenAndServe(port);
}

fn openBrowser(alloc: std.mem.Allocator, port: u16, path: []const u8) !void {
    const url = try std.fmt.allocPrint(alloc, "http://127.0.0.1:{d}/view?path={s}", .{ port, path });
    defer alloc.free(url);

    const os = @import("builtin").os.tag;
    const argv = switch (os) {
        .windows => &[_][]const u8{ "cmd", "/c", "start", url },
        .macos => &[_][]const u8{ "open", url },
        else => &[_][]const u8{ "xdg-open", url },
    };

    var child = std.process.Child.init(argv, alloc);
    _ = child.spawn() catch {}; // best-effort; ignore failures
}

fn printUsage() void {
    std.debug.print(
        \\Usage: docz preview [<path>] [--root <dir>] [--port <num>]
        \\
        \\Options:
        \\  <path>            .dcz to open initially (default: docs/SPEC.dcz)
        \\  -r, --root <dir>  Document root to serve   (default: ".")
        \\  -p, --port <num>  Port to listen on        (default: 5173)
        \\  -h, --help        Show this help
        \\
        \\Examples:
        \\  docz preview
        \\  docz preview docs/SPEC.dcz
        \\  docz preview --root docs --port 8787 docs/guide.dcz
        \\
    , .{});
}

test "preview.cli compiles and usage prints" {
    // Smoke test: just call printUsage; nothing to assert.
    printUsage();
}

<<<

`run.zig`: >>>

const std = @import("std");
const docz = @import("docz");

const html_export = @import("html_export");
const md_import = @import("md_import");
const html_import = @import("html_import");
const latex_import = @import("latex_import");
const latex_export = @import("latex_export");

const Kind = enum { dcz, md, html, tex };

fn detectKindFromPath(p: []const u8) ?Kind {
    const ext = std.fs.path.extension(p);
    if (ext.len == 0) return null;
    if (std.ascii.eqlIgnoreCase(ext, ".dcz")) return .dcz;
    if (std.ascii.eqlIgnoreCase(ext, ".md")) return .md;
    if (std.ascii.eqlIgnoreCase(ext, ".html") or std.ascii.eqlIgnoreCase(ext, ".htm")) return .html;
    if (std.ascii.eqlIgnoreCase(ext, ".tex")) return .tex;
    return null;
}

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    return try f.readToEndAlloc(alloc, 1 << 26);
}

fn writeFile(path: []const u8, data: []const u8) !void {
    const cwd = std.fs.cwd();
    if (std.fs.path.dirname(path)) |dirpart| {
        try cwd.makePath(dirpart);
    }
    var f = try cwd.createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

fn replaceExt(alloc: std.mem.Allocator, path: []const u8, new_ext_with_dot: []const u8) ![]u8 {
    const dir = std.fs.path.dirname(path);
    const stem = std.fs.path.stem(path);
    if (dir) |d| {
        return try std.fmt.allocPrint(alloc, "{s}{c}{s}{s}", .{ d, std.fs.path.sep, stem, new_ext_with_dot });
    } else {
        return try std.fmt.allocPrint(alloc, "{s}{s}", .{ stem, new_ext_with_dot });
    }
}

fn insertCssLinkBeforeHeadClose(alloc: std.mem.Allocator, html: []const u8, href: []const u8) ![]u8 {
    const needle = "</head>";
    const idx_opt = std.mem.indexOf(u8, html, needle);
    if (idx_opt == null) {
        return try std.fmt.allocPrint(alloc, "<link rel=\"stylesheet\" href=\"{s}\">\n{s}", .{ href, html });
    }
    const idx = idx_opt.?;
    var out = std.ArrayList(u8).init(alloc);
    errdefer out.deinit();

    try out.appendSlice(html[0..idx]);
    try out.appendSlice("<link rel=\"stylesheet\" href=\"");
    try out.appendSlice(href);
    try out.appendSlice("\">\n");
    try out.appendSlice(html[idx..]);

    return out.toOwnedSlice();
}

fn prettyHtml(alloc: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    errdefer out.deinit();

    var indent: usize = 0;
    var i: usize = 0;

    while (i < html.len) {
        const line_start = i;
        while (i < html.len and html[i] != '\n') : (i += 1) {}
        const raw = html[line_start..i];
        if (i < html.len and html[i] == '\n') i += 1;

        const line = std.mem.trim(u8, raw, " \t\r");
        if (line.len == 0) {
            try out.append('\n');
            continue;
        }

        var j: usize = 0;
        while (j < line.len and (line[j] == ' ' or line[j] == '\t' or line[j] == '\r')) : (j += 1) {}
        const starts_with_lt = (j < line.len and line[j] == '<');

        var pre_decr: usize = 0;
        var post_incr: usize = 0;

        if (starts_with_lt) {
            const after_lt = j + 1;
            const is_close = after_lt < line.len and line[after_lt] == '/';
            const is_decl = after_lt < line.len and (line[after_lt] == '!' or line[after_lt] == '?');

            var name_start: usize = after_lt;
            if (is_close) name_start += 1;
            while (name_start < line.len and (line[name_start] == ' ' or line[name_start] == '\t' or line[name_start] == '\r')) : (name_start += 1) {}

            var name_end = name_start;
            while (name_end < line.len) : (name_end += 1) {
                const ch = line[name_end];
                if (ch == '>' or ch == '/' or ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n') break;
            }
            const tag_name = if (name_end > name_start) line[name_start..name_end] else line[name_start..name_start];

            const voidish = std.mem.eql(u8, tag_name, "meta") or
                std.mem.eql(u8, tag_name, "link") or
                std.mem.eql(u8, tag_name, "br") or
                std.mem.eql(u8, tag_name, "img") or
                std.mem.eql(u8, tag_name, "hr");
            const self_closed = line.len >= 2 and line[line.len - 2] == '/' and line[line.len - 1] == '>';
            const has_inline_close = std.mem.indexOf(u8, line, "</") != null;

            if (is_close and !is_decl) {
                if (indent > 0) pre_decr = 1;
            } else if (!is_decl and !self_closed and !voidish and !has_inline_close) {
                post_incr = 1;
            }
        }

        if (pre_decr > 0 and indent >= pre_decr) indent -= pre_decr;

        try out.appendNTimes(' ', indent * 2);
        try out.appendSlice(line);
        try out.append('\n');

        indent += post_incr;
    }

    return out.toOwnedSlice();
}

const CssMode = enum { inline_css, file };

const GenerateOpts = struct {
    css_mode: CssMode = .inline_css,
    pretty: bool = true,
    css_file_name: []const u8 = "docz.css",
};

fn generateOnce(
    alloc: std.mem.Allocator,
    dcz_path: []const u8,
    out_dir: []const u8,
    opts: GenerateOpts,
) !void {
    const input = try readFileAlloc(alloc, dcz_path);
    defer alloc.free(input);

    const kind = detectKindFromPath(dcz_path) orelse return error.Unsupported;
    if (kind != .dcz) return error.ExpectedDcz;

    const tokens = try docz.Tokenizer.tokenize(input, alloc);
    defer {
        docz.Tokenizer.freeTokens(alloc, tokens);
        alloc.free(tokens);
    }
    var ast = try docz.Parser.parse(tokens, alloc);
    defer ast.deinit();

    const html_inline = try html_export.exportHtml(&ast, alloc);
    errdefer alloc.free(html_inline);

    var final_html: []u8 = html_inline;

    if (opts.css_mode == .file) {
        const css_blob = try html_export.collectInlineCss(&ast, alloc);
        defer alloc.free(css_blob);

        const css_out = try std.fs.path.join(alloc, &.{ out_dir, opts.css_file_name });
        defer alloc.free(css_out);
        try writeFile(css_out, css_blob);

        const no_style = try html_export.stripFirstStyleBlock(final_html, alloc);
        alloc.free(final_html);
        final_html = no_style;

        const linked = try insertCssLinkBeforeHeadClose(alloc, final_html, opts.css_file_name);
        alloc.free(final_html);
        final_html = linked;
    }

    if (opts.pretty) {
        const pretty = try prettyHtml(alloc, final_html);
        alloc.free(final_html);
        final_html = pretty;
    }

    const html_out = try std.fs.path.join(alloc, &.{ out_dir, "index.html" });
    defer alloc.free(html_out);

    try writeFile(html_out, final_html);
    alloc.free(final_html);
}

fn fileMTime(path: []const u8) !i128 {
    const st = try std.fs.cwd().statFile(path);
    return st.mtime;
}

fn spawnPreview(alloc: std.mem.Allocator, root_dir: []const u8, port: u16) !std.process.Child {
    const exe_path = try std.fs.selfExePathAlloc(alloc);
    defer alloc.free(exe_path);

    var argv = std.ArrayList([]const u8).init(alloc);
    errdefer argv.deinit();

    try argv.append(exe_path);
    try argv.append("preview");
    try argv.append("--root");
    try argv.append(root_dir);
    try argv.append("--port");
    const port_str = try std.fmt.allocPrint(alloc, "{}", .{port});
    defer alloc.free(port_str);
    try argv.append(port_str);
    // NOTE: do NOT append "index.html" here

    var child = std.process.Child.init(argv.items, alloc);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;
    try child.spawn();

    return child;
}

pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const usage =
        \\Usage: docz run <path.dcz> [--port <num>] [--css inline|file] [--no-pretty]
        \\Notes:
        \\  - Writes to a temp out dir and serves it via `docz preview`
        \\  - Rebuilds on file change. Refresh the browser to see updates.
        \\
    ;

    const dcz_path = it.next() orelse {
        std.debug.print("{s}", .{usage});
        return error.Invalid;
    };

    var port: u16 = 5173;
    var css_mode: CssMode = .inline_css;
    var pretty: bool = true;

    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--port")) {
            const v = it.next() orelse {
                std.debug.print("run: --port requires a value\n", .{});
                return error.Invalid;
            };
            port = std.fmt.parseInt(u16, v, 10) catch {
                std.debug.print("run: invalid port: {s}\n", .{v});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--css")) {
            const v = it.next() orelse {
                std.debug.print("run: --css requires a value: inline|file\n", .{});
                return error.Invalid;
            };
            if (std.mem.eql(u8, v, "inline")) css_mode = .inline_css else if (std.mem.eql(u8, v, "file")) css_mode = .file else {
                std.debug.print("run: --css must be 'inline' or 'file' (got '{s}')\n", .{v});
                return error.Invalid;
            }
        } else if (std.mem.eql(u8, arg, "--no-pretty")) {
            pretty = false;
        } else {
            std.debug.print("run: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    const tmp_root = try std.fs.path.join(alloc, &.{ ".zig-cache", "docz-run" });
    defer alloc.free(tmp_root);
    try std.fs.cwd().makePath(tmp_root);

    try generateOnce(alloc, dcz_path, tmp_root, .{ .css_mode = css_mode, .pretty = pretty });

    var preview = try spawnPreview(alloc, tmp_root, port);
    defer {
        _ = preview.kill() catch {};
        _ = preview.wait() catch {};
    }

    std.debug.print("Serving on http://localhost:{d}  (dir: {s})\n", .{ port, tmp_root });

    var last = try fileMTime(dcz_path);
    while (true) {
        std.Thread.sleep(250 * std.time.ns_per_ms);

        const now = fileMTime(dcz_path) catch continue;
        if (now != last) {
            last = now;
            generateOnce(alloc, dcz_path, tmp_root, .{ .css_mode = css_mode, .pretty = pretty }) catch |e| {
                std.debug.print("run: rebuild failed: {s}\n", .{@errorName(e)});
            };
        }
    }
}

<<<

`spec-inline.html`: >>>

<!DOCTYPE html>
<html>
  <head>
    <meta name="status" content="DRAFT">
    <meta name="updated" content="2025‑08‑10">
    <meta name="version" content="0.1.0">
    <title>Docz Mini‑Spec v0</title>
    <style>
      body { font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
      h1,h2,h3 { line-height: 1.25; margin: 1.2em 0 .4em }
      p { margin: .8em 0 }
      pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 6px; overflow:auto }
      .math { font-style: italic }

    </style>
  </head>
  <body>
    <h1>Docz Mini‑Spec v0</h1>
    <p>This is the **single source of truth** for the `.dcz` format for Milestone M0→M1.</p>
    <p>Everything in core (tokenizer, parser, AST, converters, preview, and plugins) MUST conform to this spec.</p>
    <p>Spec changes require tests and MUST be documented here before merge.</p>
    <h2>Scope</h2>
    <p>This spec defines:</p>
    <p>- Lexical rules (tokens, escaping).</p>
    <p>- Block structure (directives, attributes, nesting).</p>
    <p>- Canonical AST node set and required attributes.</p>
    <p>- Determinism requirements for round‑trips.</p>
    <p>- Validation & sanitization rules (MUST/SHOULD).</p>
    <p>- Diagnostics shape (error categories + spans).</p>
    <p>It also inventories **planned directives**. Unimplemented directives are marked *PLANNED*; validators SHOULD accept them as unknown-by-core but MAY allow via plugins.</p>
    <h2>Lexical Rules</h2>
    <p>Whitespace is UTF‑8. Lines end with `\n`. The tokenizer recognizes:</p>
    <p>- `@directive` introducer at start of a directive.</p>
    <p>- Parameter list: `(@-separated attributes)` — see “Attributes”.</p>
    <p>- `@end` closes a directive block. **Directives MUST be closed** (no implicit closures).</p>
    <p>- Plain paragraphs are sequences of non-directive lines separated by blank lines.</p>
    <p>- Code and Math are fenced blocks opened by `@code(...)` / `@math(...)` and closed by `@end`.</p>
    <p>- Inline escaping inside blocks uses `</p>
    <p>@`</p>
    <p>to represent a literal `@`.</p>
    <p>- Backslash escapes in text are **NOT** interpreted by Docz (left for exporters), except where noted by converters.</p>
    <h3>Attributes</h3>
    <p>Attributes are comma‑separated key/value pairs inside `()`:</p>
    <pre><code>key="string", key2=123, flag=true
    </code></pre>
    <p>Rules:</p>
    <p>- Keys: `[a‑zA‑Z_][a‑zA‑Z0‑9_\-]*`</p>
    <p>- Values: unquoted numbers/booleans OR quoted strings (`"..."`) with `\"` for quotes, `\\` for backslash.</p>
    <p>- Ordering is **not significant**; exporters MAY reorder deterministically (lexicographic by key).</p>
    <h2>Blocks & Directives</h2>
    <p>A directive has this form:</p>
    <pre><code>@name(k1="v1", k2=2, flag=true)
      ...block content...
    </code></pre>
    <h3>Core Directives (Implemented)</h3>
    <p>These MUST be supported by core and round‑trip converters.</p>
    <pre><code>@meta(...):     Top‑level only. Key/values become document metadata (title, author, version, etc.). No content.
      @heading(...):  Attributes: level=1..6 (required). Content is inline text on same line after closing ')'. No nested blocks.
      @code(...):     Attributes: language="" (optional), execute=false (reserved). Content: raw preformatted until @end.
      @math(...):     Attributes: none (for v0). Content: raw math until @end.
      @image(...):    Attributes: src (required), width/height (optional strings). No content. (Media)
      @import(...):   Attributes: href (required), type? (e.g., stylesheet/script). No content.
      @style(...):    Attributes: freeform. Content is raw (ignored by strict HTML/TeX exporters in v0).
    </code></pre>
    <h3>Extended Directives (PLANNED)</h3>
    <p>Core validator MUST recognize the spelling and basic shape; deeper semantics may be delegated to plugins.</p>
    <p>Exporters MAY no‑op until implemented.</p>
    <pre><code>@style-def(...): Define named style tokens; content contains style rules. (PLANNED)
      @data(...):      Attributes: format=("json"|"yaml"|"csv"|...). Content is raw data. (PLANNED)
      @plot(...):      Attributes: type, x=, y=, etc.; or content as data block. (PLANNED)
      @video(...):     Attributes: src, controls=true|false, poster? (PLANNED)
      @audio(...):     Attributes: src, controls=true|false (PLANNED)
      @pdf(...):       Attributes: src, page? (PLANNED)
      @embed(...):     Attributes: type, source, width?, height? (PLANNED)
      @graph(...):     Attributes: type ("imports"|"links"|...); content lists nodes/edges. (PLANNED)
      @logic(...):     Attributes: none; content is script to be executed in sandbox (WASM/JS). (PLANNED)
    </code></pre>
    <h2>Structural Rules</h2>
    <p>- Document root is an implicit `Document` node containing a linear list of blocks.</p>
    <p>- `@meta` nodes MUST appear before any body nodes (order preserved). Multiple `@meta` allowed; last write wins per key.</p>
    <p>- `@heading(level=n)` is a block header with inline text on the same line: `@heading(level=2) My Title @end`.</p>
    <p>- `@code` / `@math` / `@data` are multi‑line blocks terminated by `@end`. Content is NOT parsed for nested directives.</p>
    <p>- `@image`, `@import` are leaf nodes (no content block). They MAY appear anywhere in body.</p>
    <p>- Unknown directives: core MUST retain them as `Unknown(name, attributes, raw_block?)` for round‑trip safety.</p>
    <p>- Nesting: v0 forbids nested directives (everything is flat). Future versions MAY allow limited nesting via plugins.</p>
    <h2>Canonical AST (v0)</h2>
    <p>Core nodes and required attributes:</p>
    <pre><code>Document:  children:[Node]
      Meta:      attrs:{string→string} (title, author, version, ...); no content
      Heading:   attrs:{level:string}; content:string (inline text)
      Content:   content:string (paragraph text)
      CodeBlock: attrs:{language?:string, execute?:bool}; content:string (verbatim)
      Math:      content:string (verbatim)
      Media:     attrs:{src:string, kind:"image"|"video"|"audio"|"pdf", width?:string, height?:string}; no content for v0
      Import:    attrs:{href:string, type?:"stylesheet"|"script"}; no content
      Style:     attrs:{...}; content:string (opaque)
      Unknown:   attrs:{...}; name:string; content?:string
    </code></pre>
    <p>Mapping from directives to AST:</p>
    <pre><code>@meta         → Meta
      @heading      → Heading
      (plain text)  → Content (paragraphs; blank-line separated)
      @code         → CodeBlock
      @math         → Math
      @image        → Media(kind="image")
      @video        → Media(kind="video")     (PLANNED → Unknown until implemented)
      @audio        → Media(kind="audio")     (PLANNED → Unknown until implemented)
      @pdf          → Media(kind="pdf")       (PLANNED → Unknown until implemented)
      @import       → Import
      @style        → Style
      (others)      → Unknown(name=..., attrs=..., content?)
    </code></pre>
    <h2>Determinism & Round‑Trip</h2>
    <p>- Converters MUST be deterministic given the same AST and options.</p>
    <p>- Whitespace policy:</p>
    <p>- Paragraphs normalize trailing whitespace; internal spacing preserved.</p>
    <p>- Code/Math are preserved verbatim except trimming a trailing `\n\n` may occur during export; importers MUST normalize back.</p>
    <p>- Attribute order in serialized forms MUST be stable (lexicographic by key).</p>
    <p>- Unknown nodes MUST be preserved across `dcz → X → dcz` (opaque pass‑through).</p>
    <h2>Validation Rules (core/validate.zig)</h2>
    <p>The validator MUST enforce:</p>
    <pre><code>[GEN]
      - All directives are closed by @end when required.
      - No nesting in v0 (report error if a directive appears inside a block content).
      - Attributes: keys unique per node; values match expected types.

      [META]
      - Only at top of document until first non-Meta node.
      - Keys: any string; recommended: title, author, version, keywords, updated.

      [HEADING]
      - level ∈ {1..6}; content non-empty.
      - No trailing spaces inside level attribute value.

      [CODE]
      - language: string (may be empty); execute: boolean (default false).
      - Content may be empty (allowed).

      [MATH]
      - Content may be empty (validator MAY warn).

      [MEDIA]
      - src: non-empty string; width/height if present must be strings (pass-through).

      [IMPORT]
      - href: non-empty. type optional: "stylesheet"|"script".

      [STYLE]
      - Opaque: always valid; warn if empty.
    </code></pre>
    <p>Failure categories:</p>
    <pre><code>E100: Unexpected EOF (missing @end)
      E110: Unknown directive (if strict mode enabled)
      E120: Disallowed nesting in v0
      E130: Duplicate attribute key
      E140: Invalid attribute type/value
      E150: Meta after body content
      E160: Missing required attribute
      W200: Empty content (Math/Style), allowed but questionable
    </code></pre>
    <h2>Sanitization Rules (core/sanitize.zig)</h2>
    <p>Sanitizer SHOULD:</p>
    <pre><code>- Trim trailing whitespace in paragraph lines.
      - Normalize consecutive blank lines to a single blank line.
      - Canonicalize attribute ordering (lexicographic by key).
      - Clamp heading level into [1,6].
      - Remove entirely empty nodes (except CodeBlock — keep empty code).
    </code></pre>
    <h2>Diagnostics Shape</h2>
    <p>CLI MUST be able to print human‑readable and JSON forms. JSON schema (minimal v0):</p>
    <pre><code>{
      "file": "path/to/doc.dcz",
      "errors": [
      {
      "code": "E160",
      "message": "Missing required attribute 'level'",
      "span": { "line": 12, "col": 1, "endLine": 12, "endCol": 20 },
      "node": "Heading"
      }
      ],
      "warnings": [
      {
      "code": "W200",
      "message": "Empty math block",
      "span": { "line": 33, "col": 1, "endLine": 35, "endCol": 5 },
      "node": "Math"
      }
      ]
      }
    </code></pre>
    <h2>Compliance Checklist (for PRs)</h2>
    <p>- [ ] SPEC.dcz updated (this file) with any format/behavior change.</p>
    <p>- [ ] Unit tests for tokenizer/parser/validators updated.</p>
    <p>- [ ] Snapshot round‑trip tests updated for md/html/tex.</p>
    <p>- [ ] Deterministic output verified on all three OSes in CI.</p>
    <p>- [ ] Diagnostics include accurate spans and codes.</p>
    <h2>Appendix A: Mini‑Grammar (Informal)</h2>
    <pre><code>Document    := (Meta | Block | Paragraph)*
      Meta        := "@meta(" AttrList? ")" WS "@end" NL
      Heading     := "@heading(" "level=" Int ")" WS InlineText WS "@end" NL
      CodeBlock   := "@code(" AttrList? ")" NL CodeBody "@end" NL
      Math        := "@math(" AttrList? ")" NL MathBody "@end" NL
      Image       := "@image(" AttrList ")" WS "@end" NL
      Import      := "@import(" AttrList ")" WS "@end" NL
      Style       := "@style(" AttrList? ")" NL StyleBody "@end" NL
      Unknown     := "@" Ident "(" AttrList? ")" (NL Body "@end" NL | WS "@end" NL)
      Paragraph   := TextLine+ NL

      AttrList    := Attr ("," WS Attr)*
      Attr        := Ident "=" (Number | Bool | String)
      Ident       := [A-Za-z_][A-Za-z0-9_\-]*
      Number      := [0-9]+
      Bool        := "true" | "false"
      String      := "\"" ( [^"\\] | "\\\"" | "\\\\" )* "\""
      InlineText  := (not NL, may contain spaces, supports "@@" for literal "@")
    </code></pre>
    <h2>Appendix B: Directive Inventory</h2>
    <p>This table tracks implementation status for core + planned directives (update as features land).</p>
    <pre><code>name        | status     | ast      | exporter/html | exporter/md | exporter/tex
      ------------+------------+----------+---------------+-------------+--------------
      meta        | CORE       | Meta     | head/meta     | front-matter| \title/\author
      heading     | CORE       | Heading  | <h1..h6>      | #..######    | \sec/\sub..
      code        | CORE       | CodeBlock| <pre><code>   | ``` ```      | verbatim
      math        | CORE       | Math     | <div class=..>| $$/$$        | equation
      image       | CORE       | Media    | <img>         | ![]()        | \includegraphics
      import      | CORE       | Import   | <link>        | (no-op)      | (no-op)
      style       | CORE       | Style    | (ignored v0)  | (ignored v0) | (ignored v0)
      style-def   | PLANNED    | Style    | (tbd)         | (tbd)        | (tbd)
      data        | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
      plot        | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
      video       | PLANNED    | Media    | <video>       | (link)       | (no-op)
      audio       | PLANNED    | Media    | <audio>       | (link)       | (no-op)
      pdf         | PLANNED    | Media    | (embed)       | (link)       | (no-op)
      embed       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
      graph       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
      logic       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
    </code></pre>
    <h2>Versioning</h2>
    <p>- This file’s `version` field tracks spec compatibility.</p>
    <p>- Breaking changes bump MINOR while in v0 (0.x). Once stable, follow SemVer (MAJOR.MINOR.PATCH).</p>
  </body>
</html>

<<<

`all-directives.dcz`: >>>

@meta(title="All Directives Example", version="1.0", author="Docz") @end

@heading(level=1) Docz All Directives Demo @end

@heading(level=2) Metadata & Heading @end
This section shows meta + heading usage.

@heading(level=2) Style System @end
@style-def()
heading-level-1: font-size=36px, font-weight=bold, color=#000
body-text: font-family="Inter", line-height=1.6
@end

@style(color=blue, font-size=18px)
This text is styled inline.
@end

@heading(level=2) Data Directive @end
@data(format="json")
{
    "name": "Docz",
    "version": "1.0"
}
@end

@heading(level=2) Code Block @end
@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end

@heading(level=2) Math & Plot @end
@math()
E = mc^2
@end

@plot(type="line")
x: [1, 2, 3, 4]
y: [1, 4, 9, 16]
@end

@heading(level=2) Media @end
@image(src="img/logo.png", width="200px") @end
@video(src="demo.mp4", controls=true) @end
@audio(src="sound.mp3", controls=true) @end
@pdf(src="paper.pdf") @end

@heading(level=2) Embed & Logic @end
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="800px") @end

@logic()
function hello() {
    alert("Hello from Docz!");
}
@end

@heading(level=2) Graph & Query @end
@graph(type="imports")
nodes: [main.dcz, intro.dcz]
edges: [main.dcz -> intro.dcz]
@end

ZUQL Example:
@code(language="sql")
SELECT docs WHERE tag="math";
@end
<<<

`example.dcz`: >>>

@meta(title="Docz Guide", author="Team") @end
@heading(level=2) Welcome @end
@code(language="zig")
const x = 42;
@end
@math()
E = mc^2
@end
@image(src="img/logo.png") @end

<<<

`minimal.dcz`: >>>

@meta(title="Minimal Doc", author="Docz Team") @end
@heading(level=1) Hello Docz @end
Welcome to the minimal example.
<<<

`minimal.dcz.html`: >>>

<!DOCTYPE html>
<html>
<head>
<meta name="author" content="Docz Team">
<title>Minimal Doc</title>
</head>
<body>
<!-- Unhandled node: Meta -->
<h1></h1>
<p>Welcome to the minimal example.</p>
</body>
</html>

<<<

`sample.dcz`: >>>

@heading(level=2) Welcome to Docz @end
Hello World
<<<

`youtube.md`: >>>

https://www.youtube.com/watch?v=8tKZTQI_h44
<<<

`DEPENDENCIES.md`: >>>

# Docz Dependency Management Guide

This guide explains how **Docz** manages dependencies for reproducibility, modularity, and security using Zig-inspired manifests. It combines concepts from both dependency structure and ecosystem philosophy.

---

## 1. Why Dependency Management Matters

- **Reproducibility**: Same build everywhere.
- **Security**: Verified hashes, no arbitrary code.
- **Modularity**: Core stays minimal; features are plugin-driven.

Without proper dependency management:
- Builds become fragile.
- Security risks increase.
- Teams waste time troubleshooting environments.

Docz solves this by:
- Using `docz.zig.zon` as a manifest.
- Pinning versions in `docz.zig.lock`.
- Enforcing SHA-256 hash verification.

---

## 2. Core Philosophy

- **Zero unnecessary dependencies**:
    - Core = Pure Zig.
    - Plugins & themes = Optional.
- Predictable builds, minimal attack surface, maximum performance.

---

## 3. Dependency Layers

| Layer        | Purpose                                  |
|------------- |------------------------------------------|
| **Core**     | Parser, AST, Renderer, CLI.             |
| **Plugins**  | Adds features like Math, Plots, Graphs. |
| **Themes**   | Visual styles (academic, minimal, dark).|
| **Exporters**| PDF, ePub, HTML outputs.                |

Quartz (UI) is **not a dependency** of Docz. It uses Docz as a library or CLI.

---

## 4. Core Dependencies

- **Language**: Zig (≥ 0.13.0 recommended latest).
- **Core Components**:
    - `parser`: Converts `.dcz` → AST.
    - `renderer`: HTML, PDF.
    - `cli`: Command-line interface.
    - `wasm-core`: Secure execution of embedded Zig code.

Install Zig:
```bash
curl -fsSL https://ziglang.org/builds/zig-linux-x86_64-latest.tar.xz | tar -xJ
zig version
```

Build Docz:
```bash
zig build
zig build test
```

---

## 5. Manifest: `docz.zig.zon`

Defines project metadata, plugins, and themes:

```zon
.{
    .name = "docz-project",
    .version = "0.1.0",

    .plugins = .{
        .plugin-zeno = .{
            .url = "https://github.com/zigadel/plugin-zeno/archive/main.tar.gz",
            .hash = "1220abcd1234ef5678abcd1234ef5678"
        }
    },

    .themes = .{
        .academic = .{
            .url = "https://github.com/zigadel/docz-themes/archive/main.tar.gz",
            .hash = "1220efgh5678ijklmnop"
        }
    }
}
```

---

## 6. Lockfile: `docz.zig.lock`

Ensures deterministic builds by pinning exact versions:
```zon
.{
    .plugins = .{
        .plugin-zeno = .{
            .version = "1.0.3",
            .hash = "1220abcd1234ef5678abcd1234ef5678"
        }
    }
}
```

Always commit the lockfile to version control.

---

## 7. CLI Commands for Dependencies

### Install all from manifest:
```bash
qz install
```

### Add a plugin:
```bash
qz add plugin-zeno --url https://github.com/zigadel/plugin-zeno/archive/main.tar.gz --hash 1220abcd1234
```

### Remove a plugin:
```bash
qz remove plugin-zeno
```

### Update all:
```bash
qz update
```

---

## 8. Directory Structure

```
project-root/
    docz.zig.zon        # Manifest file
    docz.zig.lock       # Lockfile
    .docz-packages/     # Installed plugins & themes
```

---

## 9. Example: Multi-Plugin Setup

```zon
.{
    .name = "enterprise-docz",
    .version = "1.2.0",

    .plugins = .{
        .plugin-zeno = .{ .url = "https://github.com/zigadel/plugin-zeno", .hash = "1220abcd1234" },
        .plugin-qdraw = .{ .url = "https://github.com/zigadel/plugin-qdraw", .hash = "1220efgh5678" },
        .plugin-python = .{ .url = "https://github.com/zigadel/plugin-python", .hash = "1220ijkl9012" }
    }
}
```

---

## 10. Themes Management

Themes define UI without altering content.

Example:
```bash
qz add theme-academic --url https://github.com/zigadel/docz-themes/archive/main.tar.gz --hash 1220mnop
```

Import theme:
```text
@import("themes/academic.dczstyle")
```

---

## 11. Best Practices

- Commit `docz.zig.lock`.
- Verify hashes for all dependencies.
- Avoid using `latest` tags.
- Regularly audit installed plugins:
```bash
qz audit
```

---

## 12. Troubleshooting

- **Install fails** → Check internet and hashes.
- **Hash mismatch** → Recompute SHA-256 and update manifest.
- **Lockfile out of sync** → `qz sync`.

---

## 13. Security Checklist

- Validate all hashes.
- Use only trusted plugin sources.
- Review plugin code.

---

## 14. Workflow Diagram

```text
.dcz Files
     ↓
docz.zig.zon (Manifest)
     ↓ qz install
.docz-packages/ (Plugins)
     ↓
Quartz Runtime → WASM Execution
```

---

## 15. FAQs

**Q: Can I host plugins privately?**
A: Yes. Use HTTPS or Git URLs in manifest.

**Q: Does Docz support semantic versioning?**
A: Yes. Pin versions explicitly.

**Q: Can I use plugins without hashes?**
A: No. Hash verification is mandatory for security.

---

## 16. Related Files

- `PLUGIN_GUIDE.md`: Writing plugins.
- `DEVELOPMENT.md`: Build system overview.

<<<

`DEVELOPMENT.md`: >>>

# DEVELOPMENT.md – Engineering Guide for Docz

This document is a **technical reference for engineers contributing to Docz**.  
It focuses on the architecture, build system, debugging practices, and integration details for the **Zig-based core**, WASM runtime, and Quartz frontend.

For project planning and workflows, see:
- [ROADMAP.md](./ROADMAP.md) for strategic phases.
- [WORKFLOW.md](./WORKFLOW.md) for branching, PR, and CI/CD rules.

---

## 1. Purpose of This Document
Unlike ROADMAP or WORKFLOW, this file answers:
- **How the system is built** (architecture and components).
- **How to develop, debug, and optimize** Docz core.
- **Where to integrate** plugins, WASM modules, and UI layers.

---

## 2. High-Level Architecture

```
.dcz File
    ↓
Parser (Zig)
    ↓
AST (Intermediate Representation)
    ↓
Renderer
    ↓
Quartz UI (SvelteKit)
    ↓
Output: HTML / PDF / WASM-enhanced content
```

Key components:
- **Core Parser & CLI**: Written in Zig for deterministic builds.
- **Runtime Engine**: Executes user Zig code in a WASM sandbox.
- **UI Renderer**: Implemented in Quartz (SvelteKit + TypeScript).
- **Plugin Layer**: Extends functionality without bloating core.

---

## 3. Core Components in Detail

### 3.1 Parser
- **Goal**: Convert `.dcz` markup into an **AST**.
- Features:
    - Tokenizer for directives: `@meta`, `@heading`, `@code`, `@style`.
    - Support for **block directives** (e.g., `@code ... @end`).
- Example AST Node in Zig:
```zig
const NodeType = enum { Meta, Heading, CodeBlock, Style, Import, Math };

const ASTNode = struct {
    node_type: NodeType,
    attributes: std.StringHashMap([]const u8),
    content: []const u8,
    children: []ASTNode,
};
```

**Validation Rules**:
- Block directives must close with `@end`.
- Strict attribute validation for `@meta` and `@import`.

---

### 3.2 CLI (`qz`)
The CLI acts as the developer-facing tool:
- Commands:
    - `qz new <file>` → Create `.dcz` template.
    - `qz build <file>` → Convert `.dcz` → HTML.
    - `qz preview <file>` → Serve locally with live reload.
    - `qz install <plugin>` → Install plugins.

**CLI Skeleton in Zig**:
```zig
pub fn main() !void {
    const args = try std.process.argsAlloc(std.heap.page_allocator);
    if (args.len < 2) {
        std.debug.print("Usage: qz <command>\n", .{});
        return;
    }
    // Dispatch commands...
}
```

---

### 3.3 WASM Execution Engine
- Compiles Zig code to **`wasm32-wasi`**:
```bash
zig build-lib src/runtime.zig -target wasm32-wasi --name runtime
```
- Security constraints:
    - No network or unrestricted FS access.
    - Memory limits enforced by WASM runtime.
- Future: Add **sandbox isolation layer** for plugins.

---

### 3.4 Quartz Integration (UI)
- Quartz is a **SvelteKit frontend**:
    - Renders AST → HTML dynamically.
    - Provides **hot reload** for `.dcz` files.
    - Executes WASM modules securely in-browser.
- Output format for renderer (JSON contract):
```json
{ "type": "heading", "level": 2, "content": "Introduction" }
```

---

## 4. Plugin System

- **Philosophy**: Keep core minimal; let plugins handle advanced features.
- Plugins are **Zig modules** implementing the `Plugin` struct:
```zig
const Plugin = struct {
    name: []const u8,
    register: fn () void,
};
```
- Manifest (`plugin.zon`) defines metadata and hooks.
- Key hooks: `onRegister`, `onParse`, `onRender`.

Example Plugin Manifest:
```zon
.{
    .name = "plugin-zeno",
    .version = "1.0.0",
    .hooks = .{
        "onRender" = true
    }
}
```

---

## 5. Build System & Commands

### Build Core:
```bash
zig build
```

### Run Tests:
```bash
zig build test
```

### WASM Build:
```bash
zig build-lib src/runtime.zig -target wasm32-wasi --name runtime
```

### UI (Quartz):
```bash
npm install
npm run dev
```

---

## 6. Debugging & Development Tips

### Debug Parser
```bash
zig build run -- parse examples/sample.dcz
```
Enable Zig debug logging:
```zig
std.debug.print("Token: {s}\n", .{token});
```

### Debug WASM
- Use `wasmtime` for local execution:
```bash
wasmtime runtime.wasm
```

---

## 7. Performance Guidelines
- **Goal**: Parse 10,000-line `.dcz` <100ms.
- Use **arena allocators** for AST construction.
- Avoid unnecessary copies of content strings.

---

## 8. Security Considerations
- Validate all plugin manifests before loading.
- Enforce hash verification for dependencies.
- Sandbox WASM execution fully by Phase 4.

---

## 9. Testing Standards
- Tests live **inline in Zig files**:
```zig
test "parse heading" {
    const result = try parseDocz("@heading(level=2) Title @end");
    try expectEqual(result[0].node_type, NodeType.Heading);
}
```
- 100% coverage target for parser and CLI.

Run all tests:
```bash
zig build test
```

---

## 10. Integration Points
- **Quartz UI** consumes **AST JSON** for rendering.
- **Plugins** extend via hooks.
- **CLI** orchestrates parse → render → export pipeline.

---

## 11. Related Docs
- [ROADMAP.md](./ROADMAP.md) – Strategic direction.
- [WORKFLOW.md](./WORKFLOW.md) – CI/CD & process.
- [PLUGIN_GUIDE.md](./PLUGIN_GUIDE.md) – Plugin development.
- [DEPENDENCIES.md](./DEPENDENCIES.md) – Dependency rules.

<<<

`GAMEPLAN.md`: >>>

# GAMEPLAN.md – The Tactical Execution Blueprint for Docz

This document is the **bridge between strategy (ROADMAP) and execution (WORKFLOW)**.  
If ROADMAP is **why** and **what**, GAMEPLAN is **how**. It defines **immediate priorities, phase-based objectives, tactical workflows, and daily actionable steps** to build Docz into the universal standard for structured documentation.

---

## 1. Mission Statement

Docz is not just software. It is **infrastructure for structured knowledge**.  
This game plan ensures that:
- Every feature aligns with the **core principles**: determinism, security, modularity, and timelessness.
- Execution is **systematic**, reducing technical debt and enforcing architectural integrity.
- Every contributor can onboard quickly and **know what to do next**.

---

## 2. Operating Principles

Before touching a line of code, understand these:
- **Security by Default:** All contributions assume adversarial conditions. Sandbox everything.
- **Determinism First:** If it isn’t reproducible, it isn’t acceptable.
- **Minimal Core, Infinite Extension:** Keep the core lean; push complexity into plugins.
- **Automation Everywhere:** Every process must be enforceable by CI/CD.
- **Fail Closed:** All error states default to safe behavior.

---

## 3. High-Level Structure of Work

Phases map to **architectural layers**:
- **Phase 1:** Core engine foundation (parser, AST, renderer, CLI).
- **Phase 2:** Plugin & theme ecosystem (modularity).
- **Phase 3:** Developer experience (editor tooling, previews).
- **Phase 4:** Advanced capabilities (sandboxing, marketplace, integrations).

**Execution Model:**  
- **Each phase closes security gaps before introducing complexity.**
- **Every feature merged must include inline tests, docs, and CI compliance.**

---

## 4. Current Repository Structure

```sh
docz/
    core/               # Parser, renderer, CLI
    plugins/            # Official plugins
    examples/           # Example .dcz files
    vscode-extension/   # VSCode tooling
    web-preview/        # Browser live preview
    docs/               # Internal execution docs
    .github/            # Workflows, PR templates
```

Future additions:
- `sandbox/` → WASM execution layer.
- `themes/` → Core theme packages.
- `marketplace/` → Plugin registry backend.

---

## 5. Immediate Tactical Priorities (Next 30 Days)

### ✅ Priority 1: Core Parser & AST
- Implement **full `.dcz` tokenization**.
- Build **AST node system with validation hooks**.
- Define **directive spec** in `docs/STYLE_GUIDE.md` and lock it.

### ✅ Priority 2: Renderer → HTML
- Implement baseline renderer:
    - AST → HTML mapping.
    - Support for headings, paragraphs, images, code blocks.
- Add **theme hook layer** for Phase 2 extensibility.

### ✅ Priority 3: CLI Commands
- `docz build` → Compile `.dcz` to HTML.
- `docz preview` → Local static server with hot reload.
- Implement structured error messages for invalid syntax.

### ✅ Priority 4: Inline Testing Framework
- Enforce **tests per module** with `zig build test`.
- Coverage target: **100% for parser and CLI**.

---

## 6. Phase-by-Phase Tactical Breakdown

### **Phase 1: Core Foundation (Parser + Renderer + CLI)**
**Goal:** A standalone engine that can parse `.dcz` → HTML deterministically.

#### Tasks:
- [ ] **Tokenizer** for all directives.
- [ ] **AST Node Struct** with type enums.
- [ ] Parser validation for:
    - Missing `@end` blocks.
    - Invalid key-value pairs.
- [ ] Renderer:
    - Base HTML output.
    - Add hooks for style injection.
- [ ] CLI:
    - Commands: `build`, `preview`.
    - Error reporting with contextual hints.
- [ ] CI:
    - Lint `.dcz` samples.
    - Build binaries for Linux/macOS/Windows.
- [ ] Write sample `.dcz` files for regression testing.

#### Deliverable:
- `zig build` produces **deterministic binary**.
- HTML output matches test snapshots.

---

### **Phase 2: Plugin & Theme Ecosystem**
**Goal:** Enable modular extensibility without bloating core.

#### Tasks:
- [ ] Define **plugin manifest schema** (`plugin.zon`).
- [ ] Implement plugin loader with:
    - Manifest validation.
    - Hook registration: `onRegister`, `onParse`, `onRender`.
- [ ] Create **core plugin examples**:
    - `plugin-math`: Render LaTeX.
    - `plugin-zeno`: Simulation embedding.
- [ ] Theme system:
    - Load `.dczstyle` files.
    - Merge theme config with renderer pipeline.
- [ ] Security:
    - Enforce **hash verification** for plugins.
    - Prepare for WASM sandbox enforcement.

#### Deliverable:
- `docz install plugin-name` functional.
- Theme import supported in `.dcz`.

---

### **Phase 3: Developer Experience**
**Goal:** Make Docz frictionless for daily use.

#### Tasks:
- [ ] VSCode Extension:
    - Syntax highlighting.
    - Autocomplete for directives.
- [ ] Web Preview:
    - Browser live reload.
    - Full AST inspection panel.
- [ ] Optional GUI for Docz:
    - Minimalist, cross-platform viewer.

---

### **Phase 4: Advanced Capabilities**
**Goal:** Harden Docz for production-grade usage.

#### Tasks:
- [ ] WASM Sandbox:
    - Secure execution for `@code` blocks.
- [ ] Plugin Marketplace:
    - Registry with signed manifests.
- [ ] Quartz API Integration:
    - Output Docz → Quartz seamlessly.

---

## 7. Security Workflows by Phase

- **Phase 1:** Validate `.dcz` syntax, lock directive spec.
- **Phase 2:** Hash verification for plugins.
- **Phase 3:** WASM sandbox prototype.
- **Phase 4:** Full sandbox enforcement + plugin marketplace verification.

---

## 8. Daily Development Workflow
1. Pull latest `dev` branch.
2. Create feature branch:
```bash
git checkout -b feature/<task-name>
```
3. Implement feature with **inline tests**.
4. Run:
```bash
zig build
zig build test
```
5. Commit with **Conventional Commits** format.
6. Push & open PR → Await review + CI green check.

---

## 9. CI/CD Enforcement
- Lint: `zig fmt`, `.dcz` lint.
- Tests: Inline Zig tests mandatory.
- Security: Hash check for dependencies.
- Release flow:
    - Tag `vX.Y.Z` → triggers artifact build and checksum generation.

---

## 10. Contributor Action Map (Who Does What)
- **Core Maintainers:** Parser, renderer, CLI.
- **Plugin Developers:** Create isolated, hash-verified extensions.
- **Security Auditors:** Validate sandbox + plugin registry integrity.
- **DX Team:** VSCode extension, preview UI, docs.

---

## 11. Next Steps for All Contributors
- Read: [ROADMAP.md](./ROADMAP.md), [STYLE_GUIDE.md](./STYLE_GUIDE.md), [WORKFLOW.md](./WORKFLOW.md).
- Clone, build, and run sample `.dcz` files.
- Start with **Phase 1 tasks** → Parser completeness is top priority.

---

### Related Docs
- [CONTRIBUTING.md](../.github/CONTRIBUTING.md)
- [ROADMAP.md](./ROADMAP.md)
- [WORKFLOW.md](./WORKFLOW.md)
- [STYLE_GUIDE.md](./STYLE_GUIDE.md)
- [PLUGIN_GUIDE.md](./PLUGIN_GUIDE.md)

---

**Last Updated:** {Insert Date}
<<<

`PLUGIN_GUIDE.md`: >>>

# Docz Plugin Development Guide

Docz supports a **core + plugin architecture**, allowing developers to extend functionality without bloating the core. Plugins enable new directives, renderers, exporters, logic, and interactivity while maintaining security and modularity.

---

## 1. Why Plugins Matter

- **Modularity** → Keep the core lightweight.
- **Flexibility** → Add features on demand.
- **Security** → Isolate and sandbox risky operations.
- **Community Ecosystem** → Share, discover, and reuse plugins globally.

Examples of plugins:
- `plugin-zeno` → Real-time physics simulation.
- `plugin-qdraw` → Interactive diagramming.
- `plugin-python` → Execute Python code in a sandbox.
- `plugin-audio` → Execute Audio code.

---

## 2. Plugin Categories

| Category     | Purpose                                                                 |
|------------- |-------------------------------------------------------------------------|
| **Directives** | Introduce new syntax elements (e.g., `@diagram`, `@qdraw`).           |
| **Renderers**  | Define how directives render (HTML, Canvas, WebGL).                   |
| **Exporters**  | Output formats like PDF, EPUB, or Static HTML.                        |
| **Logic**      | Add interactivity or event-driven behavior.                           |
| **Themes**     | Define visual design language.                                        |

---

## 3. Plugin Anatomy

A plugin typically includes:
- **Manifest**: Metadata and directive registration.
- **Core Logic (Zig)**: Implements functionality and hooks.
- **Optional Frontend**: UI components for Quartz (SvelteKit).

### Manifest Example (`plugin.zon`)
```zon
.{
    .name = "plugin-qdraw",
    .version = "0.1.0",
    .author = "Quartz Team",
    .directives = .{
        "qdraw" = .{
            .type = "diagram",
            .description = "Draw diagrams inside Docz"
        }
    }
}
```

---

## 4. Folder Structure

```
plugin-qdraw/
├── src/
│   └── main.zig
├── plugin.zon
├── README.md
└── examples/
    └── usage.dcz
```

For JSON-based metadata (optional):
```json
{
  "name": "docz-plugin-zeno",
  "version": "1.0.0",
  "description": "Render interactive Zeno Engine scenes",
  "author": "Your Name",
  "entry": "plugin.zig",
  "hooks": {
    "register": "registerPlugin"
  }
}
```

---

## 5. Plugin Lifecycle & Hooks

Plugins integrate via **hooks**:

| Hook Name    | Purpose                                  |
|------------- |------------------------------------------|
| `onRegister` | Initialize plugin and directives.       |
| `onParse`    | Extend tokenization or AST.             |
| `onRender`   | Control rendering of custom directives. |
| `onExecute`  | Run WASM execution for code-based tasks.|
| `onTeardown` | Cleanup on shutdown.                    |

---

## 6. Writing Your First Plugin

### Step 1: Initialize
```bash
mkdir docz-plugin-hello
cd docz-plugin-hello
touch plugin.zon src/main.zig README.md
```

### Step 2: Implement Core
```zig
const std = @import("std");
pub fn registerPlugin() void {
    std.debug.print("Hello Plugin Registered!\n", .{});
}
```

---

## 7. Adding a Custom Directive

Example: `@hello(name="Docz")`

### Parsing
- Hook into `Parser` to detect `@hello(...)`.
- Inject AST node: `DirectiveNode(name="hello", params=...)`.

### Rendering
Output HTML:
```html
<p>Hello, Docz!</p>
```

---

## 8. Testing Plugins
```zig
const std = @import("std");
test "hello plugin outputs correct HTML" {
    const result = renderHello("Docz");
    try std.testing.expectEqualStrings("<p>Hello, Docz!</p>", result);
}
```
Run tests:
```bash
zig build test
```

---

## 9. Installing Plugins
Declare in `docz.zig.zon`:
```zon
.plugins = .{
    .docz-plugin-hello = .{
        .url = "https://github.com/user/docz-plugin-hello",
        .hash = "1220abc..."
    }
}
```
Install:
```bash
qz install plugin-hello
```

---

## 10. Advanced Capabilities
- **Custom Renderers**: HTML, Canvas, WebGL.
- **Secure Execution**: WASM sandboxes for untrusted code.
- **Access Document Metadata**:
```zig
pub fn onRender(meta: Meta, content: []const u8) void {
    if (meta.title) |title| {
        std.debug.print("Title: {s}\n", .{title});
    }
}
```

---

## 11. Frontend Integration
Add **Svelte components** for UI:
```
plugin-math3d/
└── ui/
    └── Math3D.svelte
```

Quartz auto-detects `ui` components via manifest.

---

## 12. Best Practices
- Use **semantic versioning**.
- Keep plugins **small and focused**.
- Validate **user input strictly**.
- Avoid heavy dependencies in core.
- Write **unit tests** for all hooks.

---

## 13. Publishing Plugins
1. Push to GitHub.
2. Tag a release.
3. Add `plugin.zon` and README.
4. Submit to **Docz Plugin Registry**.

```bash
qz publish plugin-hello
```

---

## 14. Security Guidelines
- Validate all inputs.
- Sandbox dynamic execution.
- Verify plugin hashes for integrity.

---

## 15. Example: Zeno Engine Plugin
Directive:
```
@embed(type="zeno-scene", source="scene.zson")
```
Features:
- Real-time simulation.
- WASM execution.
- WebSocket streaming.

---

## 16. Workflow Diagram
```
Plugin Source → Compile Zig → Register in manifest → Install via CLI → Use in Docz
```

<<<

`ROADMAP.md`: >>>

# ROADMAP.md – The Strategic Blueprint for Docz

Docz is not just another documentation tool—it is **the foundation for a new era of structured knowledge**.  
Where Markdown gave us simplicity, Docz introduces **semantic rigor, security, and extensibility** as first-class principles.  

This roadmap is not a checklist—it is an **architectural manifesto**, designed to guide contributors toward building a system that will remain relevant for decades.

---

## 1. Why This Roadmap Exists

Current documentation ecosystems fail because:
- **Markdown is weak**: It lacks structure, semantic meaning, and security guarantees.
- **Execution is unsafe**: Embedded code runs without isolation or trust validation.
- **Extensibility is chaotic**: Plugins exist as ad-hoc hacks, with no universal framework.

Docz changes this by:
- Defining `.dcz` as a **structured, declarative documentation format**.
- Building a **deterministic, Zig-based core**.
- Providing **secure WASM execution** for embedded logic.
- Designing a **plugin-first ecosystem** that scales without bloating the core.

This roadmap explains **how we build Docz into the universal standard for documentation**.

---

## 2. Guiding Principles

- **Deterministic by Design**: Every build is reproducible and cryptographically verifiable.
- **Secure by Default**: WASM sandboxing for all executable code.
- **Minimal Core, Infinite Extension**: The core handles parsing, validation, and rendering; everything else is modular.
- **Timeless Architecture**: Docz is designed to last beyond 2025, using first principles, not trends.
- **Quartz Independence**: Docz is self-sufficient. Quartz is an optional consumer, not a dependency.

---

## 3. Vision Architecture (Conceptual Flow)

```
.dcz Source
    ↓ Parsing & Validation (Zig)
Structured AST
    ↓ Renderers
HTML / PDF / JSON / WASM
    ↓ Consumers
Quartz / Minimal GUI / Custom Pipelines
    ↓ Extensions
Plugins, Themes, Exporters
```

Key insights:
- **AST as the single source of truth** → Enables infinite rendering possibilities.
- **Plugins as architectural nodes** → Add power without breaking stability.
- **Output-agnostic design** → Docz works anywhere, from CLI to web to native.

---

## 4. Strategic Objectives

1. Establish `.dcz` as the **universal structured documentation format**.
2. Build a **deterministic Zig-based core** with secure parsing and rendering.
3. Implement **WASM sandboxing** for safe embedded execution.
4. Create a **plugin-first architecture** for extensibility.
5. Deliver an **optional GUI layer** for non-Quartz users.
6. Define **testing, security, and style standards** for every contributor.

---

## 5. Multi-Phase Development Blueprint

Each phase is a **layer in the system architecture**, not just a timeline.

---

### **Phase 1: Core Foundation (Current Priority)**
**Goal:** Make Docz operational as a standalone engine.
- ✅ Parser:
    - Tokenize `.dcz` syntax → AST.
    - Enforce directive integrity and strict validation.
- ✅ Renderer:
    - Convert AST → HTML with theming hooks.
- ✅ CLI:
    - Commands: `docz build`, `docz preview`.
- ✅ Testing:
    - Inline Zig tests for every module.
- **Why This Matters:** A strong foundation ensures future modularity.

**Deliverable:**  
A deterministic binary that converts `.dcz` → HTML with complete test coverage.

---

### **Phase 2: Plugin & Theme Ecosystem**
**Goal:** Unlock modularity and user innovation.
- ✅ Plugin Loader:
    - Validate manifests (`plugin.zon`).
    - Register hooks (`onRegister`, `onRender`).
- ✅ Core Plugins:
    - `plugin-math` → LaTeX rendering.
    - `plugin-zeno` → Simulation support.
- ✅ Theme Engine:
    - Declarative `.dczstyle` files for styling.
- **Why This Matters:** Prevent core bloat while enabling ecosystem growth.

---

### **Phase 3: Developer Experience**
**Goal:** Lower friction for adoption and contribution.
- ✅ VSCode Extension:
    - Syntax highlighting and directive hints.
- ✅ Web Preview:
    - Live `.dcz` rendering in the browser.
- ✅ Minimal GUI:
    - Optional standalone renderer for GUI users.
- **Why This Matters:** Accessibility accelerates adoption without coupling to Quartz.

---

### **Phase 4: Advanced Capabilities**
**Goal:** Secure execution, marketplace, and long-term trust.
- ✅ WASM Sandbox:
    - Isolate and verify embedded logic.
- ✅ Plugin Marketplace:
    - Verified plugins with cryptographic signatures.
- ✅ Quartz API Integration:
    - Docz outputs seamlessly integrated into Quartz IDE.
- **Why This Matters:** Secure, composable, and adaptable for the future.

---

## 6. Cross-Phase Initiatives

- **Security First**: Hash-verify all dependencies, sandbox all code.
- **Test Discipline**: Inline tests enforced by CI on every PR.
- **Documentation as Code**: Update `.dcz` samples alongside every feature.

---

## 7. Risk & Resilience Strategy

| Risk                    | Mitigation                                    |
|------------------------ |-----------------------------------------------|
| Zig evolution          | Pin to stable release, adapt CI early.       |
| Plugin vulnerabilities | Mandatory hash verification + sandboxing.    |
| Ecosystem drift        | Centralized registry for verified plugins.   |
| Scope creep            | Enforce roadmap principles in PR reviews.    |

---

## 8. Horizon: Stretch Goals

- **AI-Assisted Plugins**: Summarization, diagramming, and intelligent linting.
- **Universal Export Pipeline**: PDF, EPUB, and fully interactive web outputs.
- **Parallel Rendering**: Multi-threaded Zig pipelines for large `.dcz` projects.
- **Self-Hosted Ecosystem**: Native `.dcz` rendering on Zigadel’s future GitHub alternative.

---

## 9. The Roadmap as a Social Contract

This roadmap is not just a technical document—it is a **declaration of intent**:
- Every contributor helps shape **a universal standard for structured knowledge**.
- Every commit moves Docz closer to **clarity, reproducibility, and trust**.
- Every plugin extends this mission without compromising integrity.

You are not just writing code—you are **building the future default for documentation**.

---

### Related Docs
- [WORKFLOW.md](./WORKFLOW.md)
- [CONTRIBUTING.md](../.github/CONTRIBUTING.md)
- [STYLE_GUIDE.md](./STYLE_GUIDE.md)
- [PLUGIN_GUIDE.md](./PLUGIN_GUIDE.md)
- [DEPENDENCIES.md](./DEPENDENCIES.md)

---

**Last Updated:** {Insert Date}

<<<

`SPEC.dcz`: >>>

@meta(title="Docz Mini‑Spec v0", version="0.1.0", status="DRAFT", updated="2025‑08‑10") @end

@css()
:root { --prose: 70ch }
body { font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
h1,h2,h3 { line-height: 1.25; margin: 1.2em 0 .4em }
p { margin: .8em 0}
pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 6px; overflow:auto }
.math { font-style: italic }
@end

@heading(level=1) Docz Mini‑Spec v0 @end
This is the **single source of truth** for the `.dcz` format for Milestone M0→M1.
Everything in core (tokenizer, parser, AST, converters, preview, and plugins) MUST conform to this spec.
Spec changes require tests and MUST be documented here before merge.

@heading(level=2) Scope @end
This spec defines:
- Lexical rules (tokens, escaping).
- Block structure (directives, attributes, nesting).
- Canonical AST node set and required attributes.
- Determinism requirements for round‑trips.
- Validation & sanitization rules (MUST/SHOULD).
- Diagnostics shape (error categories + spans).
It also inventories **planned directives**. Unimplemented directives are marked *PLANNED*; validators SHOULD accept them as unknown-by-core but MAY allow via plugins.

@heading(level=2) Lexical Rules @end
Whitespace is UTF‑8. Lines end with `\n`. The tokenizer recognizes:
- `@directive` introducer at start of a directive.
- Parameter list: `(@-separated attributes)` — see “Attributes”.
- `@end` closes a directive block. **Directives MUST be closed** (no implicit closures).
- Plain paragraphs are sequences of non-directive lines separated by blank lines.
- Code and Math are fenced blocks opened by `@code(...)` / `@math(...)` and closed by `@end`.
- Inline escaping inside blocks uses `@@` to represent a literal `@`.
- Backslash escapes in text are **NOT** interpreted by Docz (left for exporters), except where noted by converters.

@heading(level=3) Attributes @end
Attributes are comma‑separated key/value pairs inside `()`:
@code(language="")
key="string", key2=123, flag=true
@end
Rules:
- Keys: `[a‑zA‑Z_][a‑zA‑Z0‑9_\-]*`
- Values: unquoted numbers/booleans OR quoted strings (`"..."`) with `\"` for quotes, `\\` for backslash.
- Ordering is **not significant**; exporters MAY reorder deterministically (lexicographic by key).

@heading(level=2) Blocks & Directives @end
A directive has this form:
@code(language="")
@name(k1="v1", k2=2, flag=true)
...block content...
@end
@end

@heading(level=3) Core Directives (Implemented) @end
These MUST be supported by core and round‑trip converters.

@code(language="")
@meta(...):     Top‑level only. Key/values become document metadata (title, author, version, etc.). No content.
@heading(...):  Attributes: level=1..6 (required). Content is inline text on same line after closing ')'. No nested blocks.
@code(...):     Attributes: language="" (optional), execute=false (reserved). Content: raw preformatted until @end.
@math(...):     Attributes: none (for v0). Content: raw math until @end.
@image(...):    Attributes: src (required), width/height (optional strings). No content. (Media)
@import(...):   Attributes: href (required), type? (e.g., stylesheet/script). No content.
@style(...):    Attributes: freeform. Content is raw (ignored by strict HTML/TeX exporters in v0).
@end
@end

@heading(level=3) Extended Directives (PLANNED) @end
Core validator MUST recognize the spelling and basic shape; deeper semantics may be delegated to plugins.
Exporters MAY no‑op until implemented.
@code(language="")
@style-def(...): Define named style tokens; content contains style rules. (PLANNED)
@data(...):      Attributes: format=("json"|"yaml"|"csv"|...). Content is raw data. (PLANNED)
@plot(...):      Attributes: type, x=, y=, etc.; or content as data block. (PLANNED)
@video(...):     Attributes: src, controls=true|false, poster? (PLANNED)
@audio(...):     Attributes: src, controls=true|false (PLANNED)
@pdf(...):       Attributes: src, page? (PLANNED)
@embed(...):     Attributes: type, source, width?, height? (PLANNED)
@graph(...):     Attributes: type ("imports"|"links"|...); content lists nodes/edges. (PLANNED)
@logic(...):     Attributes: none; content is script to be executed in sandbox (WASM/JS). (PLANNED)
@end
@end

@heading(level=2) Structural Rules @end
- Document root is an implicit `Document` node containing a linear list of blocks.
- `@meta` nodes MUST appear before any body nodes (order preserved). Multiple `@meta` allowed; last write wins per key.
- `@heading(level=n)` is a block header with inline text on the same line: `@heading(level=2) My Title @end`.
- `@code` / `@math` / `@data` are multi‑line blocks terminated by `@end`. Content is NOT parsed for nested directives.
- `@image`, `@import` are leaf nodes (no content block). They MAY appear anywhere in body.
- Unknown directives: core MUST retain them as `Unknown(name, attributes, raw_block?)` for round‑trip safety.
- Nesting: v0 forbids nested directives (everything is flat). Future versions MAY allow limited nesting via plugins.

@heading(level=2) Canonical AST (v0) @end
Core nodes and required attributes:
@code(language="")
Document:  children:[Node]
Meta:      attrs:{string→string} (title, author, version, ...); no content
Heading:   attrs:{level:string}; content:string (inline text)
Content:   content:string (paragraph text)
CodeBlock: attrs:{language?:string, execute?:bool}; content:string (verbatim)
Math:      content:string (verbatim)
Media:     attrs:{src:string, kind:"image"|"video"|"audio"|"pdf", width?:string, height?:string}; no content for v0
Import:    attrs:{href:string, type?:"stylesheet"|"script"}; no content
Style:     attrs:{...}; content:string (opaque)
Unknown:   attrs:{...}; name:string; content?:string
@end

Mapping from directives to AST:
@code(language="")
@meta         → Meta
@heading      → Heading
(plain text)  → Content (paragraphs; blank-line separated)
@code         → CodeBlock
@math         → Math
@image        → Media(kind="image")
@video        → Media(kind="video")     (PLANNED → Unknown until implemented)
@audio        → Media(kind="audio")     (PLANNED → Unknown until implemented)
@pdf          → Media(kind="pdf")       (PLANNED → Unknown until implemented)
@import       → Import
@style        → Style
(others)      → Unknown(name=..., attrs=..., content?)
@end

@heading(level=2) Determinism & Round‑Trip @end
- Converters MUST be deterministic given the same AST and options.
- Whitespace policy:
  - Paragraphs normalize trailing whitespace; internal spacing preserved.
  - Code/Math are preserved verbatim except trimming a trailing `\n\n` may occur during export; importers MUST normalize back.
- Attribute order in serialized forms MUST be stable (lexicographic by key).
- Unknown nodes MUST be preserved across `dcz → X → dcz` (opaque pass‑through).

@heading(level=2) Validation Rules (core/validate.zig) @end
The validator MUST enforce:
@code(language="")
[GEN]
- All directives are closed by @end when required.
- No nesting in v0 (report error if a directive appears inside a block content).
- Attributes: keys unique per node; values match expected types.

[META]
- Only at top of document until first non-Meta node.
- Keys: any string; recommended: title, author, version, keywords, updated.

[HEADING]
- level ∈ {1..6}; content non-empty.
- No trailing spaces inside level attribute value.

[CODE]
- language: string (may be empty); execute: boolean (default false).
- Content may be empty (allowed).

[MATH]
- Content may be empty (validator MAY warn).

[MEDIA]
- src: non-empty string; width/height if present must be strings (pass-through).

[IMPORT]
- href: non-empty. type optional: "stylesheet"|"script".

[STYLE]
- Opaque: always valid; warn if empty.
@end

Failure categories:
@code(language="")
E100: Unexpected EOF (missing @end)
E110: Unknown directive (if strict mode enabled)
E120: Disallowed nesting in v0
E130: Duplicate attribute key
E140: Invalid attribute type/value
E150: Meta after body content
E160: Missing required attribute
W200: Empty content (Math/Style), allowed but questionable
@end

@heading(level=2) Sanitization Rules (core/sanitize.zig) @end
Sanitizer SHOULD:
@code(language="")
- Trim trailing whitespace in paragraph lines.
- Normalize consecutive blank lines to a single blank line.
- Canonicalize attribute ordering (lexicographic by key).
- Clamp heading level into [1,6].
- Remove entirely empty nodes (except CodeBlock — keep empty code).
@end

@heading(level=2) Diagnostics Shape @end
CLI MUST be able to print human‑readable and JSON forms. JSON schema (minimal v0):
@code(language="json")
{
  "file": "path/to/doc.dcz",
  "errors": [
    {
      "code": "E160",
      "message": "Missing required attribute 'level'",
      "span": { "line": 12, "col": 1, "endLine": 12, "endCol": 20 },
      "node": "Heading"
    }
  ],
  "warnings": [
    {
      "code": "W200",
      "message": "Empty math block",
      "span": { "line": 33, "col": 1, "endLine": 35, "endCol": 5 },
      "node": "Math"
    }
  ]
}
@end

@heading(level=2) Compliance Checklist (for PRs) @end
- [ ] SPEC.dcz updated (this file) with any format/behavior change.
- [ ] Unit tests for tokenizer/parser/validators updated.
- [ ] Snapshot round‑trip tests updated for md/html/tex.
- [ ] Deterministic output verified on all three OSes in CI.
- [ ] Diagnostics include accurate spans and codes.

@heading(level=2) Appendix A: Mini‑Grammar (Informal) @end
@code(language="")
Document    := (Meta | Block | Paragraph)*
Meta        := "@meta(" AttrList? ")" WS "@end" NL
Heading     := "@heading(" "level=" Int ")" WS InlineText WS "@end" NL
CodeBlock   := "@code(" AttrList? ")" NL CodeBody "@end" NL
Math        := "@math(" AttrList? ")" NL MathBody "@end" NL
Image       := "@image(" AttrList ")" WS "@end" NL
Import      := "@import(" AttrList ")" WS "@end" NL
Style       := "@style(" AttrList? ")" NL StyleBody "@end" NL
Unknown     := "@" Ident "(" AttrList? ")" (NL Body "@end" NL | WS "@end" NL)
Paragraph   := TextLine+ NL

AttrList    := Attr ("," WS Attr)*
Attr        := Ident "=" (Number | Bool | String)
Ident       := [A-Za-z_][A-Za-z0-9_\-]*
Number      := [0-9]+
Bool        := "true" | "false"
String      := "\"" ( [^"\\] | "\\\"" | "\\\\" )* "\""
InlineText  := (not NL, may contain spaces, supports "@@" for literal "@")
@end

@heading(level=2) Appendix B: Directive Inventory @end
This table tracks implementation status for core + planned directives (update as features land).
@code(language="")
name        | status     | ast      | exporter/html | exporter/md | exporter/tex
------------+------------+----------+---------------+-------------+--------------
meta        | CORE       | Meta     | head/meta     | front-matter| \title/\author
heading     | CORE       | Heading  | <h1..h6>      | #..######    | \sec/\sub..
code        | CORE       | CodeBlock| <pre><code>   | ``` ```      | verbatim
math        | CORE       | Math     | <div class=..>| $$/$$        | equation
image       | CORE       | Media    | <img>         | ![]()        | \includegraphics
import      | CORE       | Import   | <link>        | (no-op)      | (no-op)
style       | CORE       | Style    | (ignored v0)  | (ignored v0) | (ignored v0)
style-def   | PLANNED    | Style    | (tbd)         | (tbd)        | (tbd)
data        | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
plot        | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
video       | PLANNED    | Media    | <video>       | (link)       | (no-op)
audio       | PLANNED    | Media    | <audio>       | (link)       | (no-op)
pdf         | PLANNED    | Media    | (embed)       | (link)       | (no-op)
embed       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
graph       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
logic       | PLANNED    | Unknown  | (tbd)         | (tbd)        | (tbd)
@end

@heading(level=2) Versioning @end
- This file’s `version` field tracks spec compatibility.
- Breaking changes bump MINOR while in v0 (0.x). Once stable, follow SemVer (MAJOR.MINOR.PATCH).

<<<

`STYLE_GUIDE.md`: >>>

# STYLE_GUIDE.md – The Unified Design Language for Docz

Docz is more than a documentation engine—it is **the future of structured knowledge**.  
This style guide defines the **rules, rationale, and principles** that keep our ecosystem consistent, secure, and timeless.

It applies to:
- **Docz Markup Language** (`.dcz` files)
- **Core & Plugin Development in Zig**
- **Project Structure & Testing**
- **Security and Performance Practices**

---

## 1. Purpose of This Guide

Consistency is not cosmetic—it is **architectural integrity**.  
Docz aims to become the **universal standard for declarative documentation**, and that requires:
- **Predictability:** Anyone can read and reason about a `.dcz` file or Zig module without surprises.
- **Extensibility:** Rules that allow evolution without chaos.
- **Security by Design:** Avoiding ambiguity that leads to vulnerabilities.

This guide is the **social contract for style**, ensuring **clarity, composability, and trust** in every line of code and every directive.

---

## 2. Design Principles

Before rules, understand **why they exist**:
- **Explicitness over Implicitness:** Hidden conventions create bugs and security holes.
- **Flatness over Nesting:** Complexity increases attack surface and cognitive load.
- **Semantic Rigor:** Every directive and function should express its intent clearly.
- **Separation of Concerns:** Content, presentation, and logic are distinct layers.
- **Security First:** Every design decision considers attack vectors and sandbox compliance.

---

## 3. Docz Markup Style (`.dcz`)

### 3.1 Core Rules and Their Rationale
✅ **Explicit directives only** (`@heading`, `@meta`) → Prevent ambiguity from Markdown-like syntax.  
✅ **Minimal nesting** → Keeps parsing predictable and secure.  
✅ **Parameter-driven config** → Avoid inline hacks that break determinism.  
✅ **Always close blocks** → Ambiguous termination invites parser errors and injection risk.

---

### 3.2 Document Structure
- **Metadata first**: Establish identity and context upfront.
```dcz
@meta(title="Docz Example", author="Quartz Team", version="1.0")
```

- **Imports before content**: Declarative ordering avoids hidden dependencies.
```dcz
@import("styles/academic.dczstyle")
```

- **Explicit block closure**:
```dcz
@heading(level=2) Quick Start
@end
```

---

### 3.3 Directive Syntax Rules
- **Start with `@`** → Makes parsing deterministic.
- **Parameters use `key=value` pairs**.
- **Quote strings with spaces** → No ambiguity in parsing.
- **Examples:**
```dcz
@code(language="zig", execute=true)
const x = 42;
@end
```

**Why?** → Prevents silent failures and enforces structural clarity.

---

### 3.4 Naming Conventions
- **Files:** `kebab-case` → `getting-started.dcz`.
- **Directives:** lowercase → `@heading`, not `@Heading`.
- **Why?** → Lowercase directives reduce lexical complexity for parser.

---

### 3.5 Indentation & Formatting
- **Directives unindented**, nested content indented by 4 spaces.
- **Why?** → Consistent visual hierarchy for readability and parsing predictability.

---

### 3.6 Comments
```dcz
#: This is a comment
```
**Why?** → Uses a unique marker to avoid conflict with directive syntax.

---

### 3.7 Linting Rules
- All block directives must end with `@end`.
- Validate asset paths.
- Disallow unused styles.
**Why?** → Enforces hygiene and prevents runtime failures.

---

## 4. Zig Code Style for Core & Plugins

### 4.1 Naming
- **Types & Structs:** `CamelCase` → `ASTNode`.
- **Functions:** `camelCase` → `parseDoczFile`.
- **Constants:** `UPPER_CASE` → `MAX_BUFFER`.
- **Variables:** `snake_case` → `node_list`.
**Why?** → Each style signals intent (type vs function vs constant).

---

### 4.2 Error Handling
- Use Zig idioms:
```zig
const file = try std.fs.cwd().openFile("docz.dcz", .{});
```
- **No `catch unreachable`** outside tests.
**Why?** → Failure paths must be explicit to maintain determinism.

---

### 4.3 Layout & Formatting
- **Max line length:** 100 chars.
- **Group imports at top:**
```zig
const std = @import("std");
const parser = @import("parser.zig");
```

---

### 4.4 Documentation
- Use `///` for public APIs:
```zig
/// Parses a Docz file and returns AST.
pub fn parseDoczFile(path: []const u8) !ASTNode { ... }
```

---

## 5. Plugin Development Standards

### 5.1 Manifest Format
Plugins declare metadata in `.zon`:
```zon
.{
    .name = "plugin-zeno",
    .version = "1.0.0",
    .hooks = .{ "onRegister" = true }
}
```

### 5.2 Hook Names
- Reserved:
    - `onRegister` → Plugin bootstrap.
    - `onParse` → Modify AST.
    - `onRender` → Affect output.

### 5.3 Directory Layout
```
plugin-name/
├── plugin.zon
└── src/main.zig
```

---

## 6. Project Structure Rules
```
docz/
    core/           # Parser, CLI, runtime
    plugins/        # Official plugins
    examples/       # Sample .dcz files
    docs/           # Internal documentation
```

---

## 7. Testing Standards
- Tests live inline in `.zig` files:
```zig
test "parse heading" {
    const result = try parseDocz("@heading(level=2) Title @end");
    try expectEqual(result[0].node_type, NodeType.Heading);
}
```
- Descriptive test names.
- **No separate `tests/` folder** → Tests travel with code for cohesion.

---

## 8. Security & Performance Principles

### Security:
- **Hash-verify all plugins**.
- **Sandbox WASM execution**.
- **Fail closed, not open** → Default to safety.

### Performance:
- **Zero-copy parsing** where possible.
- **Arena allocators** over global state.
- **Rationale:** These rules preserve speed and determinism without compromising safety.

---

## 9. Related Docs
- [CONTRIBUTING.md](../.github/CONTRIBUTING.md)
- [ROADMAP.md](./ROADMAP.md)
- [WORKFLOW.md](./WORKFLOW.md)
- [PLUGIN_GUIDE.md](./PLUGIN_GUIDE.md)

---

**Last Updated:** {Insert Date}

<<<

`WORKFLOW.md`: >>>

# WORKFLOW.md – The Contributor’s Operations Playbook for Docz

Docz is not a typical software project—it is **knowledge infrastructure**.  
Our workflow is designed to ensure **security, clarity, and reproducibility**, so that every change you make strengthens the foundation of this ecosystem.

This is not just “how to work”—it explains **why these processes exist**.

---

## 1. Why Workflow Matters

A workflow is the **chain of trust** in a decentralized ecosystem.  
In a world where `.dcz` may replace `.md` as the default knowledge format, we must guarantee:
- Every build is deterministic.
- Every feature merges only after validation.
- Every plugin upholds the same integrity guarantees as the core.

By following this workflow, you help Docz remain **secure, scalable, and timeless**.

---

## 2. Branching Model: Stability Through Structure

We follow a **tiered branching strategy** for clarity and risk containment:

| Branch       | Purpose                                |
|------------- |----------------------------------------|
| `main`       | Production-ready stable releases.     |
| `dev`        | Integration branch for upcoming release.|
| `feature/*`  | Isolated branches for new work.       |

### Why this matters:
- **`main` is sacred**: Always green, always release-ready.
- **`dev` is staging**: Collects features after review.
- **`feature/*` is isolation**: Prevents unstable code from contaminating integration.

**Rules:**
- Start all work from `dev`.
- Merge to `dev` via Pull Request after review and CI success.
- Only merge `dev` → `main` during release, never directly.

---

## 3. Commit Standards: Semantics = Future-Proofing

We use **Conventional Commits** for a reason:
- Enables **automated changelogs**.
- Provides **machine-readable history**.
- Improves collaboration by signaling intent.

| Prefix        | Meaning                                |
|-------------- |---------------------------------------|
| `feat:`       | New feature.                         |
| `fix:`        | Bug fix.                             |
| `docs:`       | Documentation changes.               |
| `refactor:`   | Internal change without behavior shift.|
| `test:`       | Adding/updating tests.              |
| `ci:`         | CI/CD or pipeline adjustments.       |

**Example:**
```
feat(parser): add directive parsing for @math
```

---

## 4. Pull Request Workflow: Quality as a Gate

Pull Requests are **architectural checkpoints**, not bureaucracy.  
Before merging:
- ✅ All tests must pass (`zig build test`).
- ✅ Linting applied (`zig fmt`, `qz lint` for `.dcz`).
- ✅ Documentation updated for new/changed features.
- ✅ Security-sensitive code explicitly reviewed.

**Review Policy:**
- Minimum **one maintainer approval**.
- No self-merging without emergency review exception.

---

## 5. Testing Workflow: Integrity Over Convenience

Tests are **inline** within `.zig` files. Why?  
- Locality improves maintenance.
- Documentation and verification live together.

**Run tests:**
```bash
zig build test
```

**Coverage Goal:**  
- 100% for parser, CLI, and plugin hooks.
- Both positive and negative cases.
- Include **fuzz tests for parser resilience**.

Example:
```zig
test "parse heading directive" {
    const result = try parseDocz("@heading(level=2) Title @end");
    try expectEqual(result[0].node_type, NodeType.Heading);
}
```

---

## 6. CI/CD Philosophy: Determinism + Security

Our pipelines enforce **immutability and trust**:
- **On PR:**  
    - Build with Zig.
    - Run full test suite.
    - Validate `.dcz` examples.
- **On Release Tag:**  
    - Build reproducible binaries.
    - Generate signed checksums.

**Workflows:**
- `ci.yml` → Tests on every PR.
- `release.yml` → Builds multi-platform artifacts.
- `extension-publish.yml` → Publishes VSCode extension.

---

## 7. Plugin Contribution Flow: Controlled Extensibility

Plugins are the **lifeblood of Docz**, but they must respect our guarantees:
- Each plugin includes:
    - `plugin.zon` manifest.
    - Hooks (`onRegister`, `onParse`, `onRender`).
    - Inline tests for all logic.
- Plugins follow **the same linting, testing, and security rules** as core.

**Flow:**
- Scaffold under `plugins/plugin-name/`.
- Add manifest, code, and tests.
- Submit PR for registry approval.

Reference: [PLUGIN_GUIDE.md](../docs/PLUGIN_GUIDE.md).

---

## 8. Security in Workflow: Non-Negotiable Standards

- All dependencies **hash-verified**.
- No unchecked WASM execution—sandbox required.
- PRs modifying:
    - File I/O,
    - Networking,
    - WASM runtime  
  **must undergo security review**.

---

## 9. Your Role in the Chain of Integrity

Every commit you make either strengthens or weakens Docz.  
Ask yourself before merging:
- Does this change make Docz **more deterministic, more secure, and more extensible**?
- Will this still make sense **10 years from now**?

If yes → Merge. If no → Rethink.

---

### Related Docs
- [CONTRIBUTING.md](../.github/CONTRIBUTING.md)
- [ROADMAP.md](./ROADMAP.md)
- [STYLE_GUIDE.md](./STYLE_GUIDE.md)
- [PLUGIN_GUIDE.md](./PLUGIN_GUIDE.md)

---

**Last Updated:** {Insert Date}

<<<

`README-old.md`: >>>

# Docz: The Future of Documentation

## 1. Introduction

Docz is a next-generation document format designed to replace outdated standards like Markdown, LaTeX, and Jupyter notebooks.

Modern documentation demands:

- **Human readability** (like Markdown).
- **Mathematical expressiveness** (like LaTeX).
- **Computational interactivity** (like Jupyter).

Docz combines all three in one unified, extensible syntax.

### Why Not Markdown?
- Limited expressiveness for scientific content.
- Poor AI parsing due to ambiguous syntax.
- No built-in interactivity or styling control.

### Why Not LaTeX?
- Powerful but rigid and hard to learn.
- Outdated for modern web and collaboration.

### Why Not Jupyter?
- Good for code, bad for structure.
- Fragile, bloated notebooks with hidden state issues.

**Docz bridges these gaps:**
- Human-first, AI-friendly syntax.
- Built-in support for math, media, and interactive content.
- Graph-based document model for modular composition.

---

## 2. Project Status & Vision

**Status:** Docz is in active development.

**Goal:** Replace Markdown, LaTeX, and Jupyter with a unified, future-proof format for documentation, math, and computation. 

**Ecosystem Includes:**
- **Quartz**: Modern editor for Docz.
- **VSCode Extension**: Live preview, IntelliSense, auto-formatting.
- **Zig Core**: Parser, CLI, WASM execution engine.

---

## 3. Quick Start

### Install Quartz CLI
```bash
curl -fsSL https://get.quartz.dev/install.sh | sh
```

### Create Your First Docz File
```bash
dcz new README.dcz
```

### Preview in Quartz
```bash
dcz preview README.dcz
```

---

## 4. Core Concepts

Docz is:
- **Declarative**: No hidden logic; everything is explicit.
- **Composable**: Import and reuse sections across projects.
- **Extensible**: Add new directives via plugins.

It separates:
- Structure (`@heading`, `@import`).
- Style (`@style`, `@style-def`).
- Logic (`@logic`, `@embed`).

Quartz runtime powers Docz:
- Parses `.dcz` → AST.
- Executes code in WASM sandbox.
- Renders UI in SvelteKit.

### Why Docz is Different
| Feature             | Markdown | LaTeX | Jupyter | Docz |
|---------------------|----------|-------|---------|------|
| Math Support        | Basic    | Full  | Full    | Full |
| Interactivity       | No       | No    | Yes     | Yes  |
| AI-Friendly         | No       | No    | Limited | Yes  |
| Extensible Plugins  | No       | No    | Limited | Yes  |
| WASM Execution      | No       | No    | No      | Yes  |


---

## 5. File Structure

### Minimal Example
```txt
@meta(title="Docz Example", author="Quartz Team")

@heading(level=1) Introduction
Docz is the future of documentation.

@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end
```

### Monograph Model
Use imports for multi-section docs:
```txt
main.dcz
chapters/
    intro.dcz
    methodology.dcz
    results.dcz
```

`main.dcz:`
```c
@import("chapters/intro.dcz")
@import("chapters/methodology.dcz")
@import("chapters/results.dcz")
```

## 6. Directives Overview

Docz introduces clear, semantic directives for every structural and interactive element (some may accept parameters).

| Directive    | Purpose                                  |
| ------------ | ---------------------------------------- |
| `@meta`      | Document metadata (title, tags, version) |
| `@heading`   | Section headings with explicit levels    |
| `@import`    | Include other `.dcz` files or styles     |
| `@style`     | Inline styling for text or blocks        |
| `@style-def` | Define global reusable styles            |
| `@code`      | Code blocks (executable for Zig)         |
| `@data`      | Embed structured data (JSON, YAML)       |
| `@math`      | Render math (LaTeX syntax)               |
| `@plot`      | Generate plots from data or functions    |
| `@graph`     | Visualize graphs or DAGs                 |
| `@image`     | Embed images                             |
| `@video`     | Embed videos                             |
| `@audio`     | Embed audio                              |
| `@embed`     | Interactive content                      |
| `@logic`     | Lightweight interactivity                |

### Math & Visualization
- `@math` → LaTeX-style equations.
- `@plot` → Data or function plots.
- `@graph` → DAG visualization.

### Media Directives
- `@media(type="image", ...)` → Generic media directive.

Shorthands:
```ts
@image(src="diagram.png")
@video(src="demo.mp4")
@audio(src="track.wav")
@pdf(src="paper.pdf")
@end
```

### Dynamic Content
- `@embed` → Interactive components (e.g., Zeno Engine scenes).
- `@logic` → Lightweight interactivity.

**Example:**
```txt
@image(src="diagram.png", onClick="play('audio1')")
@end

@logic()
function play(id) {
    document.getElementById(id).play();
}
@end
```

---

## 7. Syntax Rules

Docz syntax is explicit, minimal, and consistent.

### Inline Directives
- Single-line usage.
- No `@end` required.
- Examples: `@heading`, `@image`, `@video`, `@audio`.

```txt
@heading(level=2) Introduction
@image(src="diagram.png")
```

### Block Directives
- Multi-line content.
- Must close with @end.
- Examples: @code, @style, @style-def, @logic, @math, @plot, @graph, @embed.

```txt
@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end
```

### Attribute Syntax
- Use key=value format.
- Quotes optional for simple strings, required for spaces.

Example:

```txt
@style(font-size=18px, color="dark blue")
```

## Nesting Rules
- Block directives cannot be nested unless explicitly supported.
- Example of allowed future nesting: @plot inside @math.

## Imports
- @import("file.dcz") must appear at the top or inside a composition file.

## Comments
- Use // for single-line comments.

```txt
// This is a comment
```

---

## 8. Styling System

Docz separates content from presentation.

### Inline Styling

```txt
The @style(color=blue, bold) harmonic field @end emerges.
```

### Block Styling
```txt
@style(font-size=18px, font-family="Inter")
This paragraph uses custom styling.
@end
```

### Global Styles
```txt
@style-def()
heading-level-1: font-size=36px, font-weight=bold, color=#000
body-text: font-family="Inter", line-height=1.6
@end
```

### External Styles
```ts
@import("styles/academic.dczstyle")
```

**Override Priority:** Inline > Local @style-def > Imported theme.

## 9. Execution Model

- Language: Zig first.
- Run Mode: Secure WASM sandbox.

Example:
```
@code(language="zig", execute=true)
const nums = [_]i32{1,2,3,4,5};
const sum = @reduce(.Add, nums);
@print(sum);
@end
```

Why Zig?
- WASM-native, deterministic, safe.
- Aligns with Quartz + Zeno ecosystem.

**Future:** Plugin-based multi-language execution.

---

## 10. Media & Interactivity

Bring documents to life with images, video, audio, PDFs, and interactive embeds.

### Static Media

```txt
@image(src="figures/diagram.png", width="600px", caption="System Architecture")
@end

@video(src="clips/demo.mp4", width="800px", controls=true)
@end
```

### Dynamic Content
```
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="800px", interactive=true)
@end
```

### Advanced Options
- `width`, `height`, `align`, `responsive=true`.

Example:
```ts
@image(src="diagram.png", width="600px", align="center", responsive=true)
@end
```

### Lightweight Logic

```txt
@image(src="diagram.png", onClick="play('narration')")
@end

@audio(id="narration", src="audio/explanation.wav", controls=false)
@end

@logic()
function play(id) {
    const audio = document.getElementById(id);
    audio.play();
}
@end
```

### Advanced Media Options
All media directives support:
- `width`, `height` → Size control.
- `align` → `left`, `center`, `right`.
- `responsive=true` → Auto-resize.

#### Example:
```txt
@image(src="diagram.png", width="600px", align="center", responsive=true)
@end
```

#### Zeno Engine Integration
```txt
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="900px", height="600px", interactive=true)
@end
```

---

## 11. Composition & Imports
Organize docs like modular code.

Example:
```
@import("chapters/intro.dcz")
@import("chapters/methodology.dcz")
```

Quartz automatically builds an **import** DAG:

```txt
main.dcz -> intro.dcz -> methodology.dcz
```

---

## 12. Graph & ZUQL Integration

Docz is graph-native:

- Every @import, tag, and link builds a semantic Directed Acyclic Graph (DAG).
- Visualize your document structure or query it with ZUQL.

### Example: Visualize Imports (multiple formats accepted)

Variant 1:
```txt
@graph(type="imports")
nodes:
    - main.dcz
    - chapters/intro.dcz
    - chapters/methodology.dcz
edges:
    - main.dcz -> chapters/intro.dcz
    - main.dcz -> chapters/methodology.dcz
@end
```

Variant 2:
```txt
@graph(type="imports")
nodes: [main.dcz, intro.dcz]
edges: [main.dcz -> intro.dcz]
@end
```
### Example: ZUQL Queries

```sql
SHOW DAG FOR main.dcz;
SELECT docs WHERE tag="math" AND status="draft";
```

---

## 13. Plugin System

### Why Plugins?

- Keep Docz core lean and dependency-free.
- Enable heavy features only when needed (e.g., 3D rendering, Zeno Engine).

### Install Plugins

```bash
dcz install plugin-zeno
dcz install plugin-3d-model
dcz install plugin-vulkan
dcz install plugin-webgpu
dcz install plugin-python
```

### Add Custom Directives

```text
@register-directive(name="qdraw", type="diagram")
@end
```

#### Plugin Types:

- Renderers: Zeno Engine, diagrams, 3D models.
- Exporters: PDF, ePub, HTML.
- Interactivity: Real-time collaboration.

---

## 14. Architecture Overview

Docz runtime architecture:

```
.dcz → Quartz Parser → WASM Core → SvelteKit UI
```

### Components

- Docz Parser: Tokenizes and builds AST.
- WASM Core: Executes Zig securely.
- Quartz UI: Renders layout, interactivity, and media.

`@diagram`:

```txt
+----------------+
| .dcz Document  |
+--------+-------+
         |
         v
+--------+-------+
| Quartz Parser  |
+--------+-------+
         |
         v
+--------+-------+
|  WASM Core     |
+--------+-------+
         |
         v
+--------+-------+
| SvelteKit UI   |
+----------------+
```

---

## 15. CLI Reference

Quartz CLI: `dcz`

| Command      | Description               |
| ------------ | ------------------------- |
| `dcz new`     | Create a new Docz file    |
| `dcz preview` | Live preview in Quartz UI |
| `dcz build`   | Compile to HTML/PDF       |
| `dcz install` | Install plugins           |

### Examples

```bash
dcz new README.dcz
dcz preview README.dcz
dcz build main.dcz --output docs/
```

---

## 16. Advanced Examples

### Monograph

```c
@import("chapters/intro.dcz")
@import("chapters/methodology.dcz")
@import("chapters/results.dcz")
```

### Math + Plot

```txt
@math()
E = mc^2
@end

@plot(type="line")
x: [1,2,3,4,5]
y: [1,4,9,16,25]
@end
```

### Media + Interactivity

```txt
@image(src="diagram.png", onClick="play('narration')")
@end

@audio(id="narration", src="audio/explanation.wav", controls=false)
@end

@logic()
function play(id) {
    const audio = document.getElementById(id);
    audio.play();
}
@end
```

---

## 17. Roadmap

- Collaboration: Real-time multi-user editing.
- AI Integration: Semantic suggestions, auto-formatting.
- Plugin Marketplace: Discover and share extensions.
- Native Quartz: Zig + WebGPU backend for high-performance rendering.

---

## 18. Tooling & Extensions
- **VSCode Extension**: Live preview like Markdown, IntelliSense for Docz directives, auto-formatting & linting powered by the Zig parser (via WASM).
- **Quartz Integration**: Full interactive editor built on SvelteKit.

---

## 19. Contributing

- Code: Written in Zig with strict test coverage.
- Style: Follow zero-dependency philosophy for Docz core.
- Testing: Use Zig’s built-in test blocks for every parser function.
- PRs welcome for:
    - Plugins.
    - Theme packs.
    - Rendering optimizations.

### Development Workflow
- Parser & CLI written in Zig.
- 100% test coverage on AST parser.
- `.github/` folder includes:
    - Issue & PR templates.
    - CI workflows (build, test, release).
- Run tests: `zig build test` (for unit tests), `test-integration`, `test-e2e`, or `test-all`
<<<

`README.dcz`: >>>

@meta(
    title="Docz: The Future of Documentation",
    author="Quartz Team",
    version="1.0",
    tags="documentation, docz, quartz"
)

@style-def()
heading-level-1: font-size=36px, font-weight=bold, color=#222
heading-level-2: font-size=28px, color=#444
body-text: font-family="Inter", line-height=1.6
code-block: font-family="Fira Code", font-size=14px
@end

@heading(level=1) Docz: The Future of Documentation

@heading(level=2) 1. Introduction
Docz is a next-generation document format designed to replace outdated standards like Markdown, LaTeX, and Jupyter notebooks.

@heading(level=3) Why It Exists
- Human readability like Markdown.
- Mathematical expressiveness like LaTeX.
- Computational interactivity like Jupyter.

@heading(level=3) Why Not Markdown?
- Limited expressiveness for scientific content.
- Poor AI parsing due to ambiguous syntax.
- No built-in interactivity or styling control.

@heading(level=3) Why Not LaTeX?
- Powerful but rigid and hard to learn.
- Outdated for modern web and collaboration.

@heading(level=3) Why Not Jupyter Notebooks?
- Good for code, bad for structure.
- Fragile, bloated notebooks with hidden state issues.

Docz bridges these gaps:
- AI-friendly, directive-based syntax.
- Native math + media + interactivity.
- Graph-based modular composition.

---

@heading(level=2) 2. Project Status & Vision
**Status:** Docz is in active development.  
**Goal:** Replace Markdown, LaTeX, and Jupyter with a unified, future-proof format for documentation, math, and computation.  
**Ecosystem Includes:**
- Quartz: Modern editor for Docz.
- VSCode Extension: Live preview, IntelliSense, auto-formatting.
- Zig Core: Parser, CLI, WASM execution engine.

---

@heading(level=2) 3. Quick Start
@code(language="shell")
curl -fsSL https://get.quartz.dev/install.sh | sh
qz new README.dcz
qz preview README.dcz
@end

---

@heading(level=2) 4. Core Concepts
Docz is:
- Declarative.
- Composable.
- Extensible.

Quartz runtime:
- Parses `.dcz` → AST.
- Executes code in WASM sandbox.
- Renders UI in SvelteKit.

@heading(level=3) Why Docz is Different
@table
Feature | Markdown | LaTeX | Jupyter | Docz
Math Support | Basic | Full | Full | Full
Interactivity | No | No | Yes | Yes
AI-Friendly | No | No | Limited | Yes
Extensible Plugins | No | No | Limited | Yes
WASM Execution | No | No | No | Yes
@end

---

@heading(level=2) 5. File Structure
@heading(level=3) Minimal Example
@code(language="text")
@meta(title="Docz Example", author="Quartz Team")

@heading(level=1) Introduction
Docz is the future of documentation.

@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end
@end

@heading(level=3) Monograph
@code(language="text")
main.dcz
chapters/
    intro.dcz
    methodology.dcz
@end

main.dcz:
@code(language="text")
@import("chapters/intro.dcz")
@import("chapters/methodology.dcz")
@import("chapters/results.dcz")
@end

---

@heading(level=2) 6. Directives Overview

@table
Directive | Purpose
@meta | Document metadata
@heading | Section headings
@import | Include other files
@style | Inline styling
@style-def | Global styles
@code | Code blocks
@data | Structured datasets
@math | Math notation
@plot | Data/function plots
@graph | Graphs/DAGs
@image | Embed images
@video | Embed videos
@audio | Embed audio
@pdf | Embed PDFs
@embed | Interactive content
@logic | Client-side behavior
@end

---

@heading(level=2) 7. Syntax Rules
Docz syntax is explicit, minimal, and consistent.

@heading(level=3) Inline Directives
- Single-line usage.
- No @end required.
- Examples: @heading, @image, @video, @audio.

@code(language="text")
@heading(level=2) Introduction
@image(src="diagram.png")
@end

@heading(level=3) Block Directives
- Multi-line content.
- Must close with @end.
- Examples: @code, @style, @style-def, @logic, @math, @plot, @graph, @embed.

@code(language="text")
@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end
@end

@heading(level=3) Attribute Syntax
- Use key=value format.
- Quotes optional for simple strings, required for spaces.

Example:
@code(language="text")
@style(font-size=18px, color="dark blue")
@end

@heading(level=3) Nesting Rules
- Block directives cannot be nested unless explicitly supported.
- Example of allowed future nesting: @plot inside @math.

@heading(level=3) Imports
- @import("file.dcz") must appear at the top or inside a composition file.

@heading(level=3) Comments
- Use // for single-line comments.
@code(language="text")
// This is a comment
@end

---

@heading(level=2) 8. Styling System
@heading(level=3) Inline Style
The @style(color=blue, bold) harmonic field @end emerges.

@heading(level=3) Block Style
@style(font-size=18px, font-family="Inter")
This paragraph uses custom styling.
@end

@heading(level=3) Global Styles
@style-def()
heading-level-1: font-size=36px, font-weight=bold, color=#000
body-text: font-family="Inter", line-height=1.6
@end

---

@heading(level=2) 9. Execution Model
@code(language="zig", execute=true)
const nums = [_]i32{1,2,3,4,5};
const sum = @reduce(.Add, nums);
@print(sum);
@end

---

@heading(level=2) 10. Media & Interactivity

@heading(level=3) Static Media
@image(src="figures/diagram.png", width="600px", caption="System Architecture")
@end

@video(src="clips/demo.mp4", width="800px", controls=true)
@end

@audio(src="audio/explanation.wav", controls=true)
@end

@heading(level=3) Dynamic Content
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="800px", height="600px", interactive=true)
@end

@heading(level=3) Lightweight Logic
@image(src="diagram.png", onClick="play('narration')")
@end

@audio(id="narration", src="audio/explanation.wav", controls=false)
@end

@logic()
function play(id) {
    const audio = document.getElementById(id);
    audio.play();
}
@end

@heading(level=3) Advanced Media Options
All media directives support:
- width, height → Size control.
- align → left, center, right.
- responsive=true → Auto-resize.

Example:
@image(src="diagram.png", width="600px", align="center", responsive=true)
@end

@heading(level=4) Zeno Engine Integration
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="900px", height="600px", interactive=true)
@end


---

@heading(level=2) 11. Composition & Imports
@code(language="text")
@import("chapters/intro.dcz")
@import("chapters/methodology.dcz")
@end

---

@heading(level=2) 12. Graph & ZUQL
@graph(type="imports")
nodes:
    - main.dcz
    - intro.dcz
edges:
    - main.dcz -> intro.dcz
@end

ZUQL query example:
@code(language="text")
SELECT docs WHERE tag="math" AND status="draft";
@end

---

@heading(level=2) 13. Plugin System
@code(language="shell")
qz install plugin-zeno
qz install plugin-3d-model
@end

---

@heading(level=2) 14. Architecture
@diagram(type="flow")
Docz (.dcz) → Quartz Parser → WASM Core → SvelteKit UI
@end

---

@heading(level=2) 15. CLI Reference
@table
Command | Description
qz new | Create a new Docz file
qz preview | Live preview
qz build | Export HTML/PDF
qz install | Install plugins
@end

---

@heading(level=2) 16. Examples

@heading(level=3) Math + Plot
@math()
E = mc^2
@end

@plot(type="line")
x: [1,2,3,4,5]
y: [1,4,9,16,25]
@end

---

@heading(level=2) 17. Roadmap
- Real-time collaboration
- AI-assisted formatting
- Plugin marketplace
- Native Quartz: Zig + WebGPU

---

@heading(level=2) 18. Tooling & Extensions
- VSCode Extension: Live preview like Markdown, IntelliSense for Docz directives, auto-formatting & linting powered by the Zig parser (via WASM).
- Quartz Integration: Full interactive editor built on SvelteKit.

---

@heading(level=2) 19. Contributing
- Written in Zig with strict tests
- Extend via plugins

@heading(level=3) Development Workflow
- Parser & CLI written in Zig.
- 100% test coverage on AST parser.
- `.github/` folder includes:
    - Issue & PR templates.
    - CI workflows (build, test, release).
- Run tests:
@code(language="shell")
zig build test
@end
<<<

