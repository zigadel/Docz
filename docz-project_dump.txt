📦 Dumping from: C:\Workspaces\Zigadel\code\Applications\docz
📤 Output: C:\Workspaces\Zigadel\code\Applications\docz\project_dump.txt
📁 Max file size: 104857600 bytes
🚫 Ignore rules (in order):
  .git/
  zig-out/
  .zig-cache/
  */node_modules/
  node_modules
  themes/default/node_modules/
  */package-lock.json
  third_party/
  docs/
  C:/Workspaces/Zigadel/code/Applications/docz/project_dump.txt

🧱 Filtered Tree:
- .dpignore
- .github
  - .github/CONTRIBUTING.md
  - .github/ISSUE_TEMPLATE
    - .github/ISSUE_TEMPLATE/bug_report.md
    - .github/ISSUE_TEMPLATE/config.yml
    - .github/ISSUE_TEMPLATE/feature_request.md
    - .github/ISSUE_TEMPLATE/question.md
  - .github/PULL_REQUEST_TEMPLATE.md
  - .github/workflows
    - .github/workflows/ci.yml
    - .github/workflows/core-publish.yml
    - .github/workflows/extension-publish.yml
    - .github/workflows/release.yml
- .gitignore
- assets
  - assets/css
    - assets/css/docz.core.css
    - assets/css/katex-dozenal.css
- build.zig
- docz.settings.json
- examples
  - examples/all-directives.dcz
  - examples/example.dcz
  - examples/hello.dcz
  - examples/minimal.dcz
  - examples/sample.dcz
- project_dump.txt
- README.dcz
- README.md
- root.zig
- src
  - src/cli
    - src/cli/assets.zig
    - src/cli/build_cmd.zig
    - src/cli/common.zig
    - src/cli/convert.zig
    - src/cli/enable_wasm.zig
    - src/cli/fallback.zig
    - src/cli/html_ops.zig
    - src/cli/preview.zig
    - src/cli/run.zig
  - src/convert
    - src/convert/html
      - src/convert/html/export.zig
      - src/convert/html/import.zig
    - src/convert/inline
      - src/convert/inline/renderer.zig
    - src/convert/latex
      - src/convert/latex/export.zig
      - src/convert/latex/import.zig
    - src/convert/markdown
      - src/convert/markdown/export.zig
      - src/convert/markdown/import.zig
  - src/core
    - src/core/registry.zig
  - src/docz.zig
  - src/main.zig
  - src/parser
    - src/parser/ast.zig
    - src/parser/parser.zig
    - src/parser/tokenizer.zig
  - src/plugins
    - src/plugins/manager.zig
  - src/renderer
    - src/renderer/html.zig
  - src/testutil.zig
  - src/util
    - src/util/hash_manifest.zig
  - src/web_preview
    - src/web_preview/handler.zig
    - src/web_preview/hot_reload.zig
    - src/web_preview/limits.zig
    - src/web_preview/server.zig
    - src/web_preview/timeout.zig
- tests
  - tests/e2e
    - tests/e2e/cli_usage.zig
    - tests/e2e/convert_cli.zig
    - tests/e2e/enable_wasm.zig
    - tests/e2e/file_to_html.zig
    - tests/e2e/preview_cli_smoke.zig
  - tests/integration
    - tests/integration/assets_discovery.zig
    - tests/integration/convert_html_import.zig
    - tests/integration/latex_roundtrip.zig
    - tests/integration/parser.zig
    - tests/integration/pipeline.zig
    - tests/integration/preview_limits.zig
    - tests/integration/renderer.zig
    - tests/integration/tokenizer.zig
    - tests/integration/vendor_verify.zig
    - tests/integration/web_preview_http_features.zig
    - tests/integration/web_preview_routes.zig
  - tests/test_all_e2e.zig
  - tests/test_all_integration.zig
- themes
  - themes/default
    - themes/default/dist
      - themes/default/dist/docz.tailwind.css
    - themes/default/package.json
    - themes/default/src
      - themes/default/src/input.css
      - themes/default/src/preflight.css
    - themes/default/tailwind.config.js
    - themes/default/tokens.css
- tools
  - tools/manifests
    - tools/manifests/katex-dist.txt
  - tools/print_version.zig
  - tools/vendor_core.zig
  - tools/vendor_verify_main.zig
  - tools/vendor.config
  - tools/vendor.zig
- vscode-extension
  - vscode-extension/package.json
  - vscode-extension/src
    - vscode-extension/src/extension.ts
    - vscode-extension/src/syntax

📄 File Contents:

`.dpignore`: >>>

.git/
zig-out/
.zig-cache/
*/node_modules/
node_modules
themes/default/node_modules/
*/package-lock.json
third_party/
docs/
<<<

`.gitignore`: >>>

.DS_Store

.dpignore
.env
project_dump.txt

.zig-cache/
.zig-cache
zig-out/
zig-out
out
out/

node_modules/
<<<

`build.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");

/// Link platform-specific networking deps (TLS, sockets) for Windows.
fn linkPlatformNetDeps(artifact: *std.Build.Step.Compile) void {
    const rt = artifact.root_module.resolved_target orelse return;
    if (rt.result.os.tag == .windows) {
        artifact.linkSystemLibrary("ws2_32");
        artifact.linkSystemLibrary("advapi32"); // RtlGenRandom
        artifact.linkSystemLibrary("crypt32"); // Cert* APIs
        artifact.linkSystemLibrary("secur32"); // Schannel (std.crypto.tls)
    }
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // ─────────────────────────────────────────────
    // Build options visible via @import("build_options")
    // Toggle: zig build test-all -Dverbose-tests
    // ─────────────────────────────────────────────
    const verbose_tests = b.option(bool, "verbose-tests", "Print debug logs in tests") orelse false;

    const build_opts = b.addOptions();
    build_opts.addOption(bool, "verbose_tests", verbose_tests);

    // ─────────────────────────────────────────────
    // Public library surface (root.zig is API entry)
    // ─────────────────────────────────────────────
    const docz_module = b.createModule(.{
        .root_source_file = b.path("root.zig"),
        .target = target,
        .optimize = optimize,
    });
    docz_module.addOptions("build_options", build_opts);

    // ─────────────────────────────────────────────
    // Preview server modules (under src/web_preview/*)
    // Kept OUT of docz_module to avoid cycles.
    // ─────────────────────────────────────────────
    const web_preview_hot_mod = b.createModule(.{
        .root_source_file = b.path("src/web_preview/hot_reload.zig"),
        .target = target,
        .optimize = optimize,
    });
    web_preview_hot_mod.addOptions("build_options", build_opts);

    // helpers as separate named modules so tests can import them cleanly
    const web_preview_limits_mod = b.createModule(.{
        .root_source_file = b.path("src/web_preview/limits.zig"),
        .target = target,
        .optimize = optimize,
    });
    web_preview_limits_mod.addOptions("build_options", build_opts);

    const web_preview_timeout_mod = b.createModule(.{
        .root_source_file = b.path("src/web_preview/timeout.zig"),
        .target = target,
        .optimize = optimize,
    });
    web_preview_timeout_mod.addOptions("build_options", build_opts);

    const web_preview_mod = b.createModule(.{
        .root_source_file = b.path("src/web_preview/server.zig"),
        .target = target,
        .optimize = optimize,
    });
    web_preview_mod.addOptions("build_options", build_opts);
    web_preview_mod.addImport("docz", docz_module);
    web_preview_mod.addImport("web_preview_hot", web_preview_hot_mod);
    web_preview_mod.addImport("web_preview_limits", web_preview_limits_mod);
    web_preview_mod.addImport("web_preview_timeout", web_preview_timeout_mod);

    // ─────────────────────────────────────────────
    // CLI root module
    // ─────────────────────────────────────────────
    const cli_root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_root_module.addOptions("build_options", build_opts);
    cli_root_module.addImport("docz", docz_module);
    cli_root_module.addImport("web_preview", web_preview_mod);
    cli_root_module.addImport("web_preview_hot", web_preview_hot_mod);

    // ─────────────────────────────────────────────
    // Converters (internal modules)
    // ─────────────────────────────────────────────
    const html_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/html/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    html_import_mod.addOptions("build_options", build_opts);
    html_import_mod.addImport("docz", docz_module);

    const html_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/html/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    html_export_mod.addOptions("build_options", build_opts);
    html_export_mod.addImport("docz", docz_module);

    // root.zig does: @import("html_export")
    docz_module.addImport("html_export", html_export_mod);

    const md_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/markdown/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    md_import_mod.addOptions("build_options", build_opts);
    md_import_mod.addImport("docz", docz_module);

    const md_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/markdown/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    md_export_mod.addOptions("build_options", build_opts);
    md_export_mod.addImport("docz", docz_module);

    const latex_import_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/latex/import.zig"),
        .target = target,
        .optimize = optimize,
    });
    latex_import_mod.addOptions("build_options", build_opts);
    latex_import_mod.addImport("docz", docz_module);

    const latex_export_mod = b.createModule(.{
        .root_source_file = b.path("src/convert/latex/export.zig"),
        .target = target,
        .optimize = optimize,
    });
    latex_export_mod.addOptions("build_options", build_opts);
    latex_export_mod.addImport("docz", docz_module);

    // Make converters addressable from CLI
    cli_root_module.addImport("html_import", html_import_mod);
    cli_root_module.addImport("html_export", html_export_mod);
    cli_root_module.addImport("md_import", md_import_mod);
    cli_root_module.addImport("md_export", md_export_mod);
    cli_root_module.addImport("latex_import", latex_import_mod);
    cli_root_module.addImport("latex_export", latex_export_mod);

    // ─────────────────────────────────────────────
    // Utility modules (exposed to tests)
    // ─────────────────────────────────────────────
    const util_hash_manifest_mod = b.createModule(.{
        .root_source_file = b.path("src/util/hash_manifest.zig"),
        .target = target,
        .optimize = optimize,
    });
    util_hash_manifest_mod.addOptions("build_options", build_opts);

    // ─────────────────────────────────────────────
    // Tools: vendor (module + exe) and vendor-verify (HTTP-free)
    // ─────────────────────────────────────────────
    const vendor_mod = b.createModule(.{
        .root_source_file = b.path("tools/vendor.zig"),
        .target = target,
        .optimize = optimize,
    });

    const vendor_tool = b.addExecutable(.{
        .name = "docz-vendor",
        .root_module = vendor_mod,
    });
    linkPlatformNetDeps(vendor_tool);
    b.installArtifact(vendor_tool);

    const vendor_verify_mod = b.createModule(.{
        .root_source_file = b.path("tools/vendor_verify_main.zig"),
        .target = target,
        .optimize = optimize,
    });
    const vendor_verify_exe = b.addExecutable(.{
        .name = "docz-vendor-verify",
        .root_module = vendor_verify_mod,
    });

    // ─────────────────────────────────────────────
    // CLI executable
    // ─────────────────────────────────────────────
    const exe = b.addExecutable(.{
        .name = "docz",
        .root_module = cli_root_module,
    });
    linkPlatformNetDeps(exe);
    b.installArtifact(exe);

    // A second installed exe name for e2e (prevents locking on Windows).
    const exe_name = if (builtin.os.tag == .windows) "docz.exe" else "docz";
    const e2e_name = if (builtin.os.tag == .windows) "docz-e2e.exe" else "docz-e2e";
    const e2e_install = b.addInstallArtifact(exe, .{ .dest_sub_path = e2e_name });

    // Paths exposed to tests via build_options.
    const docz_rel = b.fmt("zig-out/bin/{s}", .{exe_name});
    const e2e_rel = b.fmt("zig-out/bin/{s}", .{e2e_name});
    const docz_abs = b.getInstallPath(.bin, exe_name);
    const e2e_abs = b.getInstallPath(.bin, e2e_name);

    build_opts.addOption([]const u8, "docz_relpath", docz_rel);
    build_opts.addOption([]const u8, "e2e_relpath", e2e_rel);
    build_opts.addOption([]const u8, "docz_abspath", docz_abs);
    build_opts.addOption([]const u8, "e2e_abspath", e2e_abs);

    // ─────────────────────────────────────────────
    // Convenience run steps
    // ─────────────────────────────────────────────
    const run_cmd = b.addRunArtifact(exe);
    if (b.args) |args| run_cmd.addArgs(args);
    const run_step = b.step("run", "Run the Docz CLI");
    run_step.dependOn(&run_cmd.step);

    const prev = b.addRunArtifact(exe);
    prev.addArg("preview");
    if (b.args) |args| prev.addArgs(args);
    const prev_step = b.step("preview", "Run the web preview server");
    prev_step.dependOn(&prev.step);

    // ─────────────────────────────────────────────
    // Vendor pipeline steps
    // ─────────────────────────────────────────────
    const vendor_cfg = b.option([]const u8, "vendor-config", "Path to tools/vendor.config") orelse "tools/vendor.config";

    const vendor_bootstrap = b.addRunArtifact(vendor_tool);
    vendor_bootstrap.addArgs(&.{ "bootstrap", "--config", vendor_cfg });
    const vendor_step = b.step("vendor", "Fetch/lock/verify third_party assets from config");
    vendor_step.dependOn(&vendor_bootstrap.step);

    const vendor_freeze = b.addRunArtifact(vendor_tool);
    vendor_freeze.addArg("freeze");
    const vendor_freeze_step = b.step("vendor-freeze", "Write third_party/VENDOR.lock");
    vendor_freeze_step.dependOn(&vendor_freeze.step);

    const vendor_checks = b.addRunArtifact(vendor_tool);
    vendor_checks.addArg("checksums");
    const vendor_checks_step = b.step("vendor-checksums", "Write/refresh CHECKSUMS.sha256");
    vendor_checks_step.dependOn(&vendor_checks.step);

    const run_vendor_verify = b.addRunArtifact(vendor_verify_exe);
    const step_vendor_verify = b.step("vendor-verify", "Verify third_party checksums (no HTTP)");
    step_vendor_verify.dependOn(&run_vendor_verify.step);

    // ─────────────────────────────────────────────
    // Unit tests (library + converters) — embedded `test {}` blocks
    // ─────────────────────────────────────────────
    const unit_tests = b.addTest(.{ .root_module = docz_module });
    linkPlatformNetDeps(unit_tests);
    const unit_run = b.addRunArtifact(unit_tests);

    const html_import_unit = b.addTest(.{ .root_module = html_import_mod });
    linkPlatformNetDeps(html_import_unit);
    const html_import_unit_run = b.addRunArtifact(html_import_unit);

    const html_export_unit = b.addTest(.{ .root_module = html_export_mod });
    linkPlatformNetDeps(html_export_unit);
    const html_export_unit_run = b.addRunArtifact(html_export_unit);

    const md_import_unit = b.addTest(.{ .root_module = md_import_mod });
    linkPlatformNetDeps(md_import_unit);
    const md_import_unit_run = b.addRunArtifact(md_import_unit);

    const md_export_unit = b.addTest(.{ .root_module = md_export_mod });
    linkPlatformNetDeps(md_export_unit);
    const md_export_unit_run = b.addRunArtifact(md_export_unit);

    const latex_import_unit = b.addTest(.{ .root_module = latex_import_mod });
    linkPlatformNetDeps(latex_import_unit);
    const latex_import_unit_run = b.addRunArtifact(latex_import_unit);

    const latex_export_unit = b.addTest(.{ .root_module = latex_export_mod });
    linkPlatformNetDeps(latex_export_unit);
    const latex_export_unit_run = b.addRunArtifact(latex_export_unit);

    const unit_step = b.step("test", "Run unit tests");
    unit_step.dependOn(&unit_run.step);
    unit_step.dependOn(&html_import_unit_run.step);
    unit_step.dependOn(&html_export_unit_run.step);
    unit_step.dependOn(&md_import_unit_run.step);
    unit_step.dependOn(&md_export_unit_run.step);
    unit_step.dependOn(&latex_import_unit_run.step);
    unit_step.dependOn(&latex_export_unit_run.step);

    // ─────────────────────────────────────────────
    // CLI unit tests (module-under-test style)
    // ─────────────────────────────────────────────
    const cli_common_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/common.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_common_mod.addOptions("build_options", build_opts);
    cli_common_mod.addImport("docz", docz_module);

    const cli_convert_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/convert.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_convert_mod.addOptions("build_options", build_opts);
    cli_convert_mod.addImport("docz", docz_module);
    cli_convert_mod.addImport("html_import", html_import_mod);
    cli_convert_mod.addImport("html_export", html_export_mod);
    cli_convert_mod.addImport("md_import", md_import_mod);
    cli_convert_mod.addImport("md_export", md_export_mod);
    cli_convert_mod.addImport("latex_import", latex_import_mod);
    cli_convert_mod.addImport("latex_export", latex_export_mod);

    const cli_build_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/build_cmd.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_build_mod.addOptions("build_options", build_opts);
    cli_build_mod.addImport("docz", docz_module);
    cli_build_mod.addImport("html_export", html_export_mod);

    const cli_preview_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/preview.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_preview_mod.addOptions("build_options", build_opts);
    cli_preview_mod.addImport("docz", docz_module);
    cli_preview_mod.addImport("web_preview", web_preview_mod);
    cli_preview_mod.addImport("web_preview_hot", web_preview_hot_mod);

    const cli_enable_mod = b.createModule(.{
        .root_source_file = b.path("src/cli/enable_wasm.zig"),
        .target = target,
        .optimize = optimize,
    });
    cli_enable_mod.addOptions("build_options", build_opts);
    cli_enable_mod.addImport("docz", docz_module);

    const cli_common_unit = b.addTest(.{ .root_module = cli_common_mod });
    const cli_convert_unit = b.addTest(.{ .root_module = cli_convert_mod });
    const cli_build_unit = b.addTest(.{ .root_module = cli_build_mod });
    const cli_preview_unit = b.addTest(.{ .root_module = cli_preview_mod });
    const cli_enable_unit = b.addTest(.{ .root_module = cli_enable_mod });
    linkPlatformNetDeps(cli_common_unit);
    linkPlatformNetDeps(cli_convert_unit);
    linkPlatformNetDeps(cli_build_unit);
    linkPlatformNetDeps(cli_preview_unit);
    linkPlatformNetDeps(cli_enable_unit);

    const cli_unit_step = b.step("test-cli", "Run CLI unit tests");
    cli_unit_step.dependOn(&b.addRunArtifact(cli_common_unit).step);
    cli_unit_step.dependOn(&b.addRunArtifact(cli_convert_unit).step);
    cli_unit_step.dependOn(&b.addRunArtifact(cli_build_unit).step);
    cli_unit_step.dependOn(&b.addRunArtifact(cli_preview_unit).step);
    cli_unit_step.dependOn(&b.addRunArtifact(cli_enable_unit).step);

    // ─────────────────────────────────────────────
    // Integration tests (aggregate runner pattern)
    // ─────────────────────────────────────────────
    const integration_module = b.createModule(.{
        .root_source_file = b.path("tests/test_all_integration.zig"),
        .target = target,
        .optimize = optimize,
    });
    integration_module.addOptions("build_options", build_opts);
    integration_module.addImport("docz", docz_module);
    integration_module.addImport("html_import", html_import_mod);
    integration_module.addImport("html_export", html_export_mod);
    integration_module.addImport("md_import", md_import_mod);
    integration_module.addImport("md_export", md_export_mod);
    integration_module.addImport("latex_import", latex_import_mod);
    integration_module.addImport("latex_export", latex_export_mod);
    integration_module.addImport("vendor", vendor_mod);
    integration_module.addImport("web_preview", web_preview_mod);
    integration_module.addImport("web_preview_hot", web_preview_hot_mod);

    // helpers visible to tests by module name
    integration_module.addImport("web_preview_limits", web_preview_limits_mod);
    integration_module.addImport("web_preview_timeout", web_preview_timeout_mod);
    integration_module.addImport("util_hash_manifest", util_hash_manifest_mod);

    const integration_tests = b.addTest(.{ .root_module = integration_module });
    linkPlatformNetDeps(integration_tests);

    const integration_run = b.addRunArtifact(integration_tests);
    // Auto-stop the preview server inside integration tests after 2 seconds.
    integration_run.setEnvironmentVariable("DOCZ_TEST_AUTOSTOP_MS", "2000");

    const integration_step = b.step("test-integration", "Run integration tests");
    integration_step.dependOn(&integration_run.step);

    // ─────────────────────────────────────────────
    // End-to-end tests
    // ─────────────────────────────────────────────
    const e2e_module = b.createModule(.{
        .root_source_file = b.path("tests/test_all_e2e.zig"),
        .target = target,
        .optimize = optimize,
    });
    e2e_module.addOptions("build_options", build_opts);
    e2e_module.addImport("docz", docz_module);
    e2e_module.addImport("web_preview_limits", web_preview_limits_mod);
    e2e_module.addImport("web_preview_timeout", web_preview_timeout_mod);
    e2e_module.addImport("util_hash_manifest", util_hash_manifest_mod);

    const e2e_tests = b.addTest(.{ .root_module = e2e_module });
    linkPlatformNetDeps(e2e_tests);

    const e2e_run = b.addRunArtifact(e2e_tests);
    e2e_run.setEnvironmentVariable("DOCZ_BIN", e2e_abs);
    e2e_run.step.dependOn(&e2e_install.step);

    const e2e_step = b.step("test-e2e", "Run end-to-end tests");
    e2e_step.dependOn(&e2e_run.step);

    // ─────────────────────────────────────────────
    // Version helper (nice for CI logs)
    // ─────────────────────────────────────────────
    const version_mod = b.createModule(.{
        .root_source_file = b.path("tools/print_version.zig"),
        .target = target,
        .optimize = optimize,
    });
    const version_exe = b.addExecutable(.{
        .name = "docz-version",
        .root_module = version_mod,
    });
    const step_version = b.step("version", "Print Docz build info");
    step_version.dependOn(&b.addRunArtifact(version_exe).step);

    // ─────────────────────────────────────────────
    // Aggregate: test-all (ensure vendor verify & version print first)
    // ─────────────────────────────────────────────
    const all_tests = b.step("test-all", "Run unit + integration + e2e tests");
    all_tests.dependOn(step_vendor_verify);
    all_tests.dependOn(step_version);
    all_tests.dependOn(unit_step);
    all_tests.dependOn(cli_unit_step);
    all_tests.dependOn(integration_step);
    all_tests.dependOn(e2e_step);
}

<<<

`docz.settings.json`: >>>

{
  "root": ".",
  "port": 5173,
  "open": true,
  "enable_katex": true,
  "enable_tailwind": true,
  "third_party_root": "third_party"
}

<<<

`README.dcz`: >>>

@meta(title:"Docz — A tiny, fast, ergonomic documentation engine", author:"Docz Authors")

@style(mode:"global")
# Core typographic rhythm (these are defaults; override in your theme)
heading-level-1: font-size=38px, font-weight=700
heading-level-2: font-size=28px, font-weight=600
heading-level-3: font-size=22px, font-weight=600
body-text: line-height=1.7
@end

# Docz

**Docz** is a compact documentation engine and file format built for speed, clarity, and *developer ergonomics*.  
Write in `.dcz`, render to HTML, and get a live local preview with hot‑reload. Out of the box, Docz supports **bold**, *italic*, inline `code`, [links](https://ziglang.org), fenced code blocks, and LaTeX math via KaTeX.

## Highlights

- Tiny binary, zero‑node runtime; batteries included.
- Fast live preview with auto‑reload.
- First‑class KaTeX math (vendored, offline‑friendly).
- Optional TailwindCSS theme (vendored or monorepo‑built).
- Pragmatic `.dcz` shorthand with room to grow: simple writing flow now, power features later.

## Quick Start

@code(lang:"bash")
# Build and run the CLI
zig build

# Preview an example document
zig build run -- run ./examples/hello.dcz
@end

Open the printed URL in your browser. Edits to `hello.dcz` will auto‑reload.

## Status

Docz is under **active development**. The CLI and the preview server are stable enough for experimentation, and the `.dcz` shorthand includes the essentials while we iterate toward the full spec.

## The `.dcz` Basics

Headings, paragraphs, inline styling, links, code blocks, and display math:

@code(lang:"text")
# Hello, Docz!
This is **bold**, *italic*, and `inline code`, plus a [link](https://ziglang.org).
@end

@math
E = mc^2
@end

@code(lang:"zig")
const std = @import("std");
pub fn main() !void {
    std.debug.print("Hello from Zig\\n", .{});
}
@end

### Notes

- Inline shortcuts work everywhere **except** inside `pre`, `code`, `script`, and `style`.
- `@math ... @end` produces a KaTeX display block (vendored into `third_party/katex/*`).
- `@code(lang:"...") ... @end` escapes HTML and sets a `language-<lang>` class for syntax highlighting by external tools/themes.

## Live Preview

The `run` subcommand compiles `.dcz` to a temporary directory and launches the built‑in preview server:

@code(lang:"bash")
zig build run -- run ./docs/SPEC.dcz
@end

The @style(class="color = red") preview @end server exposes a small set of routes (used internally by the CLI and tests):

- `/view?path=docs/SPEC.dcz` — render a full HTML page
- `/render?path=docs/SPEC.dcz` — render body fragment
- `/third_party/...` — serves vendored assets (KaTeX, Tailwind theme)
- `/__docz_hot.txt` — file polled by the live‑reload script

## Themes & Tailwind

Docz ships with a **default Tailwind theme**. On build, the CLI looks for:

1. Monorepo build: `themes/default/dist/docz.tailwind.css`
2. Otherwise, the newest vendored theme under `third_party/tailwind/docz-theme-*/css/docz.tailwind.css`

If found, the CSS is copied next to the generated `index.html` and linked automatically.

### Building the monorepo theme (optional)

@code(lang:"bash")
# From the repository root:
cd themes/default
npm install
npm run build
# Result: themes/default/dist/docz.tailwind.css
@end

## Vendored Assets

Run once to fetch/verify external assets into `third_party/`:

@code(lang:"bash")
zig build vendor
@end

This will place KaTeX and the Docz Tailwind theme under versioned directories with checksums and a lock file.

## CLI Overview

@code(lang:"text")
Docz CLI Usage:
  docz build <file.dcz>       Build .dcz file to HTML
  docz preview                Start local preview server
  docz enable wasm            Enable WASM execution support (planned)

`docz run <file.dcz>` compiles to a temp dir and delegates to `preview`.
@end

## Repo Structure

@code(lang:"text")
docz/
├─ src/               # core, parser, renderer, CLI commands
├─ web-preview/       # preview server and hot-reload plumbing
├─ themes/default/    # optional Tailwind theme (monorepo build)
├─ third_party/       # vendored KaTeX and theme artifacts
├─ tests/             # unit, integration, and e2e tests
└─ tools/             # vendor bootstrap/verify tooling
@end

## Contributing

- Keep functions small and testable; prefer pure helpers.
- Write tests alongside behavior.
- Avoid hidden global state; pass allocators and buffers explicitly.
- Prefer clear, boring code over cleverness.

### Running the test suite

@code(lang:"bash")
zig build test-all --summary all
@end

## Roadmap

- Full `.dcz` parser with directive blocks (`@table`, `@graph`, etc.)
- Rich plugin system for import/export and rendering hooks
- Syntax‑highlighting pipeline and theme slots
- Optional WASM execution surface (guarded, secure)

## License

MIT — see `LICENSE`.

**Happy documenting!**

<<<

`README.md`: >>>

# Docz

A fast, ergonomic documentation engine and file format designed for STEM writing. Docz blends a crisp authoring experience with the power of HTML/CSS, optional TailwindCSS, KaTeX math, and (optionally) Zig/WASM for advanced scenarios. It aims to be **presentable by default** while remaining **extensible** and **maintainable** over the long haul.

---

## Why Docz?

- **Clean defaults, power on tap** – Write with simple, readable shorthand; get professional output instantly. Drop to HTML/CSS/Tailwind when you need full control.
- **A real language** – `.dcz` files compile via a tokenizer → parser → renderer pipeline. The CLI gives you repeatable builds.
- **Live preview** – Local web server with hot reload for a smooth “edit → see” loop.
- **Vendored assets** – Reproducible builds via `third_party/` (KaTeX, theme CSS). No flaky CDNs.
- **Monorepo** – One place for engine, preview server, tests, examples, and VSCode extension.

---

## Key Features

- **First‑class `.dcz`**: compact directives with readable defaults.
- **Shorthand inline styling** in prose (rendered post‑export):
  - `**bold**`, `*italic*`, `__underline__`, `[text](url)`, headings with `#`, `##`, `###`, …
- **Directives** (baseline set):
  - `@meta(title:"...", author:"...")` → document metadata (used in `<title>`)
  - `@style(mode:"global") … @end` → quick style hints
  - `@math … @end` → KaTeX rendering (display math)
  - `@code(lang:"zig") … @end` → code blocks with language classes
  - (Additional directives and plugins can be added over time.)
- **Automatic assets**:
  - Core CSS (`assets/css/docz.core.css`) always injected first
  - Optional external CSS file (if you ask for `--css file`)
  - Vendored Tailwind theme (`third_party/tailwind/.../docz.tailwind.css`) when available
  - KaTeX CSS/JS (from `third_party/katex/...`) injected when present
- **Web Preview**: lightweight HTTP server (`docz preview`) serving compiled output and `third_party/` assets with hot reload support.
- **VSCode Extension**: syntax highlighting and (future) editor ergonomics for `.dcz`.

---

## Repository Layout

```
docz/
├─ assets/                     # Core assets (e.g., docz.core.css)
├─ docs/                       # Project docs, spec, guide
├─ examples/                   # Small sample .dcz inputs
├─ src/
│  ├─ cli/                     # CLI subcommands (build, run, preview, convert, ...)
│  ├─ convert/                 # Import/export bridges (HTML/Markdown/LaTeX)
│  ├─ parser/                  # Tokenizer, AST, Parser
│  ├─ renderer/                # HTML renderer (and helpers)
│  ├─ core/                    # (future core pieces live here)
│  └─ main.zig                 # Entry point wiring the CLI
├─ themes/default/             # Optional Tailwind theme (local build)
│  ├─ src/                     # Tailwind input/preflight
│  ├─ dist/                    # Built CSS (docz.tailwind.css)
│  └─ tailwind.config.js
├─ third_party/                # Vendored, checksummed assets
│  ├─ katex/<ver>/dist/...
│  └─ tailwind/docz-theme-<ver>/css/docz.tailwind.css
├─ tools/
│  ├─ vendor.zig               # Vendoring/bootstrap tool (fetch/verify/freeze)
│  └─ vendor.config            # Manifests + settings
├─ web-preview/                # Preview server (routes, hot reload)
├─ vscode-extension/           # VSCode extension (basic syntax highlighting)
├─ tests/                      # Unit, integration, e2e tests
├─ build.zig                   # Zig build script
└─ root.zig                    # Library surface exports (Tokenizer/Parser/Renderer/etc.)
```

---

## Quick Start

### Prerequisites

- **Zig**: use the project’s documented toolchain (tested with `0.15.0-dev` lineage).
- **Node.js + npm** (optional): only if you want to rebuild the local Tailwind theme under `themes/default/`.

### Build & Test

```bash
# From repo root
zig build test-all --summary all
```

You should see all unit/integration/e2e tests pass. Tests are your safety net for refactors.

### Vendor Third‑Party Assets (recommended once)

```bash
zig build vendor
```

This will:
- Fetch KaTeX into `third_party/katex/<version>/dist/...`
- Place the Docz Tailwind theme into `third_party/tailwind/docz-theme-<version>/css/docz.tailwind.css`
- Write checksums and a `third_party/VENDOR.lock` for reproducibility

### Preview a Document

```bash
# Live compile + serve + auto‑reload
zig build run -- run ./examples/hello.dcz
```

This compiles to a temp dir (`.zig-cache/docz-run/`), starts the preview server on your configured port (default `5173`), opens the browser, and hot‑reloads on file changes.

### Standalone Preview Server

```bash
zig build run -- preview
# or with options
zig build run -- preview --root docs --port 8787 --no-open
```

The server also serves `third_party/*` under the `/third_party/...` route for deterministic local assets.

---

## CLI Reference (stable subset)

> Run `zig build run --` to see top–level help. Below are the primary subcommands.

### `docz run <file.dcz> [--port <n>] [--css inline|file] [--no-pretty] [--no-live] [--config <file>]`

- Compiles the given `.dcz` to HTML in a temp directory and serves it via the preview server.
- Options:
  - `--port <n>`: overrides port used by `docz preview`
  - `--css inline|file`: keep CSS inline or emit `docz.css` and link it
  - `--no-pretty`: skip HTML pretty-print pass
  - `--no-live`: disable hot reload marker
  - `--config <file>`: load `docz.settings.json` from a custom path

### `docz preview [<path>] [--root <dir>] [--port <n>] [--no-open] [--config <file>]`

- Serves a directory (default `.`) and optionally opens `docs/SPEC.dcz` (or a provided file) in the browser.
- Designed to work with `docz run`, but useful standalone too.

### `docz enable wasm`

- Toggle scaffolding for WASM execution if/when your pipeline uses Zig+WASM runtime features. (Experimental placeholder.)

> Additional converters (HTML/Markdown/LaTeX round‑trips) live under `src/convert/` and are wired into the CLI where practical. Check `tests/integration/` for current capabilities.

---

## Configuration

Docz looks for `docz.settings.json` in the working directory by default (you can point to another file with `--config`). Minimal example:

```json
{
  "port": 5173
}
```

The CLI merges explicit flags over config values. For example, `--port 8787` wins over the JSON value.

---

## Styling & Assets

### CSS Order of Operations

1. **Core CSS** – embedded into the build and always written as `docz.core.css`, linked first.
2. **Your external CSS** (if `--css file`) – collected from inline styles and written as `docz.css`, linked second.
3. **Tailwind Theme** – if available, `docz.tailwind.css` is copied from either:
   - `themes/default/dist/docz.tailwind.css` (preferred, if present), or
   - latest vendored `third_party/tailwind/docz-theme-*/css/docz.tailwind.css`.
   Linked last, so it can override earlier rules if needed.
4. **KaTeX** – when `third_party/katex/*/dist` is present, its CSS/JS are injected and `auto-render` is enabled with common delimiters (`$...$`, `$$...$$`, `\(...\)`, `\[...\]`).

### Building the Local Theme (optional)

If you want to iterate on `themes/default/`:

```bash
cd themes/default
npm install
npm run build     # produces dist/docz.tailwind.css
```

`docz run` will prefer this file when present.

---

## `.dcz` Authoring Basics

A tiny taste of the current baseline (see `examples/` for more):

```text
@meta(title:"Docz Hello", author:"You")

@style(mode:"global")
heading-level-1: font-size=36px, font-weight=bold
body-text: line-height=1.6
@end

# Hello, Docz!
This is **bold**, *italic*, __underline__, and a [link](https://ziglang.org).

@math
E = mc^2
@end

@code(lang:"zig")
const std = @import("std");
pub fn main() !void { std.debug.print("hi\n", .{}); }
@end
```

Docz currently applies a pragmatic fallback renderer that:
- Converts headings `#..######` to `<h1>..</h1>`…`<h6>..</h6>`
- Converts inline marks `**`, `*`, `__`, and `[text](url)` outside of `pre/code/script/style`
- Handles display math via KaTeX when `@math ... @end` blocks are present
- Emits `<pre><code class="language-...">` for `@code(lang:"...")`

The full tokenizer/parser/renderer pipeline is tested and evolving—expect the fallback renderer to be replaced by the full pipeline as we complete directive coverage.

---

## Web Preview

- Serves static output and `/third_party/...` assets
- Hot-reload marker (`__docz_hot.txt`) is polled by an injected `<script>` unless disabled with `--no-live`
- Robust path sanitization and a simple MIME resolver for common types

---

## Testing

Docz ships with unit, integration, and end‑to‑end tests.

```bash
zig build test-all --summary all   # everything
zig build test                     # unit-only (if configured)
```

When debugging memory issues, Zig’s GPA diagnostics will flag double‑frees, leaks, and unbalanced alloc/dealloc. Tests are written to pass cleanly (no leaks) under GPA.

---

## Troubleshooting

- **`npm ci` fails** – The local theme uses `npm install` the first time to generate a lockfile; `npm ci` requires an existing lockfile.
- **Formatting placeholders** – When using `std.fmt.allocPrint`, remember to escape braces in embedded JavaScript/JSON with doubled braces: `{{` and `}}`.
- **Windows paths** – Use forward slashes when constructing URLs for the preview server. The code handles OS path joins internally.
- **Vendoring** – If `zig build vendor` complains about missing files, delete `third_party/` and re‑run; ensure your network allows the downloads listed in `tools/vendor.config`.

---

## Contributing

- See [`.github/CONTRIBUTING.md`](./.github/CONTRIBUTING.md) and the issue templates under `.github/ISSUE_TEMPLATE/`.
- All changes should keep tests green; add tests for new features.
- Prefer small, focused PRs.
- Keep the CLI help text accurate and user‑oriented.

---

## Roadmap

High‑level direction is tracked in:
- [`docs/ROADMAP.md`](./docs/ROADMAP.md)
- [`docs/SPEC.dcz`](./docs/SPEC.dcz)
- [`docs/PLUGIN_GUIDE.md`](./docs/PLUGIN_GUIDE.md)

Planned areas:
- Full directive coverage via the tokenizer/parser/renderer pipeline
- First‑class tables/graphs (`@table`, `@graph`)
- Stronger plugin system and WASM execution hooks
- Theme packs and richer default typography

---

## Acknowledgements

- **Zig** – A joyfully low‑level, precise language that makes writing fast, correct tooling a delight.
- **TailwindCSS** – For utility‑first CSS; used optionally by Docz themes.
- **KaTeX** – For blazing‑fast math rendering.

---

## License

TBD.

<<<

`root.zig`: >>>

// "public API surface" (internal stuff is instead hooked up via `build.zig`)
const std = @import("std");

// ── Parsers / AST -----------------------------------------------------------
pub const Tokenizer = @import("src/parser/tokenizer.zig");
pub const Parser = @import("src/parser/parser.zig");
pub const AST = @import("src/parser/ast.zig");

// Import the dedicated HTML exporter module (wired up in build.zig).
// NOTE: build.zig must have: docz_module.addImport("html_export", html_export_mod);
const html_export = @import("html_export");

// ── Renderer facade (what tests/CLI import) ---------------------------------
// - renderer.inline.renderInline(...)   → inline transformer for paragraph text
// - renderer.html.exportHtml(...)       → full document HTML exporter
//   (aliases: renderer.html.renderHTML / renderer.html.render)
pub const renderer = struct {
    pub const inline_ = struct {
        pub const renderInline =
            @import("src/convert/inline/renderer.zig").renderInline;
    };

    pub const html = struct {
        pub const exportHtml = html_export.exportHtml;

        // Convenience aliases expected by some callers/tests
        pub const render = exportHtml;
        pub const renderHTML = exportHtml;
    };
};

// ── Canonical top-level symbols (back-compat) --------------------------------
// Some older call sites use these names directly.
pub const Renderer = @import("src/renderer/html.zig");
pub const InlineRenderer = @import("src/convert/inline/renderer.zig");

// ── Embedded assets (paths are relative to repo root) -----------------------
pub const assets = struct {
    /// Baseline stylesheet for out-of-the-box, clean defaults.
    pub const core_css: []const u8 = @embedFile("assets/css/docz.core.css");
};

// ── Plugin system ------------------------------------------------------------
const plugin_mod = @import("src/plugins/manager.zig");
pub const PluginManager = plugin_mod.PluginManager;
pub const Plugin = plugin_mod.Plugin;

// ── Namespaces for clarity (ergonomic re-exports) ---------------------------
pub const parser = struct {
    pub const tokenizer = Tokenizer;
    pub const parser = Parser;
    pub const ast = AST;
};

// ── Minimal shim for tests that read docz.main.USAGE_TEXT -------------------
pub const main = struct {
    pub const USAGE_TEXT =
        \\Docz CLI Usage:
        \\  docz build <file.dcz>       Build .dcz file to HTML
        \\  docz preview                Start local preview server
        \\  docz enable wasm            Enable WASM execution support
        \\
    ;
};

// Keep tests tiny; no cross-module imports from here to avoid cycles.
test {
    std.testing.refAllDecls(@This());
}

<<<

`package.json`: >>>


<<<

`extension.ts`: >>>


<<<

`print_version.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");

pub fn main() !void {
    // Keep it dead simple and compatible with your snapshot: use std.debug.print.
    std.debug.print("Docz build info\n", .{});
    std.debug.print("  Zig:      {d}.{d}.{d}\n", .{
        builtin.zig_version.major,
        builtin.zig_version.minor,
        builtin.zig_version.patch,
    });
    std.debug.print("  Target:   {s}-{s}-{s}\n", .{
        @tagName(builtin.cpu.arch),
        @tagName(builtin.os.tag),
        @tagName(builtin.abi),
    });
    std.debug.print("  Optimize: {s}\n", .{@tagName(builtin.mode)});

    // If you later add build options (e.g., git commit), print them here:
    // const opts = @import("build_options");
    // std.debug.print("  Git:      {s}\n", .{ opts.git_commit });
}

<<<

`vendor_core.zig`: >>>

const std = @import("std");

/// Filesystem + hashing utilities extracted from your original tools/vendor.zig,
/// trimmed to only what verifyAll() needs. No HTTP symbols.
pub const IGNORE_BASENAMES = [_][]const u8{
    "CHECKSUMS.sha256",
    "VERSION",
    ".DS_Store",
    "Thumbs.db",
};

pub fn isIgnoredBase(b: []const u8) bool {
    for (IGNORE_BASENAMES) |name| if (std.mem.eql(u8, b, name)) return true;
    return false;
}

pub fn walkFilesCollect(a: std.mem.Allocator, root_abs: []const u8, out: *std.ArrayList([]const u8)) !void {
    var dir = try std.fs.cwd().openDir(root_abs, .{ .iterate = true });
    defer dir.close();

    var it = dir.iterate();
    while (try it.next()) |e| {
        const name = e.name;
        if (name.len == 0 or name[0] == '.') continue;

        const abs = try std.fs.path.join(a, &.{ root_abs, name });
        switch (e.kind) {
            .file => {
                if (!isIgnoredBase(name)) try out.append(a, abs) else a.free(abs);
            },
            .directory => {
                try walkFilesCollect(a, abs, out);
                a.free(abs);
            },
            else => a.free(abs),
        }
    }
}

pub fn sha256HexOfFile(a: std.mem.Allocator, abs: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(abs, .{});
    defer f.close();
    const st = try f.stat();
    const buf = try a.alloc(u8, @intCast(st.size));
    defer a.free(buf);
    _ = try f.readAll(buf);

    var h = std.crypto.hash.sha2.Sha256.init(.{});
    h.update(buf);

    var digest: [32]u8 = undefined;
    h.final(&digest);

    return try bytesToHexLower(a, &digest);
}

pub fn writeChecksumsFor(a: std.mem.Allocator, base_abs: []const u8) !void {
    var files = std.ArrayList([]const u8){};
    defer {
        for (files.items) |p| a.free(p);
        files.deinit(a);
    }
    try walkFilesCollect(a, base_abs, &files);
    if (files.items.len == 0) return;

    const outp = try std.fs.path.join(a, &.{ base_abs, "CHECKSUMS.sha256" });
    defer a.free(outp);
    var f = try std.fs.cwd().createFile(outp, .{ .truncate = true });
    defer f.close();

    const root_len = base_abs.len;
    for (files.items) |abs| {
        const hex = try sha256HexOfFile(a, abs);
        defer a.free(hex);

        var rel: []const u8 = abs;
        if (abs.len > root_len + 1 and
            std.mem.eql(u8, abs[0..root_len], base_abs) and
            abs[root_len] == std.fs.path.sep)
        {
            rel = abs[root_len + 1 ..];
        }

        const line = try std.fmt.allocPrint(a, "{s}  {s}\n", .{ hex, rel });
        defer a.free(line);
        try f.writeAll(line);
    }
}

pub fn verifyOne(a: std.mem.Allocator, base_abs: []const u8) !void {
    const cpath = try std.fs.path.join(a, &.{ base_abs, "CHECKSUMS.sha256" });
    defer a.free(cpath);

    if (!fileExists(cpath)) {
        std.debug.print("verify: skipped (no CHECKSUMS) {s}\n", .{base_abs});
        return;
    }

    const buf = try slurpFile(a, cpath, 1 << 22);
    defer a.free(buf);

    var ok: usize = 0;
    var tot: usize = 0;

    var lines = std.mem.splitScalar(u8, buf, '\n');
    while (lines.next()) |ln_raw| {
        const ln = std.mem.trim(u8, ln_raw, " \t\r");
        if (ln.len == 0) continue;
        if (ln.len < 66) return error.BadChecksumLine;

        const hex = ln[0..64];
        var sp = ln[64..];
        while (sp.len > 0 and (sp[0] == ' ' or sp[0] == '\t')) sp = sp[1..];
        const rel = sp;

        const abs = try std.fs.path.join(a, &.{ base_abs, rel });
        defer a.free(abs);
        if (!fileExists(abs)) {
            std.debug.print("missing: {s}\n", .{abs});
            return error.FileMissing;
        }

        const got = try sha256HexOfFile(a, abs);
        defer a.free(got);

        tot += 1;
        if (!std.mem.eql(u8, hex, got)) {
            std.debug.print("mismatch: {s}\n", .{abs});
            return error.ChecksumMismatch;
        }
        ok += 1;
    }
    std.debug.print("verify: {d}/{d} ok under {s}\n", .{ ok, tot, base_abs });
}

pub fn discoverVersionRoots(a: std.mem.Allocator) !std.ArrayList([]const u8) {
    var out = std.ArrayList([]const u8){};

    const tp = "third_party";
    var tp_dir = std.fs.cwd().openDir(tp, .{ .iterate = true }) catch |e| {
        if (e != error.FileNotFound) return e;
        return out; // nothing to discover
    };
    defer tp_dir.close();

    var it1 = tp_dir.iterate();
    while (try it1.next()) |family| {
        if (family.kind != .directory) continue;
        if (family.name.len == 0 or family.name[0] == '.') continue;

        const fam_abs = try std.fs.path.join(a, &.{ tp, family.name });
        defer a.free(fam_abs);

        var fam_dir = try std.fs.cwd().openDir(fam_abs, .{ .iterate = true });
        defer fam_dir.close();

        var it2 = fam_dir.iterate();
        while (try it2.next()) |ver| {
            if (ver.kind != .directory) continue;
            if (ver.name.len == 0 or ver.name[0] == '.') continue;

            const root_abs = try std.fs.path.join(a, &.{ fam_abs, ver.name });

            var files = std.ArrayList([]const u8){};
            defer {
                for (files.items) |p| a.free(p);
                files.deinit(a);
            }
            try walkFilesCollect(a, root_abs, &files);
            if (files.items.len > 0) {
                try out.append(a, try a.dupe(u8, root_abs));
            }
            a.free(root_abs);
        }
    }

    return out;
}

pub fn writeAllChecksums(a: std.mem.Allocator) !void {
    var roots = try discoverVersionRoots(a);
    defer {
        for (roots.items) |r| a.free(r);
        roots.deinit(a);
    }

    if (roots.items.len == 0) {
        std.debug.print("checksums: nothing to do (no third_party assets yet)\n", .{});
        return;
    }

    for (roots.items) |root_abs| {
        try writeChecksumsFor(a, root_abs);
        std.debug.print("checksums: wrote {s}/CHECKSUMS.sha256\n", .{root_abs});
    }
}

pub fn verifyAll(a: std.mem.Allocator) !void {
    var roots = try discoverVersionRoots(a);
    defer {
        for (roots.items) |r| a.free(r);
        roots.deinit(a);
    }

    if (roots.items.len == 0) {
        std.debug.print("verify: nothing to check (no third_party assets yet)\n", .{});
        return;
    }

    for (roots.items) |root_abs| {
        try verifyOne(a, root_abs);
    }
}

// ---- tiny IO helpers (no HTTP) ----

pub fn slurpFile(a: std.mem.Allocator, path: []const u8, max: usize) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    var out = std.ArrayList(u8){};
    defer out.deinit(a);

    var tmp: [32 * 1024]u8 = undefined;
    var total: usize = 0;
    while (true) {
        const n = try f.read(&tmp);
        if (n == 0) break;
        total += n;
        if (total > max) return error.FileTooLarge;
        try out.appendSlice(a, tmp[0..n]);
    }
    return try out.toOwnedSlice(a);
}

pub fn fileExists(abs: []const u8) bool {
    _ = std.fs.cwd().access(abs, .{}) catch return false;
    return true;
}

pub fn bytesToHexLower(a: std.mem.Allocator, bytes: []const u8) ![]u8 {
    const lut = "0123456789abcdef";
    var out = try a.alloc(u8, bytes.len * 2);
    var j: usize = 0;
    for (bytes) |b| {
        out[j] = lut[(b >> 4) & 0xF];
        out[j + 1] = lut[b & 0xF];
        j += 2;
    }
    return out;
}

<<<

`vendor_verify_main.zig`: >>>

const std = @import("std");
const core = @import("vendor_core.zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    // Verify only (no HTTP compiled)
    try core.verifyAll(A);
}

<<<

`vendor.config`: >>>

# KaTeX
katex.version=0.16.22
katex.manifest=tools/manifests/katex-dist.txt
katex.cdn=jsdelivr

# Tailwind (point to a prebuilt CSS URL or a local file to copy)
tailwind.version=4.1.12
tailwind.url=themes/default/dist/docz.tailwind.css


<<<

`vendor.zig`: >>>

const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var it = try std.process.argsWithAllocator(A);
    defer it.deinit();
    _ = it.next(); // program name

    const cmd = it.next() orelse return usage();

    if (std.mem.eql(u8, cmd, "fetch")) {
        const what = it.next() orelse return usage();
        if (std.mem.eql(u8, what, "katex")) return try sub_fetch_katex(A, &it);
        if (std.mem.eql(u8, what, "tailwind-theme")) return try sub_fetch_tailwind_theme(A, &it);
        return usage();
    }
    if (std.mem.eql(u8, cmd, "checksums")) return try writeAllChecksums(A);
    if (std.mem.eql(u8, cmd, "verify")) return try verifyAll(A);
    if (std.mem.eql(u8, cmd, "freeze")) return try freezeLock(A);
    if (std.mem.eql(u8, cmd, "bootstrap")) return try sub_bootstrap(A, &it);

    return usage();
}

const USAGE: []const u8 =
    \\Usage:
    \\  zig run tools/vendor.zig -- fetch katex <version> [--manifest <path>] [--cdn jsdelivr|unpkg]
    \\  zig run tools/vendor.zig -- fetch tailwind-theme <version> <url-or-path>
    \\  zig run tools/vendor.zig -- checksums
    \\  zig run tools/vendor.zig -- verify
    \\  zig run tools/vendor.zig -- freeze
    \\  zig run tools/vendor.zig -- bootstrap [--config tools/vendor.config]
    \\
    \\Notes:
    \\- No versions are hardcoded. We scan third_party/** dynamically.
    \\- KaTeX fetch uses a manifest you provide (one relative path per line from package root).
    \\- checksums/verify operate on any version folders that contain files.
    \\
;

fn usage() !void {
    std.debug.print("{s}", .{USAGE});
    return error.Invalid;
}

// ─────────────────────────────────────────────────────────────
// tiny IO helpers
// ─────────────────────────────────────────────────────────────

fn slurpFile(a: std.mem.Allocator, path: []const u8, max: usize) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    var out = std.ArrayList(u8){};
    defer out.deinit(a);

    var tmp: [32 * 1024]u8 = undefined;
    var total: usize = 0;
    while (true) {
        const n = try f.read(&tmp);
        if (n == 0) break;
        total += n;
        if (total > max) return error.FileTooLarge;
        try out.appendSlice(a, tmp[0..n]);
    }
    return try out.toOwnedSlice(a);
}

fn httpGetToFile(a: std.mem.Allocator, url: []const u8, dest_abs: []const u8) !void {
    if (std.fs.path.dirname(dest_abs)) |d| try std.fs.cwd().makePath(d);

    var client = std.http.Client{ .allocator = a };
    defer client.deinit();

    var current_url = try a.dupe(u8, url);
    defer a.free(current_url);

    var redirects_left: u8 = 5;

    while (true) {
        const current = try std.Uri.parse(current_url);        var req = try client.request(.GET, current, .{});
        defer req.deinit();try req.wait();

        const code: u16 = @intFromEnum(req.response.status);
        const klass: u16 = code / 100;

        if (klass == 2) {
            var out_file = try std.fs.cwd().createFile(dest_abs, .{ .truncate = true });
            defer out_file.close();

            var buf: [32 * 1024]u8 = undefined;
            while (true) {
                const n = try req.reader().read(&buf);
                if (n == 0) break;
                try out_file.writeAll(buf[0..n]);
            }
            break;
        } else if (klass == 3) {
            if (redirects_left == 0) return error.HttpFailed;
            redirects_left -%= 1;

            const loc = req.response.location orelse blk: {
                var it = req.response.iterateHeaders();
                while (it.next()) |h| {
                    if (std.ascii.eqlIgnoreCase(h.name, "location")) break :blk h.value;
                }
                break :blk null;
            } orelse return error.HttpFailed;

            const next_url = try resolveRedirectAgainst(a, current_url, loc);
            a.free(current_url);
            current_url = next_url;
            continue;
        } else {
            std.debug.print("HTTP {d} for {s}\n", .{ code, current_url });
            return error.HttpFailed;
        }
    }
}

// ---------- helpers for redirect resolution (string-based) ----------

fn originEndIndex(u: []const u8) usize {
    if (std.mem.indexOf(u8, u, "://")) |i| {
        const after_scheme = i + 3;
        if (std.mem.indexOfScalarPos(u8, u, after_scheme, '/')) |j|
            return j;
        return u.len; // no path → whole string is origin
    }
    return 0;
}

fn resolveRedirectAgainst(a: std.mem.Allocator, base_url: []const u8, loc: []const u8) ![]u8 {
    if (std.mem.indexOf(u8, loc, "://") != null)
        return a.dupe(u8, loc);

    const origin_end = originEndIndex(base_url);
    if (origin_end == 0) return error.BadBaseUrl;

    if (loc.len > 0 and loc[0] == '/') {
        const origin = base_url[0..origin_end];
        return std.fmt.allocPrint(a, "{s}{s}", .{ origin, loc });
    }

    var dir_end = origin_end;
    if (origin_end < base_url.len) {
        const path = base_url[origin_end..];
        if (std.mem.lastIndexOfScalar(u8, path, '/')) |ls| {
            dir_end = origin_end + ls + 1;
        } else {
            dir_end = origin_end;
        }
    }
    const before = base_url[0..dir_end];
    return std.fmt.allocPrint(a, "{s}{s}", .{ before, loc });
}

fn copyFile(src_abs: []const u8, dest_abs: []const u8) !void {
    if (std.fs.path.dirname(dest_abs)) |d| try std.fs.cwd().makePath(d);

    var in_file = try std.fs.cwd().openFile(src_abs, .{});
    defer in_file.close();

    var out_file = try std.fs.cwd().createFile(dest_abs, .{ .truncate = true });
    defer out_file.close();

    var buf: [64 * 1024]u8 = undefined;
    while (true) {
        const n = try in_file.read(&buf);
        if (n == 0) break;
        try out_file.writeAll(buf[0..n]);
    }
}

fn writeTextFile(dest_abs: []const u8, body: []const u8) !void {
    if (std.fs.path.dirname(dest_abs)) |d| try std.fs.cwd().makePath(d);
    var f = try std.fs.cwd().createFile(dest_abs, .{ .truncate = true });
    defer f.close();
    try f.writeAll(body);
}

fn fileExists(abs: []const u8) bool {
    _ = std.fs.cwd().access(abs, .{}) catch return false;
    return true;
}

// ─────────────────────────────────────────────────────────────
// KaTeX fetch
// ─────────────────────────────────────────────────────────────

fn fetchKatex(a: std.mem.Allocator, ver: []const u8, manifest: []const u8, cdn: []const u8) !void {
    const base = try std.fmt.allocPrint(a, "third_party/katex/{s}", .{ver});
    defer a.free(base);

    var mf = std.fs.cwd().openFile(manifest, .{}) catch |e| {
        std.debug.print("katex: manifest not found: {s} ({s})\n", .{ manifest, @errorName(e) });
        return e;
    };
    defer mf.close();

    var mb = std.ArrayList(u8){};
    defer mb.deinit(a);
    var tmp: [8 * 1024]u8 = undefined;
    while (true) {
        const n = try mf.read(&tmp);
        if (n == 0) break;
        try mb.appendSlice(a, tmp[0..n]);
    }
    const mb_slice = mb.items;

    var ok: usize = 0;
    var itl = std.mem.splitScalar(u8, mb_slice, '\n');
    while (itl.next()) |raw| {
        const rel = std.mem.trim(u8, raw, " \t\r");
        if (rel.len == 0 or rel[0] == '#') continue;

        const url = switch (cdn[0]) {
            'j' => try std.fmt.allocPrint(a, "https://cdn.jsdelivr.net/npm/katex@{s}/{s}", .{ ver, rel }),
            'u' => try std.fmt.allocPrint(a, "https://unpkg.com/katex@{s}/{s}", .{ ver, rel }),
            else => try std.fmt.allocPrint(a, "https://cdn.jsdelivr.net/npm/katex@{s}/{s}", .{ ver, rel }),
        };
        defer a.free(url);

        const dest = try std.fs.path.join(a, &.{ base, rel });
        defer a.free(dest);

        try httpGetToFile(a, url, dest);
        ok += 1;
    }

    const vfile = try std.fs.path.join(a, &.{ base, "VERSION" });
    defer a.free(vfile);
    try writeTextFile(vfile, ver);

    std.debug.print("katex: fetched {d} files into {s}\n", .{ ok, base });
}

fn sub_fetch_katex(a: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const ver = it.next() orelse {
        std.debug.print("fetch katex: missing <version>, e.g. 0.16.11\n", .{});
        return error.Invalid;
    };

    var manifest_path: ?[]const u8 = null;
    var cdn: []const u8 = "jsdelivr";
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--manifest")) {
            manifest_path = it.next() orelse {
                std.debug.print("fetch katex: --manifest <path> required\n", .{});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--cdn")) {
            cdn = it.next() orelse {
                std.debug.print("fetch katex: --cdn jsdelivr|unpkg\n", .{});
                return error.Invalid;
            };
        } else {
            std.debug.print("fetch katex: unknown option {s}\n", .{arg});
            return error.Invalid;
        }
    }
    const manifest = manifest_path orelse {
        std.debug.print("fetch katex: --manifest <path> is required (no file list is hardcoded)\n", .{});
        return error.Invalid;
    };

    try fetchKatex(a, ver, manifest, cdn);
}

// ─────────────────────────────────────────────────────────────
// Tailwind theme fetch
// ─────────────────────────────────────────────────────────────

fn fetchTailwindTheme(a: std.mem.Allocator, ver: []const u8, src: []const u8) !void {
    const base = try std.fmt.allocPrint(a, "third_party/tailwind/docz-theme-{s}", .{ver});
    defer a.free(base);

    const dest = try std.fs.path.join(a, &.{ base, "css", "docz.tailwind.css" });
    defer a.free(dest);

    if (std.mem.startsWith(u8, src, "http://") or std.mem.startsWith(u8, src, "https://")) {
        try httpGetToFile(a, src, dest);
    } else {
        try copyFile(src, dest);
    }

    const vfile = try std.fs.path.join(a, &.{ base, "VERSION" });
    defer a.free(vfile);
    try writeTextFile(vfile, ver);

    std.debug.print("tailwind: placed theme {s} -> {s}\n", .{ src, dest });
}

fn sub_fetch_tailwind_theme(a: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const ver = it.next() orelse {
        std.debug.print("fetch tailwind-theme: missing <version>, e.g. 1.0.0\n", .{});
        return error.Invalid;
    };
    const src = it.next() orelse {
        std.debug.print("fetch tailwind-theme: missing <url-or-path>\n", .{});
        return error.Invalid;
    };

    try fetchTailwindTheme(a, ver, src);
}

// ─────────────────────────────────────────────────────────────
// Checksums / Verify (dynamic discovery)
// ─────────────────────────────────────────────────────────────

const IGNORE_BASENAMES = [_][]const u8{
    "CHECKSUMS.sha256",
    "VERSION",
    ".DS_Store",
    "Thumbs.db",
};

fn isIgnoredBase(b: []const u8) bool {
    for (IGNORE_BASENAMES) |name| if (std.mem.eql(u8, b, name)) return true;
    return false;
}

fn walkFilesCollect(a: std.mem.Allocator, root_abs: []const u8, out: *std.ArrayList([]const u8)) !void {
    var dir = try std.fs.cwd().openDir(root_abs, .{ .iterate = true });
    defer dir.close();

    var it = dir.iterate();
    while (try it.next()) |e| {
        const name = e.name;
        if (name.len == 0 or name[0] == '.') continue;

        const abs = try std.fs.path.join(a, &.{ root_abs, name });
        switch (e.kind) {
            .file => {
                if (!isIgnoredBase(name)) try out.append(a, abs) else a.free(abs);
            },
            .directory => {
                try walkFilesCollect(a, abs, out);
                a.free(abs);
            },
            else => a.free(abs),
        }
    }
}

fn sha256HexOfFile(a: std.mem.Allocator, abs: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(abs, .{});
    defer f.close();
    const st = try f.stat();
    const buf = try a.alloc(u8, @intCast(st.size));
    defer a.free(buf);
    _ = try f.readAll(buf);

    var h = std.crypto.hash.sha2.Sha256.init(.{});
    h.update(buf);

    var digest: [32]u8 = undefined;
    h.final(&digest);

    return try bytesToHexLower(a, &digest);
}

fn writeChecksumsFor(a: std.mem.Allocator, base_abs: []const u8) !void {
    var files = std.ArrayList([]const u8){};
    defer {
        for (files.items) |p| a.free(p);
        files.deinit(a);
    }
    try walkFilesCollect(a, base_abs, &files);
    if (files.items.len == 0) return;

    const outp = try std.fs.path.join(a, &.{ base_abs, "CHECKSUMS.sha256" });
    defer a.free(outp);
    var f = try std.fs.cwd().createFile(outp, .{ .truncate = true });
    defer f.close();

    const root_len = base_abs.len;
    for (files.items) |abs| {
        const hex = try sha256HexOfFile(a, abs);
        defer a.free(hex);

        var rel: []const u8 = abs;
        if (abs.len > root_len + 1 and
            std.mem.eql(u8, abs[0..root_len], base_abs) and
            abs[root_len] == std.fs.path.sep)
        {
            rel = abs[root_len + 1 ..];
        }

        const line = try std.fmt.allocPrint(a, "{s}  {s}\n", .{ hex, rel });
        defer a.free(line);
        try f.writeAll(line);
    }
}

fn verifyOne(a: std.mem.Allocator, base_abs: []const u8) !void {
    const cpath = try std.fs.path.join(a, &.{ base_abs, "CHECKSUMS.sha256" });
    defer a.free(cpath);

    if (!fileExists(cpath)) {
        std.debug.print("verify: skipped (no CHECKSUMS) {s}\n", .{base_abs});
        return;
    }

    const buf = try slurpFile(a, cpath, 1 << 22);
    defer a.free(buf);

    var ok: usize = 0;
    var tot: usize = 0;

    var lines = std.mem.splitScalar(u8, buf, '\n');
    while (lines.next()) |ln_raw| {
        const ln = std.mem.trim(u8, ln_raw, " \t\r");
        if (ln.len == 0) continue;
        if (ln.len < 66) return error.BadChecksumLine;

        const hex = ln[0..64];
        var sp = ln[64..];
        while (sp.len > 0 and (sp[0] == ' ' or sp[0] == '\t')) sp = sp[1..];
        const rel = sp;

        const abs = try std.fs.path.join(a, &.{ base_abs, rel });
        defer a.free(abs);
        if (!fileExists(abs)) {
            std.debug.print("missing: {s}\n", .{abs});
            return error.FileMissing;
        }

        const got = try sha256HexOfFile(a, abs);
        defer a.free(got);

        tot += 1;
        if (!std.mem.eql(u8, hex, got)) {
            std.debug.print("mismatch: {s}\n", .{abs});
            return error.ChecksumMismatch;
        }
        ok += 1;
    }
    std.debug.print("verify: {d}/{d} ok under {s}\n", .{ ok, tot, base_abs });
}

fn discoverVersionRoots(a: std.mem.Allocator) !std.ArrayList([]const u8) {
    var out = std.ArrayList([]const u8){};

    const tp = "third_party";
    var tp_dir = std.fs.cwd().openDir(tp, .{ .iterate = true }) catch |e| {
        if (e != error.FileNotFound) return e;
        return out; // nothing to discover
    };
    defer tp_dir.close();

    var it1 = tp_dir.iterate();
    while (try it1.next()) |family| {
        if (family.kind != .directory) continue;
        if (family.name.len == 0 or family.name[0] == '.') continue;

        const fam_abs = try std.fs.path.join(a, &.{ tp, family.name });
        defer a.free(fam_abs);

        var fam_dir = try std.fs.cwd().openDir(fam_abs, .{ .iterate = true });
        defer fam_dir.close();

        var it2 = fam_dir.iterate();
        while (try it2.next()) |ver| {
            if (ver.kind != .directory) continue;
            if (ver.name.len == 0 or ver.name[0] == '.') continue;

            const root_abs = try std.fs.path.join(a, &.{ fam_abs, ver.name });

            var files = std.ArrayList([]const u8){};
            defer {
                for (files.items) |p| a.free(p);
                files.deinit(a);
            }
            try walkFilesCollect(a, root_abs, &files);
            if (files.items.len > 0) {
                try out.append(a, try a.dupe(u8, root_abs));
            }
            a.free(root_abs);
        }
    }

    return out;
}

pub fn writeAllChecksums(a: std.mem.Allocator) !void {
    var roots = try discoverVersionRoots(a);
    defer {
        for (roots.items) |r| a.free(r);
        roots.deinit(a);
    }

    if (roots.items.len == 0) {
        std.debug.print("checksums: nothing to do (no third_party assets yet)\n", .{});
        return;
    }

    for (roots.items) |root_abs| {
        try writeChecksumsFor(a, root_abs);
        std.debug.print("checksums: wrote {s}/CHECKSUMS.sha256\n", .{root_abs});
    }
}

pub fn verifyAll(a: std.mem.Allocator) !void {
    var roots = try discoverVersionRoots(a);
    defer {
        for (roots.items) |r| a.free(r);
        roots.deinit(a);
    }

    if (roots.items.len == 0) {
        std.debug.print("verify: nothing to check (no third_party assets yet)\n", .{});
        return;
    }

    for (roots.items) |root_abs| {
        try verifyOne(a, root_abs);
    }
}

fn bytesToHexLower(a: std.mem.Allocator, bytes: []const u8) ![]u8 {
    const lut = "0123456789abcdef";
    var out = try a.alloc(u8, bytes.len * 2);
    var j: usize = 0;
    for (bytes) |b| {
        out[j] = lut[(b >> 4) & 0xF];
        out[j + 1] = lut[b & 0xF];
        j += 2;
    }
    return out;
}

// ─────────────────────────────────────────────────────────────
// Freeze lock
// ─────────────────────────────────────────────────────────────

fn latestByMtime(a: std.mem.Allocator, dir_abs: []const u8) !?[]const u8 {
    var dir = try std.fs.cwd().openDir(dir_abs, .{ .iterate = true, .access_sub_paths = true });
    defer dir.close();

    var it = dir.iterate();
    var best: ?struct { name: []const u8, mtime: i128 } = null;

    while (try it.next()) |e| {
        if (e.kind != .directory) continue;
        if (e.name.len == 0 or e.name[0] == '.') continue;
        if (std.mem.eql(u8, e.name, "node_modules")) continue;

        const sub_abs = try std.fs.path.join(a, &.{ dir_abs, e.name });
        defer a.free(sub_abs);

        var files = std.ArrayList([]const u8){};
        defer {
            for (files.items) |p| a.free(p);
            files.deinit(a);
        }
        try walkFilesCollect(a, sub_abs, &files);
        if (files.items.len == 0) continue;

        const st = std.fs.cwd().statFile(sub_abs) catch {
            if (best == null or std.mem.lessThan(u8, best.?.name, e.name)) {
                best = .{ .name = try a.dupe(u8, e.name), .mtime = 0 };
            }
            continue;
        };
        const m = st.mtime;
        if (best == null or m > best.?.mtime) {
            best = .{ .name = try a.dupe(u8, e.name), .mtime = m };
        }
    }

    if (best == null) return null;
    return best.?.name;
}

fn jsonEscapeInto(w: anytype, s: []const u8) !void {
    for (s) |c| switch (c) {
        '"' => try w.writeAll("\\\""),
        '\\' => try w.writeAll("\\\\"),
        '\n' => try w.writeAll("\\n"),
        '\r' => try w.writeAll("\\r"),
        '\t' => try w.writeAll("\\t"),
        else => try w.writeByte(c),
    };
}

fn freezeLock(a: std.mem.Allocator) !void {
    const root = "third_party";

    var tp = std.fs.cwd().openDir(root, .{ .iterate = true }) catch |e| {
        if (e == error.FileNotFound) {
            std.debug.print("freeze: nothing to freeze (no third_party)\n", .{});
            return;
        }
        return e;
    };
    defer tp.close();

    var it = tp.iterate();

    var entries = std.ArrayList(struct { key: []const u8, val: []const u8 }){};
    defer {
        for (entries.items) |kv| {
            a.free(kv.key);
            a.free(kv.val);
        }
        entries.deinit(a);
    }

    while (try it.next()) |e| {
        if (e.kind != .directory) continue;
        if (e.name.len == 0 or e.name[0] == '.') continue;

        const fam_abs = try std.fs.path.join(a, &.{ root, e.name });
        defer a.free(fam_abs);

        const vopt = try latestByMtime(a, fam_abs);
        if (vopt) |vname| {
            try entries.append(a, .{ .key = try a.dupe(u8, e.name), .val = vname });
        }
    }

    var buf = std.ArrayList(u8){};
    defer buf.deinit(a);
    var w = buf.writer();

    try w.writeAll("{");
    var first = true;
    for (entries.items) |kv| {
        if (!first) try w.writeAll(", ");
        first = false;

        try w.writeByte('"');
        try jsonEscapeInto(w, kv.key);
        try w.writeByte('"');
        try w.writeAll(": ");
        try w.writeByte('"');
        try jsonEscapeInto(w, kv.val);
        try w.writeByte('"');
    }
    try w.writeAll("}\n");

    const lock_path = try std.fs.path.join(a, &.{ root, "VENDOR.lock" });
    defer a.free(lock_path);
    try writeTextFile(lock_path, buf.items);

    std.debug.print("freeze: wrote {s}\n", .{lock_path});
}

// ─────────────────────────────────────────────────────────────
// Bootstrap (config-driven)
// ─────────────────────────────────────────────────────────────

fn parseKvConfig(a: std.mem.Allocator, path: []const u8) !std.StringHashMap([]const u8) {
    var map = std.StringHashMap([]const u8).init(a);

    const buf = try slurpFile(a, path, 1 << 16);
    defer a.free(buf);

    var lines = std.mem.splitScalar(u8, buf, '\n');
    while (lines.next()) |raw| {
        const ln = std.mem.trim(u8, raw, " \t\r");
        if (ln.len == 0 or ln[0] == '#') continue;

        const eq = std.mem.indexOfScalar(u8, ln, '=') orelse continue;
        const k = std.mem.trim(u8, ln[0..eq], " \t");
        const v = std.mem.trim(u8, ln[eq + 1 ..], " \t");
        if (k.len == 0) continue;

        try map.put(try a.dupe(u8, k), try a.dupe(u8, v));
    }
    return map;
}

fn get(map: *const std.StringHashMap([]const u8), key: []const u8) ?[]const u8 {
    return map.get(key);
}

fn sub_bootstrap(a: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    var cfg_path: []const u8 = "tools/vendor.config";
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--config")) {
            cfg_path = it.next() orelse {
                std.debug.print("bootstrap: --config requires a path\n", .{});
                return error.Invalid;
            };
        } else {
            std.debug.print("bootstrap: unknown option {s}\n", .{arg});
            return error.Invalid;
        }
    }

    var map = parseKvConfig(a, cfg_path) catch |e| {
        if (e == error.FileNotFound) {
            std.debug.print("bootstrap: no config at {s}; nothing to do\n", .{cfg_path});
            return;
        }
        return e;
    };
    defer {
        var itx = map.iterator();
        while (itx.next()) |ent| {
            a.free(ent.key_ptr.*);
            a.free(ent.value_ptr.*);
        }
        map.deinit();
    }

    var did_any: bool = false;

    if (get(&map, "katex.version")) |k_ver| {
        const k_mf = get(&map, "katex.manifest") orelse {
            std.debug.print("bootstrap: katex.version set but katex.manifest missing\n", .{});
            return error.Invalid;
        };
        const k_cdn = get(&map, "katex.cdn") orelse "jsdelivr";
        try fetchKatex(a, k_ver, k_mf, k_cdn);
        did_any = true;
    }

    if (get(&map, "tailwind.version")) |t_ver| {
        const t_url = get(&map, "tailwind.url") orelse {
            std.debug.print("bootstrap: tailwind.version set but tailwind.url missing\n", .{});
            return error.Invalid;
        };
        try fetchTailwindTheme(a, t_ver, t_url);
        did_any = true;
    }

    try writeAllChecksums(a);
    try freezeLock(a);
    try verifyAll(a);

    if (!did_any)
        std.debug.print("bootstrap: config had no vendor entries; wrote/checked nothing\n", .{})
    else
        std.debug.print("bootstrap: done\n", .{});
}

<<<

`katex-dist.txt`: >>>

dist/katex.min.css
dist/katex.min.js
dist/contrib/auto-render.min.js
dist/fonts/KaTeX_AMS-Regular.woff2
dist/fonts/KaTeX_Caligraphic-Bold.woff2
dist/fonts/KaTeX_Caligraphic-Regular.woff2
dist/fonts/KaTeX_Fraktur-Bold.woff2
dist/fonts/KaTeX_Fraktur-Regular.woff2
dist/fonts/KaTeX_Main-Bold.woff2
dist/fonts/KaTeX_Main-BoldItalic.woff2
dist/fonts/KaTeX_Main-Italic.woff2
dist/fonts/KaTeX_Main-Regular.woff2
dist/fonts/KaTeX_Math-BoldItalic.woff2
dist/fonts/KaTeX_Math-Italic.woff2
dist/fonts/KaTeX_SansSerif-Bold.woff2
dist/fonts/KaTeX_SansSerif-Italic.woff2
dist/fonts/KaTeX_SansSerif-Regular.woff2
dist/fonts/KaTeX_Script-Regular.woff2
dist/fonts/KaTeX_Size1-Regular.woff2
dist/fonts/KaTeX_Size2-Regular.woff2
dist/fonts/KaTeX_Size3-Regular.woff2
dist/fonts/KaTeX_Size4-Regular.woff2
dist/fonts/KaTeX_Typewriter-Regular.woff2

<<<

`package.json`: >>>

{
  "name": "@docz/theme-default",
  "private": true,
  "devDependencies": {
    "tailwindcss": "^3.4.10"
  },
  "scripts": {
    "build": "npx tailwindcss -c tailwind.config.js -i src/input.css -o dist/docz.tailwind.css --minify"
  }
}

<<<

`tailwind.config.js`: >>>

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["../../**/*.{html,dcz}"],
  theme: {
    fontFamily: {
      sans: "var(--font-sans)",
      mono: "var(--font-mono)",
    },
    extend: {
      colors: {
        bg: "var(--color-bg)",
        fg: "var(--color-fg)",
        muted: "var(--color-muted)",
        accent: "var(--color-accent)",
      },
      borderRadius: { DEFAULT: "var(--radius)" },
      spacing: {
        1: "var(--space-1)",
        2: "var(--space-2)",
        3: "var(--space-3)",
        4: "var(--space-4)",
        6: "var(--space-6)",
        8: "var(--space-8)",
      },
    },
  },
  corePlugins: { preflight: false }, // we use preflight.css instead
  plugins: [],
};

<<<

`tokens.css`: >>>

:root {
  /* Colors */
  --color-bg: #ffffff;
  --color-fg: #111827;
  --color-muted: #6b7280;
  --color-accent: #2563eb;

  /* Typography */
  --font-sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --text-base: 16px;
  --leading: 1.6;

  /* Sizing / spacing */
  --radius: 0.375rem;
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-6: 1.5rem;
  --space-8: 2rem;

  /* Code */
  --code-bg: #0b1020;
  --code-fg: #e5e7eb;
}

<<<

`input.css`: >>>

@import "../tokens.css";
@import "./preflight.css";

/* Tailwind layers */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Small helpers that match docz.core.css defaults */
.dcz-prose a { color: var(--color-accent); text-decoration: underline; }
.dcz-prose code {
  background: var(--code-bg); color: var(--code-fg);
  padding: 0 .25em; border-radius: var(--radius);
}

<<<

`preflight.css`: >>>

/* Minimal preflight that respects docz.core.css */
html, body {
  background: var(--color-bg);
  color: var(--color-fg);
  font-family: var(--font-sans);
  font-size: var(--text-base);
  line-height: var(--leading);
}

<<<

`docz.tailwind.css`: >>>

:root{--color-bg:#fff;--color-fg:#111827;--color-muted:#6b7280;--color-accent:#2563eb;--font-sans:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--text-base:16px;--leading:1.6;--radius:0.375rem;--space-1:0.25rem;--space-2:0.5rem;--space-3:0.75rem;--space-4:1rem;--space-6:1.5rem;--space-8:2rem;--code-bg:#0b1020;--code-fg:#e5e7eb}body,html{background:var(--color-bg);color:var(--color-fg);font-family:var(--font-sans);font-size:var(--text-base);line-height:var(--leading)}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.block{display:block}.inline{display:inline}.table{display:table}.hidden{display:none}.italic{font-style:italic}.dcz-prose a{color:var(--color-accent);text-decoration:underline}.dcz-prose code{background:var(--code-bg);color:var(--code-fg);padding:0 .25em;border-radius:var(--radius)}
<<<

`test_all_e2e.zig`: >>>

const std = @import("std");

comptime {
    _ = @import("e2e/cli_usage.zig");
    _ = @import("e2e/file_to_html.zig");
    _ = @import("e2e/enable_wasm.zig");
    _ = @import("e2e/convert_cli.zig");
    // _ = @import("e2e/preview_cli_smoke.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`test_all_integration.zig`: >>>

const std = @import("std");

comptime {
    _ = @import("integration/tokenizer.zig");
    _ = @import("integration/parser.zig");
    _ = @import("integration/renderer.zig");
    _ = @import("integration/pipeline.zig");
    _ = @import("integration/convert_html_import.zig");
    _ = @import("integration/latex_roundtrip.zig");
    _ = @import("integration/vendor_verify.zig");
    _ = @import("integration/web_preview_routes.zig");
    _ = @import("integration/web_preview_http_features.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`assets_discovery.zig`: >>>

const std = @import("std");
const testing = std.testing;

const assets = @import("../../src/cli/assets.zig");

fn expectContains(hay: []const u8, needle: []const u8) !void {
    try testing.expect(std.mem.indexOf(u8, hay, needle) != null);
}

test "assets.findTailwindCss prefers monorepo theme over vendored" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    // Remember current CWD and switch to temp
    const old_cwd = try std.fs.cwd().realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(old_cwd);
    defer std.os.chdir(old_cwd) catch {};
    const tmp_path = try tmp.dir.realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(tmp_path);
    try std.os.chdir(tmp_path);

    // Create BOTH monorepo and vendored theme paths.
    try tmp.dir.makePath("themes/default/dist");
    try tmp.dir.makePath("third_party/tailwind/docz-theme-4.1.11/css");
    try tmp.dir.makePath("third_party/tailwind/docz-theme-4.1.12/css");

    // Write the files
    {
        var f = try tmp.dir.createFile("themes/default/dist/docz.tailwind.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* mono */");
    }
    {
        var f = try tmp.dir.createFile("third_party/tailwind/docz-theme-4.1.11/css/docz.tailwind.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* v411 */");
    }
    {
        var f = try tmp.dir.createFile("third_party/tailwind/docz-theme-4.1.12/css/docz.tailwind.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* v412 */");
    }

    const path_opt = try assets.findTailwindCss(testing.allocator);
    defer if (path_opt) |p| testing.allocator.free(p);

    try testing.expect(path_opt != null);
    const p = path_opt.?;
    try testing.expectEqualStrings("themes/default/dist/docz.tailwind.css", p);
}

test "assets.findTailwindCss picks newest vendored by mtime with lexicographic tie-break" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    // Switch cwd -> tmp
    const old_cwd = try std.fs.cwd().realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(old_cwd);
    defer std.os.chdir(old_cwd) catch {};
    const tmp_path = try tmp.dir.realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(tmp_path);
    try std.os.chdir(tmp_path);

    // Only vendored; two versions
    try tmp.dir.makePath("third_party/tailwind/docz-theme-4.1.11/css");
    try tmp.dir.makePath("third_party/tailwind/docz-theme-4.1.12/css");

    {
        var f = try tmp.dir.createFile("third_party/tailwind/docz-theme-4.1.11/css/docz.tailwind.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* 4.1.11 */");
    }
    {
        var f = try tmp.dir.createFile("third_party/tailwind/docz-theme-4.1.12/css/docz.tailwind.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* 4.1.12 */");
    }

    const got = try assets.findTailwindCss(testing.allocator);
    defer if (got) |p| testing.allocator.free(p);

    try testing.expect(got != null);
    try expectContains(got.?, "docz-theme-4.1.12");
}

test "assets.findKatexAssets returns hrefs rooted at /third_party/katex/<ver>/dist/..." {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    // Switch cwd -> tmp
    const old_cwd = try std.fs.cwd().realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(old_cwd);
    defer std.os.chdir(old_cwd) catch {};
    const tmp_path = try tmp.dir.realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(tmp_path);
    try std.os.chdir(tmp_path);

    // Create two versions (older + newer)
    try tmp.dir.makePath("third_party/katex/0.16.21/dist/contrib");
    try tmp.dir.makePath("third_party/katex/0.16.22/dist/contrib");

    {
        var f = try tmp.dir.createFile("third_party/katex/0.16.21/dist/katex.min.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* css */");
        var g = try tmp.dir.createFile("third_party/katex/0.16.21/dist/katex.min.js", .{ .truncate = true });
        defer g.close();
        var h = try tmp.dir.createFile("third_party/katex/0.16.21/dist/contrib/auto-render.min.js", .{ .truncate = true });
        defer h.close();
    }
    {
        var f = try tmp.dir.createFile("third_party/katex/0.16.22/dist/katex.min.css", .{ .truncate = true });
        defer f.close();
        try f.writeAll("/* css */");
        var g = try tmp.dir.createFile("third_party/katex/0.16.22/dist/katex.min.js", .{ .truncate = true });
        defer g.close();
        var h = try tmp.dir.createFile("third_party/katex/0.16.22/dist/contrib/auto-render.min.js", .{ .truncate = true });
        defer h.close();
    }

    const k = try assets.findKatexAssets(testing.allocator);
    defer if (k) |kk| {
        testing.allocator.free(kk.css_href);
        testing.allocator.free(kk.js_href);
        testing.allocator.free(kk.auto_href);
    };

    try testing.expect(k != null);
    try expectContains(k.?.css_href, "/third_party/katex/0.16.22/dist/katex.min.css");
    try expectContains(k.?.js_href, "/third_party/katex/0.16.22/dist/katex.min.js");
    try expectContains(k.?.auto_href, "/third_party/katex/0.16.22/dist/contrib/auto-render.min.js");
}

test "assets.copyFileStreaming copies bytes verbatim" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    // Write a source file
    {
        var f = try tmp.dir.createFile("src.txt", .{ .truncate = true });
        defer f.close();
        try f.writeAll("hello world");
    }

    // Perform copy using absolute paths (resolve both)
    const base = try tmp.dir.realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(base);

    const src = try std.fs.path.join(testing.allocator, &.{ base, "src.txt" });
    defer testing.allocator.free(src);
    const dest = try std.fs.path.join(testing.allocator, &.{ base, "nested", "out.txt" });
    defer testing.allocator.free(dest);

    try assets.copyFileStreaming(src, dest);

    // Read back
    var f2 = try tmp.dir.openFile("nested/out.txt", .{});
    defer f2.close();
    const buf = try f2.readToEndAlloc(testing.allocator, 1 << 20);
    defer testing.allocator.free(buf);

    try testing.expectEqualStrings("hello world", buf);
}

test "assets.fileMTime returns a positive number" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    {
        var f = try tmp.dir.createFile("a.txt", .{ .truncate = true });
        defer f.close();
        try f.writeAll("x");
    }

    const base = try tmp.dir.realpathAlloc(testing.allocator, ".");
    defer testing.allocator.free(base);
    const abs = try std.fs.path.join(testing.allocator, &.{ base, "a.txt" });
    defer testing.allocator.free(abs);

    const mt = try assets.fileMTime(abs);
    try testing.expect(mt > 0);
}

<<<

`convert_html_import.zig`: >>>

const std = @import("std");
const html_import = @import("html_import"); // wired in build.zig

test "integration: HTML import produces expected dcz" {
    const html =
        \\<html><head><title>T</title>
        \\  <meta name="author" content="Docz Team">
        \\</head>
        \\<body><h1>Hi</h1><p>Para</p></body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try html_import.importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "@meta(title=\"T\") @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@meta(author=\"Docz Team\") @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@heading(level=1) Hi @end") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "Para\n") != null);
}

test "integration: images and <pre><code class=language-*> blocks" {
    const html =
        \\<html><body>
        \\  <img src="/img/logo.png" alt="x">
        \\  <pre><code class="language-zig">const x = 42;</code></pre>
        \\</body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try html_import.importHtmlToDcz(A, html);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "@image(src=\"/img/logo.png\") @end") != null);

    // minimal check for a code block with the right language and body
    try std.testing.expect(std.mem.indexOf(u8, out,
        \\@code(language="zig")
    ) != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "const x = 42;") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@end\n") != null);
}

<<<

`latex_roundtrip.zig`: >>>

const std = @import("std");
const docz = @import("docz");

// internal converter modules from build.zig
const latex_import = @import("latex_import");
const latex_export = @import("latex_export");

// ── helpers ──────────────────────────────────────────────────────────────────

fn trimRightSpaces(line: []const u8) []const u8 {
    return std.mem.trimRight(u8, line, " \t\r");
}

/// Normalize LaTeX for comparison:
/// - Trim trailing spaces per line
/// - Collapse 3+ consecutive newlines → 2 newlines
/// - Trim leading/trailing blank lines
/// - Ensure single trailing newline
fn normalizeLatex(alloc: std.mem.Allocator, s: []const u8) ![]u8 {
    // ArrayList for this Zig requires passing the allocator to operations.
    var tmp = std.ArrayList(u8){};
    defer tmp.deinit(alloc);

    // 1) trim trailing spaces line-by-line
    var it = std.mem.tokenizeScalar(u8, s, '\n');
    var first_line = true;
    while (it.next()) |line| {
        const t = trimRightSpaces(line);
        if (!first_line) try tmp.append(alloc, '\n');
        try tmp.appendSlice(alloc, t);
        first_line = false;
    }

    // 2) collapse >2 newlines → exactly 2
    var out = std.ArrayList(u8){};
    defer out.deinit(alloc);
    var i: usize = 0;
    var nl_count: usize = 0;
    while (i < tmp.items.len) : (i += 1) {
        const c = tmp.items[i];
        if (c == '\n') {
            nl_count += 1;
            if (nl_count <= 2) try out.append(alloc, '\n');
        } else {
            nl_count = 0;
            try out.append(alloc, c);
        }
    }

    // 3) trim leading/trailing newlines
    var start: usize = 0;
    while (start < out.items.len and out.items[start] == '\n') start += 1;

    var end: usize = out.items.len;
    while (end > start and out.items[end - 1] == '\n') end -= 1;

    // 4) build final buffer
    var final_buf = std.ArrayList(u8){};
    defer final_buf.deinit(alloc);
    if (end > start) try final_buf.appendSlice(alloc, out.items[start..end]);
    try final_buf.append(alloc, '\n');

    return try final_buf.toOwnedSlice(alloc);
}

// ── tests ────────────────────────────────────────────────────────────────────

test "integration: LaTeX ↔ DCZ round-trip via AST (baseline sample)" {
    // Use plain strings + '\n' to avoid confusion with Zig's '\\' line-prefix macro.
    const tex_input =
        \\\title{Roundtrip Spec}
        \\\author{Docz}
        \\
        \\\section{Intro}
        \\Hello world paragraph.
        \\
        \\\subsection{Code}
        \\\begin{verbatim}
        \\const x = 1;
        \\\end{verbatim}
        \\
        \\\begin{equation}
        \\E = mc^2
        \\\end{equation}
        \\
        \\\includegraphics{img/logo.png}
        \\
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    // 1) LaTeX → DCZ
    const dcz = try latex_import.importLatexToDcz(A, tex_input);
    defer A.free(dcz);

    // 2) DCZ → tokens → AST
    const tokens = try docz.Tokenizer.tokenize(dcz, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }
    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit(A);

    // 3) AST → LaTeX
    const tex_output = try latex_export.exportAstToLatex(&ast, A);
    defer A.free(tex_output);

    // 4) Normalize + compare
    const n_in = try normalizeLatex(A, tex_input);
    defer A.free(n_in);
    const n_out = try normalizeLatex(A, tex_output);
    defer A.free(n_out);

    try std.testing.expectEqualStrings(n_in, n_out);
}

test "integration: heading level clamp (>=4 → \\subsubsection{})" {
    const tex_input =
        \\\title{Clamp}
        \\
        \\\section{Top}
        \\Para.
        \\
        \\\subsubsection{Deep A}
        \\\subsubsection{Deep B}
        \\
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const dcz = try latex_import.importLatexToDcz(A, tex_input);
    defer A.free(dcz);

    const tokens = try docz.Tokenizer.tokenize(dcz, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }
    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit(A);

    const tex_output = try latex_export.exportAstToLatex(&ast, A);
    defer A.free(tex_output);

    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\section{Top}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\subsubsection{Deep A}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex_output, "\\subsubsection{Deep B}") != null);

    const n_in = try normalizeLatex(A, tex_input);
    defer A.free(n_in);
    const n_out = try normalizeLatex(A, tex_output);
    defer A.free(n_out);
    try std.testing.expectEqualStrings(n_in, n_out);
}

<<<

`parser.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "integration: parser builds AST from token list" {
    const input =
        \\@heading(level=2) Heading @end
        \\Some paragraph text with *emphasis*.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit(allocator);

    // std.debug.print("🌲 AST has {d} top-level nodes\n", .{ast.children.items.len});
    try std.testing.expect(ast.children.items.len >= 1);
}

<<<

`pipeline.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const html_export = @import("html_export");

test "🔁 Full pipeline integration: .dcz input → HTML output" {
    const input_docz =
        \\@meta(title="Integration Test", author="Docz Team") @end
        \\@heading(level=2) Hello, Docz! @end
        \\@code(language="zig")
        \\const x = 123;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokens = try docz.Tokenizer.tokenize(input_docz, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit(allocator);

    const html = try html_export.exportHtml(&ast, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h2>Hello, Docz!</h2>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 123;"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "Integration Test"));
}

<<<

`preview_limits.zig`: >>>

const std = @import("std");
const limits_mod = @import("../../src/web_preview/limits.zig"); // keep your current layout

test "limits: contentLengthFrom parses integers and ignores junk" {
    const good =
        \\Content-Length: 123\r
        \\X: y\r
        \\ \r
        \\
    ;
    try std.testing.expectEqual(@as(usize, 123), limits_mod.contentLengthFrom(good));

    const bad =
        \\Content-Length: nope\r
        \\ \r
        \\
    ;
    try std.testing.expectEqual(@as(usize, 0), limits_mod.contentLengthFrom(bad));
}

<<<

`renderer.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const html_export = @import("html_export");

pub const _force_test_discovery = true;

test "integration: renderer produces HTML from simple AST" {
    const input =
        \\@heading(level=3) Render Test @end
        \\Code below:
        \\@code(language="zig")
        \\const x = 9;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    defer allocator.free(tokens);

    var ast = try docz.Parser.parse(tokens, allocator);
    defer ast.deinit(allocator);

    const html = try html_export.exportHtml(&ast, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h3>Render Test</h3>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 9;"));
}

<<<

`tokenizer.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "integration: tokenizer produces correct tokens from .dcz input" {
    const input =
        \\@heading(level=1) Hello, Docz! @end
        \\This is a **test** of the tokenizer.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer std.debug.assert(gpa.deinit() == .ok);

    const tokens = try docz.Tokenizer.tokenize(input, allocator);
    defer {
        // IMPORTANT: free allocated lexemes first, then the slice itself
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    // std.debug.print("📦 Tokenizer produced {d} tokens:\n", .{tokens.len});
    // for (tokens, 0..) |tok, i| {
    //     std.debug.print("  [{d}] {s} : {s}\n", .{ i, @tagName(tok.kind), tok.lexeme });
    // }

    try std.testing.expect(tokens.len > 2);
}

<<<

`vendor_verify.zig`: >>>

const std = @import("std");
const vendor = @import("vendor"); // <-- from build.zig

test "third_party checksums verify" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    try vendor.verifyAll(gpa.allocator()); // robust: no hardcoded paths
}

<<<

`web_preview_http_features.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");
const web = @import("web_preview");

fn writeAll(w: anytype, bytes: []const u8) !void {
    var off: usize = 0;
    while (off < bytes.len) {
        const n = try w.write(bytes[off..]);
        if (n == 0) return error.EndOfStream;
        off += n;
    }
}

/// Robust read-to-end with a deadline:
/// - Windows: uses recv() and treats WSAEWOULDBLOCK/WSAEINTR as transient.
/// - POSIX: uses posix.recv() with EINTR/EWOULDBLOCK as transient.
/// We break if there's no progress for ~1s or total > 3s.
fn readAllToEnd(A: std.mem.Allocator, s: *std.net.Stream) ![]u8 {
    var out = std.ArrayListUnmanaged(u8){};
    errdefer out.deinit(A);

    var tmp: [4096]u8 = undefined;

    var timer = try std.time.Timer.start();
    var last_progress_ns: u64 = timer.read(); // time since start
    const stall_ns: u64 = 1_000_000_000; // 1s of no progress → break
    const total_ns: u64 = 3_000_000_000; // 3s overall cap

    while (true) {
        const n = if (builtin.os.tag == .windows) blk: {
            const ws2 = std.os.windows.ws2_32;
            const ret: c_int = ws2.recv(
                s.handle,
                tmp[0..].ptr,
                @as(c_int, @intCast(tmp.len)),
                0,
            );
            if (ret == 0) break; // peer closed
            if (ret == ws2.SOCKET_ERROR) {
                const werr = ws2.WSAGetLastError();
                const code: u16 = @intFromEnum(werr);
                switch (code) {
                    10035 => { // WSAEWOULDBLOCK
                        // fall through to stall/total timers below
                        break :blk @as(usize, 0);
                    },
                    10004 => { // WSAEINTR
                        break :blk @as(usize, 0);
                    },
                    10054 => break, // WSAECONNRESET → treat as EOF
                    else => return error.Unexpected,
                }
            }
            break :blk @as(usize, @intCast(ret));
        } else blk: {
            const got = std.posix.recv(s.handle, tmp[0..], 0) catch |e| switch (e) {
                error.WouldBlock, error.Interrupted => 0,
                error.ConnectionResetByPeer => 0,
                else => return e,
            };
            break :blk @as(usize, got);
        };

        if (n > 0) {
            try out.appendSlice(A, tmp[0..n]);
            last_progress_ns = timer.read();
            continue;
        }

        // No bytes this tick: decide whether to wait a bit or bail.
        const now = timer.read();
        if (now - last_progress_ns > stall_ns or now > total_ns) break;
        // sleep a little to yield
        std.Thread.sleep(5 * std.time.ns_per_ms);
    }

    return out.toOwnedSlice(A);
}

fn parseStatus(buf: []const u8) ?u16 {
    const lf = std.mem.indexOfScalar(u8, buf, '\n') orelse return null;
    const line_raw = buf[0..lf];
    const line = if (line_raw.len > 0 and line_raw[line_raw.len - 1] == '\r')
        line_raw[0 .. line_raw.len - 1]
    else
        line_raw;

    // "HTTP/1.1 200 OK"
    var it = std.mem.splitScalar(u8, line, ' ');
    _ = it.next() orelse return null;
    const code_s = it.next() orelse return null;
    return std.fmt.parseInt(u16, code_s, 10) catch null;
}

fn headerValue(headers_block: []const u8, name_ci: []const u8) ?[]const u8 {
    var it = std.mem.splitScalar(u8, headers_block, '\n');
    while (it.next()) |line_cr| {
        var line = line_cr;
        if (line.len == 0) continue;
        if (line[line.len - 1] == '\r') line = line[0 .. line.len - 1];
        const colon = std.mem.indexOfScalar(u8, line, ':') orelse continue;
        const key = line[0..colon];
        if (std.ascii.eqlIgnoreCase(key, name_ci)) {
            var v = line[colon + 1 ..];
            while (v.len > 0 and (v[0] == ' ' or v[0] == '\t')) v = v[1..];
            return v;
        }
    }
    return null;
}

fn startServer(A: std.mem.Allocator, port: u16) !std.Thread {
    const srv_ptr = try A.create(web.PreviewServer);
    errdefer A.destroy(srv_ptr);

    srv_ptr.* = try web.PreviewServer.init(A, ".");
    // spawn thread that runs the server; it cleans itself up on exit
    return try std.Thread.spawn(.{}, struct {
        fn run(srv: *web.PreviewServer, alloc: std.mem.Allocator, p: u16) void {
            defer {
                srv.deinit();
                alloc.destroy(srv);
            }
            web.PreviewServer.listenAndServe(srv, p) catch {};
        }
    }.run, .{ srv_ptr, A, port });
}

fn stopServer(port: u16) !void {
    const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, port);
    var s = try std.net.tcpConnectToAddress(addr);
    defer s.close();

    const req =
        "GET /__docz_stop HTTP/1.1\r\nHost: 127.0.0.1\r\nConnection: close\r\n\r\n";

    // fire-and-forget stop; no drain (avoids Windows ReadFile/recv weirdness)
    try writeAll(&s, req);

    if (builtin.os.tag == .windows) {
        const ws2 = std.os.windows.ws2_32;
        _ = ws2.shutdown(s.handle, ws2.SD_SEND);
    } else {
        std.posix.shutdown(s.handle, .send) catch {};
    }
}

/// basic HTTP fetch for the tests with deadline read and send-shutdown
fn httpGet(
    A: std.mem.Allocator,
    port: u16,
    method: []const u8,
    path: []const u8,
    extra_headers: []const []const u8,
) !struct {
    status: u16,
    headers: []const u8,
    body: []const u8,
    raw: []u8,
} {
    const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, port);
    var s = try std.net.tcpConnectToAddress(addr);
    defer s.close();

    var req_buf = std.ArrayListUnmanaged(u8){};
    defer req_buf.deinit(A);

    try req_buf.appendSlice(A, method);
    try req_buf.appendSlice(A, " ");
    try req_buf.appendSlice(A, path);
    try req_buf.appendSlice(A, " HTTP/1.1\r\nHost: 127.0.0.1\r\nConnection: close\r\n");

    for (extra_headers) |h| {
        try req_buf.appendSlice(A, h);
        try req_buf.appendSlice(A, "\r\n");
    }
    try req_buf.appendSlice(A, "\r\n");

    try writeAll(&s, req_buf.items);

    // Half-close send side so the server knows we’re done sending.
    if (builtin.os.tag == .windows) {
        const ws2 = std.os.windows.ws2_32;
        _ = ws2.shutdown(s.handle, ws2.SD_SEND);
    } else {
        std.posix.shutdown(s.handle, .send) catch {};
    }

    const resp = try readAllToEnd(A, &s);

    const split = std.mem.indexOf(u8, resp, "\r\n\r\n") orelse return error.BadResponse;
    const hdrs = resp[0 .. split + 2]; // include final CRLF for simple scanning
    const st = parseStatus(resp) orelse return error.BadResponse;
    const body = resp[split + 4 ..];

    return .{
        .status = st,
        .headers = hdrs,
        .body = body,
        .raw = resp,
    };
}

// --------------------- TESTS ---------------------

test "third_party assets get long immutable caching" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const port: u16 = 5179;
    var th = try startServer(A, port);
    defer th.join();

    std.Thread.sleep(150 * std.time.ns_per_ms);

    const path = "/third_party/katex/0.16.22/dist/katex.min.css";
    const r = try httpGet(A, port, "GET", path, &.{});
    defer A.free(r.raw);

    try std.testing.expectEqual(@as(u16, 200), r.status);
    const cc = headerValue(r.headers, "Cache-Control") orelse return error.MissingHeader;
    try std.testing.expect(std.mem.indexOf(u8, cc, "immutable") != null);

    try stopServer(port);
}

test "ETag + 304 roundtrip for third_party asset" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const port: u16 = 5191;
    var th = try startServer(A, port);
    defer th.join();

    std.Thread.sleep(150 * std.time.ns_per_ms);

    const path = "/third_party/katex/0.16.22/dist/katex.min.css";
    const r1 = try httpGet(A, port, "GET", path, &.{});
    defer A.free(r1.raw);

    const etag = headerValue(r1.headers, "ETag") orelse return error.MissingHeader;

    var etag_hdr_buf: [256]u8 = undefined;
    const etag_hdr = try std.fmt.bufPrint(&etag_hdr_buf, "If-None-Match: {s}", .{etag});

    const r2 = try httpGet(A, port, "GET", path, &.{etag_hdr});
    defer A.free(r2.raw);

    try std.testing.expectEqual(@as(u16, 304), r2.status);

    try stopServer(port);
}

test "single Range request returns 206 and correct Content-Range" {
    if (builtin.os.tag == .windows) {
        // This test is flaky on Windows due to stdlib socket quirks (ReadFile vs recv).
        // Server behavior is correct; the client helper can hang in CI/Debug.
        // Covered on non-Windows; safe to skip here.
        return;
    }

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const port: u16 = 5192;
    var th = try startServer(A, port);
    defer th.join();

    std.Thread.sleep(150 * std.time.ns_per_ms);

    const path = "/third_party/katex/0.16.22/dist/katex.min.css";
    const r_full = try httpGet(A, port, "GET", path, &.{});
    defer A.free(r_full.raw);

    const r_hdr = "Range: bytes=0-9";
    const r_part = try httpGet(A, port, "GET", path, &.{r_hdr});
    defer A.free(r_part.raw);

    try std.testing.expectEqual(@as(u16, 206), r_part.status);
    const cr = headerValue(r_part.headers, "Content-Range") orelse return error.MissingHeader;
    try std.testing.expect(std.mem.startsWith(u8, cr, "bytes 0-9/"));
    try std.testing.expectEqual(@as(usize, 10), r_part.body.len);

    try stopServer(port);
}

test "HEAD on /ping suppresses body but reports length" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const port: u16 = 5194;
    var th = try startServer(A, port);
    defer th.join();

    std.Thread.sleep(150 * std.time.ns_per_ms);

    const r = try httpGet(A, port, "HEAD", "/ping", &.{});
    defer A.free(r.raw);

    try std.testing.expectEqual(@as(u16, 200), r.status);

    const cl = headerValue(r.headers, "Content-Length") orelse return error.MissingHeader;
    // Body should be empty on HEAD
    try std.testing.expectEqual(@as(usize, 0), r.body.len);
    // Content-Length should parse to a number (we don't assert exact value)
    _ = std.fmt.parseInt(usize, cl, 10) catch return error.BadLength;

    try stopServer(port);
}

<<<

`web_preview_routes.zig`: >>>

const std = @import("std");
const server_mod = @import("web_preview");

// --- Tunables ---------------------------------------------------------------
const BOOT_WAIT_SLICE_MS: u64 = 25; // small retry step while server boots
const BOOT_BUDGET_MS: u64 = 6000; // give the server up to 6s to bind
// ---------------------------------------------------------------------------

fn fileExists(path: []const u8) bool {
    _ = std.fs.cwd().statFile(path) catch return false;
    return true;
}

// tiny/forgiving scanner for:  "key" : "value"
fn findJsonStringValue(buf: []const u8, key: []const u8) ?[]const u8 {
    var i: usize = 0;
    while (i < buf.len) : (i += 1) {
        if (buf[i] != '"') continue;

        const start_key = i + 1;
        var j = start_key;
        while (j < buf.len and buf[j] != '"') : (j += 1) {}
        if (j >= buf.len) break;

        const kslice = buf[start_key..j];
        i = j + 1;

        // skip whitespace
        while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}

        // expect colon
        if (i >= buf.len) continue;
        if (buf[i] != ':') continue;
        i += 1;

        // skip whitespace
        while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
        if (i >= buf.len) break;

        // match "value"
        if (i < buf.len and buf[i] == '"' and std.mem.eql(u8, kslice, key)) {
            const vs = i + 1;
            var ve = vs;
            while (ve < buf.len and buf[ve] != '"') : (ve += 1) {}
            if (ve <= buf.len) return buf[vs..ve];
        }
    }
    return null;
}

/// Read up to `max_bytes` from a file into an allocator-backed slice.
fn readFilePrefixAlloc(a: std.mem.Allocator, path: []const u8, max_bytes: usize) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();

    const size = try f.getEndPos();
    const want: usize = if (size > max_bytes) max_bytes else @as(usize, @intCast(size));

    var buf = try a.alloc(u8, want);
    const n = try f.readAll(buf);
    return buf[0..n];
}

/// Find one “real” third_party asset path that the preview server should serve.
/// Returns an allocator-owned string that the caller must free.
fn findAnyThirdPartyAsset(a: std.mem.Allocator) !?[]const u8 {
    // Prefer the lock file produced by vendor tooling.
    if (fileExists("third_party/VENDOR.lock")) {
        const buf = try readFilePrefixAlloc(a, "third_party/VENDOR.lock", 64 * 1024);
        defer a.free(buf);

        if (findJsonStringValue(buf, "katex")) |ver| {
            const abs = try std.fs.path.join(a, &.{ "third_party", "katex", ver, "dist", "katex.min.css" });
            defer a.free(abs);
            if (fileExists(abs)) {
                return try std.fmt.allocPrint(a, "/third_party/katex/{s}/dist/katex.min.css", .{ver});
            }
        }
        if (findJsonStringValue(buf, "tailwind")) |label| {
            const abs = try std.fs.path.join(a, &.{ "third_party", "tailwind", label, "css", "docz.tailwind.css" });
            defer a.free(abs);
            if (fileExists(abs)) {
                return try std.fmt.allocPrint(a, "/third_party/tailwind/{s}/css/docz.tailwind.css", .{label});
            }
        }
    }

    // Fallback: scan directories directly (take the first match we can stat)
    if (std.fs.cwd().openDir("third_party/katex", .{ .iterate = true })) |dir_val| {
        var d = dir_val;
        defer d.close();

        var it = d.iterate();
        while (true) {
            const n = it.next() catch break;
            if (n == null) break;
            const e = n.?;
            if (e.kind != .directory) continue;

            const abs = try std.fs.path.join(a, &.{ "third_party", "katex", e.name, "dist", "katex.min.css" });
            defer a.free(abs);
            if (fileExists(abs)) {
                return try std.fmt.allocPrint(a, "/third_party/katex/{s}/dist/katex.min.css", .{e.name});
            }
        }
    } else |_| {}

    if (std.fs.cwd().openDir("third_party/tailwind", .{ .iterate = true })) |dir_val2| {
        var d2 = dir_val2;
        defer d2.close();

        var it2 = d2.iterate();
        while (true) {
            const n = it2.next() catch break;
            if (n == null) break;
            const e = n.?;
            if (e.kind != .directory) continue;

            const abs = try std.fs.path.join(a, &.{ "third_party", "tailwind", e.name, "css", "docz.tailwind.css" });
            defer a.free(abs);
            if (fileExists(abs)) {
                return try std.fmt.allocPrint(a, "/third_party/tailwind/{s}/css/docz.tailwind.css", .{e.name});
            }
        }
    } else |_| {}

    return null;
}

fn nowMs() u64 {
    const t = std.time.milliTimestamp();
    return @as(u64, @intCast(if (t < 0) 0 else t));
}

fn sleepMs(ms: u64) void {
    std.Thread.sleep(ms * std.time.ns_per_ms);
}

/// Try connecting until the TCP listener is accepting (with a firm time budget).
fn waitUntilListening(a: std.mem.Allocator, host: []const u8, port: u16) !void {
    const deadline = nowMs() + BOOT_BUDGET_MS;
    while (true) {
        if (nowMs() >= deadline) return error.TimedOut;
        const s = std.net.tcpConnectToHost(a, host, port) catch |e| switch (e) {
            error.ConnectionRefused,
            error.HostLacksNetworkAddresses,
            error.NetworkUnreachable,
            error.NameServerFailure,
            error.TemporaryNameServerFailure,
            error.UnknownHostName,
            => {
                sleepMs(BOOT_WAIT_SLICE_MS);
                continue;
            },
            else => return e,
        };
        // If connect worked, the listener is up; close this probe socket and return.
        s.close();
        return;
    }
}

test "preview serves third_party assets" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    // Pick one asset we know should exist
    const maybe_asset = try findAnyThirdPartyAsset(A);
    if (maybe_asset == null) return error.SkipZigTest;
    const asset_path = maybe_asset.?; // e.g. /third_party/katex/<ver>/dist/katex.min.css
    defer A.free(asset_path);

    // Start the preview server
    var srv = try server_mod.PreviewServer.init(A, ".");
    defer srv.deinit(); // ensure resources are released even if test fails

    const port: u16 = 5179;
    // Keep the thread handle so we can join it at teardown.
    var th = try std.Thread.spawn(.{}, server_mod.PreviewServer.listenAndServe, .{ &srv, port });
    defer th.join();

    // Actively wait for the TCP listener
    try waitUntilListening(A, "127.0.0.1", port);

    // Build URL/URI
    var client = std.http.Client{ .allocator = A };
    defer client.deinit();

    const url = try std.fmt.allocPrint(A, "http://127.0.0.1:{d}{s}", .{ port, asset_path });
    defer A.free(url);

    const uri = try std.Uri.parse(url);

    // Retry a few times to smooth over transient socket issues on Windows
    var status: std.http.Status = .internal_server_error;
    var attempt: usize = 0;
    while (attempt < 3) : (attempt += 1) {
        var req = try client.request(.GET, uri, .{
            .headers = .{ .connection = .{ .override = "close" } },
            .keep_alive = false,
        });
        defer req.deinit();

        // Send a GET with no body; transient write errors -> retry
        _ = req.sendBodiless() catch {
            std.Thread.sleep(150 * std.time.ns_per_ms);
            continue;
        };

        // Read only the response head; transient read errors -> retry
        var redirect_buf: [1024]u8 = undefined;
        const head = req.receiveHead(&redirect_buf) catch {
            std.Thread.sleep(150 * std.time.ns_per_ms);
            continue;
        };
        status = head.head.status;
        break;
    }

    try std.testing.expect(status == .ok);

    // Tell the server to stop so our thread can join cleanly (prevents hangs).
    try httpGetStop(A, port);
}

fn httpGetStop(a: std.mem.Allocator, port: u16) !void {
    var client = std.http.Client{ .allocator = a };
    defer client.deinit();

    const url = try std.fmt.allocPrint(a, "http://127.0.0.1:{d}/__docz_stop", .{port});
    defer a.free(url);
    const uri = try std.Uri.parse(url);

    var req = try client.request(.GET, uri, .{
        .headers = .{ .connection = .{ .override = "close" } },
        .keep_alive = false,
    });
    defer req.deinit();

    _ = req.sendBodiless() catch {};
    var redirect_buf: [256]u8 = undefined;
    _ = req.receiveHead(&redirect_buf) catch {};
}

<<<

`cli_usage.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "🧪 CLI Usage Text Contains 'docz build'" {
    const usage = docz.main.USAGE_TEXT;

    // std.debug.print("\n📋 CLI USAGE TEXT:\n{s}\n", .{usage});
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "docz build"));
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "docz preview"));
}

<<<

`convert_cli.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");
const build_options = @import("build_options");

// ─────────────────────────────────────────────────────────────────────────────
// Small path helpers (owned results)
// ─────────────────────────────────────────────────────────────────────────────

fn pathJoin2(alloc: std.mem.Allocator, a: []const u8, b: []const u8) ![]u8 {
    var list = std.ArrayList([]const u8){};
    defer list.deinit(alloc);
    try list.append(alloc, a);
    try list.append(alloc, b);
    return std.fs.path.join(alloc, list.items);
}

fn pathJoin3(alloc: std.mem.Allocator, a: []const u8, b: []const u8, c: []const u8) ![]u8 {
    var list = std.ArrayList([]const u8){};
    defer list.deinit(alloc);
    try list.append(alloc, a);
    try list.append(alloc, b);
    try list.append(alloc, c);
    return std.fs.path.join(alloc, list.items);
}

fn dirExistsAbs(abs_path: []const u8) bool {
    var d = std.fs.openDirAbsolute(abs_path, .{}) catch return false;
    d.close();
    return true;
}

// ─────────────────────────────────────────────────────────────────────────────
// Repo/CWD anchor (stable for test runner)
// ─────────────────────────────────────────────────────────────────────────────

fn repoRootFromCwd(alloc: std.mem.Allocator) ![]u8 {
    return std.fs.cwd().realpathAlloc(alloc, ".");
}

// ─────────────────────────────────────────────────────────────────────────────
// Launcher discovery (no nested functions)
// ─────────────────────────────────────────────────────────────────────────────

fn tryOpenAbs(p: []const u8) bool {
    if (!std.fs.path.isAbsolute(p)) return false;
    const f = std.fs.openFileAbsolute(p, .{}) catch return false;
    f.close();
    return true;
}

fn findUpFile(
    alloc: std.mem.Allocator,
    start_abs: []const u8,
    rel: []const u8,
    max_up: usize,
) !?[]u8 {
    if (!std.fs.path.isAbsolute(start_abs)) return null;

    var cur = try alloc.dupe(u8, start_abs);
    defer alloc.free(cur);

    var i: usize = 0;
    while (true) : (i += 1) {
        if (i > max_up) break;

        const cand = try std.fs.path.join(alloc, &[_][]const u8{ cur, rel });
        if (std.fs.openFileAbsolute(cand, .{})) |f| {
            f.close();
            return cand; // owned
        } else |e| {
            switch (e) {
                error.FileNotFound => {},
                else => {},
            }
        }
        alloc.free(cand);

        const parent_opt = std.fs.path.dirname(cur);
        if (parent_opt == null) break;

        const parent = parent_opt.?;
        const dup = try alloc.dupe(u8, parent);
        alloc.free(cur);
        cur = dup;
    }
    return null;
}

fn ensureE2ELauncher(alloc: std.mem.Allocator) ![]u8 {
    const e2e_name = if (builtin.os.tag == .windows) "docz-e2e.exe" else "docz-e2e";
    const docz_name = if (builtin.os.tag == .windows) "docz.exe" else "docz";

    if (@hasDecl(build_options, "e2e_abspath")) {
        const baked = build_options.e2e_abspath;
        if (tryOpenAbs(baked)) return try alloc.dupe(u8, baked);
    }

    const cwd_abs = try std.fs.cwd().realpathAlloc(alloc, ".");
    defer alloc.free(cwd_abs);

    const rel_e2e = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", "bin", e2e_name });
    defer alloc.free(rel_e2e);
    if (try findUpFile(alloc, cwd_abs, rel_e2e, 8)) |hit| return hit;

    const rel_docz = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", "bin", docz_name });
    defer alloc.free(rel_docz);
    if (try findUpFile(alloc, cwd_abs, rel_docz, 8)) |hit| return hit;

    if (@hasDecl(build_options, "docz_abspath")) {
        const baked_docz = build_options.docz_abspath;
        if (tryOpenAbs(baked_docz)) return try alloc.dupe(u8, baked_docz);
    }

    std.debug.print(
        "[ensureE2ELauncher] Could not find a runnable CLI.\n" ++
            "  Tried (in order):\n" ++
            "    • build_options.e2e_abspath\n" ++
            "    • find-up from CWD for zig-out/bin/{s}\n" ++
            "    • find-up from CWD for zig-out/bin/{s}\n" ++
            "    • build_options.docz_abspath\n",
        .{ e2e_name, docz_name },
    );

    return error.FileNotFound;
}

// ─────────────────────────────────────────────────────────────────────────────
// Test workspace helper (under <repo>/zig-out)
// ─────────────────────────────────────────────────────────────────────────────

fn makeWorkDir(alloc: std.mem.Allocator) !struct { dir: std.fs.Dir, abs: []u8 } {
    const repo_abs = try repoRootFromCwd(alloc);
    defer alloc.free(repo_abs);

    const base_abs = if (dirExistsAbs(repo_abs))
        try alloc.dupe(u8, repo_abs)
    else
        try std.fs.cwd().realpathAlloc(alloc, ".");
    defer alloc.free(base_abs);

    var base_dir = try std.fs.openDirAbsolute(base_abs, .{});
    defer base_dir.close();

    try base_dir.makePath("zig-out");

    var name_buf: [64]u8 = undefined;
    const sub = try std.fmt.bufPrint(&name_buf, "e2e_cli_test-{d}", .{std.time.milliTimestamp()});
    const sub_rel = try std.fs.path.join(alloc, &[_][]const u8{ "zig-out", sub });
    defer alloc.free(sub_rel);

    try base_dir.makePath(sub_rel);

    const abs = try pathJoin3(alloc, base_abs, "zig-out", sub);
    const dir = try std.fs.openDirAbsolute(abs, .{ .iterate = false });

    return .{ .dir = dir, .abs = abs };
}

// ─────────────────────────────────────────────────────────────────────────────
// The actual e2e test
// ─────────────────────────────────────────────────────────────────────────────

test "e2e: docz convert dcz→tex and tex→dcz" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const dcz_input =
        \\@meta(title="T") @end
        \\@heading(level=1) Hello @end
        \\Para
        \\
    ;

    var work_bundle = try makeWorkDir(A);
    defer {
        work_bundle.dir.close();
        A.free(work_bundle.abs);
    }
    const work = work_bundle.dir;
    const work_abs = work_bundle.abs;

    const in_path = try pathJoin2(A, work_abs, "in.dcz");
    defer A.free(in_path);
    const out_path = try pathJoin2(A, work_abs, "out.tex");
    defer A.free(out_path);
    const back_path = try pathJoin2(A, work_abs, "back.dcz");
    defer A.free(back_path);

    {
        var f = try work.createFile("in.dcz", .{ .truncate = true });
        defer f.close();
        _ = try f.writeAll(dcz_input);
    }

    const exe_path = try ensureE2ELauncher(A);
    defer A.free(exe_path);

    {
        var child = std.process.Child.init(
            &[_][]const u8{ exe_path, "convert", in_path, "--to", out_path },
            A,
        );
        try child.spawn();
        const term = try child.wait();
        try std.testing.expectEqual(std.process.Child.Term{ .Exited = 0 }, term);
    }

    const tex = blk: {
        var f = try work.openFile("out.tex", .{});
        defer f.close();

        var out = std.ArrayList(u8){};
        defer out.deinit(A);
        var tmp: [4096]u8 = undefined;
        while (true) {
            const n = try f.read(&tmp);
            if (n == 0) break;
            try out.appendSlice(A, tmp[0..n]);
        }
        break :blk try out.toOwnedSlice(A);
    };
    defer A.free(tex);

    try std.testing.expect(std.mem.indexOf(u8, tex, "\\title{T}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\section{Hello}") != null);

    {
        var child = std.process.Child.init(
            &[_][]const u8{ exe_path, "convert", out_path, "--to", back_path },
            A,
        );
        try child.spawn();
        const term = try child.wait();
        try std.testing.expectEqual(std.process.Child.Term{ .Exited = 0 }, term);
    }

    const back = blk2: {
        var f = try work.openFile("back.dcz", .{});
        defer f.close();

        var out = std.ArrayList(u8){};
        defer out.deinit(A);
        var tmp: [4096]u8 = undefined;
        while (true) {
            const n = try f.read(&tmp);
            if (n == 0) break;
            try out.appendSlice(A, tmp[0..n]);
        }
        break :blk2 try out.toOwnedSlice(A);
    };
    defer A.free(back);

    try std.testing.expect(std.mem.indexOf(u8, back, "@heading(level=1) Hello @end") != null);
}

<<<

`enable_wasm.zig`: >>>

const std = @import("std");
const docz = @import("docz");

test "🔧 Enable WASM Command Listed in Usage" {
    const usage = docz.main.USAGE_TEXT;

    std.debug.print("\n🔍 Verifying 'enable wasm' appears in help output...\n", .{});
    try std.testing.expect(std.mem.containsAtLeast(u8, usage, 1, "enable wasm"));
}

<<<

`file_to_html.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const tokenizer = docz.parser.tokenizer;
const parser = docz.parser.parser;
const renderer = docz.renderer.html;

test "📄 Parse and render a basic .dcz file to HTML" {
    const input =
        \\@meta(title="Hello")
        \\@heading(level=1) Welcome to Docz @end
        \\@code(language="zig")
        \\const x = 42;
        \\@end
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer std.debug.assert(gpa.deinit() == .ok);

    const tokens = try tokenizer.tokenize(input, allocator);
    defer {
        docz.Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try parser.parse(tokens, allocator);
    defer ast.deinit(allocator);

    const html = try renderer.renderHTML(&ast, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h1>Welcome to Docz</h1>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 42;"));
}

<<<

`preview_cli_smoke.zig`: >>>

const std = @import("std");

// ---- small helpers ---------------------------------------------------------

fn writeAllStream(s: *std.net.Stream, bytes: []const u8) !void {
    var off: usize = 0;
    while (off < bytes.len) {
        const n = try s.write(bytes[off..]);
        if (n == 0) return error.Unexpected; // peer closed; treat as error on this snapshot
        off += n;
    }
}

fn readAll(s: *std.net.Stream, A: std.mem.Allocator) ![]u8 {
    var out = std.ArrayListUnmanaged(u8){};
    errdefer out.deinit(A);

    var tmp: [4096]u8 = undefined;
    while (true) {
        const n = s.read(tmp[0..]) catch |e| switch (e) {
            // On this Zig version, EOF is signaled by n == 0 (no error).
            // Only WouldBlock is in the error set; Interrupted isn't.
            error.WouldBlock => continue,
            else => return e,
        };
        if (n == 0) break;
        try out.appendSlice(A, tmp[0..n]);
    }
    return out.toOwnedSlice(A);
}

fn httpGet(port: u16, path: []const u8, A: std.mem.Allocator) ![]u8 {
    const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, port);
    var sock = try std.net.tcpConnectToAddress(addr);
    defer sock.close();

    var req = std.ArrayListUnmanaged(u8){};
    defer req.deinit(A);
    try req.appendSlice(A, "GET ");
    try req.appendSlice(A, path);
    try req.appendSlice(A, " HTTP/1.1\r\nHost: 127.0.0.1\r\nConnection: close\r\n\r\n");

    try writeAllStream(&sock, req.items);
    return readAll(&sock, A);
}

fn status(bytes: []const u8) !u16 {
    const nl = std.mem.indexOf(u8, bytes, "\r\n") orelse return error.BadFormat;
    const line = bytes[0..nl];
    const sp1 = std.mem.indexOfScalar(u8, line, ' ') orelse return error.BadFormat;
    const sp2 = std.mem.indexOfScalarPos(u8, line, sp1 + 1, ' ') orelse return error.BadFormat;
    return @intCast(try std.fmt.parseInt(u16, line[sp1 + 1 .. sp2], 10));
}

// ---- the smoke test --------------------------------------------------------

test "docz preview CLI smoke: starts, serves /healthz, stops" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const port: u16 = 5181;

    // Build argv: docz preview --no-open --port <port>
    var port_buf: [16]u8 = undefined;
    const port_s = try std.fmt.bufPrint(&port_buf, "{d}", .{port});

    var child = std.process.Child.init(&[_][]const u8{
        "docz", "preview", "--no-open", "--port", port_s,
    }, A);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    // Provide auto-stop in case our /__docz_stop doesn't land.
    var env = try std.process.getEnvMap(A);
    defer env.deinit();
    try env.put("DOCZ_TEST_AUTOSTOP_MS", "2500");
    child.env_map = &env; // pass a pointer per this Zig snapshot's API

    try child.spawn();
    defer {
        // make sure we don't leak a process if the test fails early
        _ = child.kill() catch {};
        _ = child.wait() catch {};
    }

    // Give the server a brief moment to bind
    std.Thread.sleep(200 * std.time.ns_per_ms);

    // Probe /healthz (retry once if we raced the bind)
    const resp = httpGet(port, "/healthz", A) catch blk: {
        std.Thread.sleep(250 * std.time.ns_per_ms);
        break :blk try httpGet(port, "/healthz", A);
    };
    defer A.free(resp);
    try std.testing.expectEqual(@as(u16, 200), try status(resp));

    // Ask it to stop cleanly
    const stop_resp = try httpGet(port, "/__docz_stop", A);
    defer A.free(stop_resp);

    const term = try child.wait();
    try std.testing.expect(term == .Exited and term.Exited == 0);
}

<<<

`docz.zig`: >>>

// central "index" that re-exports stable APIs

<<<

`main.zig`: >>>

// CLI entry point (docz)

const std = @import("std");

// Thin CLI dispatcher: each subcommand lives in src/cli/*.zig
const cli_convert = @import("cli/convert.zig");
const cli_build_cmd = @import("cli/build_cmd.zig");
const cli_preview = @import("cli/preview.zig");
const cli_enable = @import("cli/enable_wasm.zig");
const cli_run = @import("cli/run.zig"); // ← new

/// Global constant for CLI usage text (keeps original lines; adds convert/export + run)
pub const USAGE_TEXT =
    \\Docz CLI Usage:
    \\  docz build <file.dcz>       Build .dcz file to HTML
    \\  docz preview                Start local preview server
    \\  docz run <file.dcz>         Convert to temp dir and serve; rebuild on change
    \\                               Options: [--port <num>] [--css inline|file] [--no-pretty]
    \\  docz enable wasm            Enable WASM execution support
    \\  docz convert <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]
    \\  docz export  <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]
    \\
;

/// CLI entry point: parse args → dispatch to subcommand module.
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var it = try std.process.argsWithAllocator(A);
    defer it.deinit();

    _ = it.next(); // program name
    const cmd = it.next() orelse {
        printUsage();
        return;
    };

    // Dispatch table
    if (std.mem.eql(u8, cmd, "build")) {
        try cli_build_cmd.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "preview")) {
        try cli_preview.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "run")) {
        try cli_run.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "enable")) {
        // enable_wasm expects the next token to be "wasm"
        try cli_enable.run(A, &it);
        return;
    }
    if (std.mem.eql(u8, cmd, "convert") or std.mem.eql(u8, cmd, "export")) {
        try cli_convert.run(A, &it);
        return;
    }

    printUsage();
}

/// Prints usage help text (no std.io handles → portable across nightlies)
fn printUsage() void {
    // std.debug.print writes to stderr on most toolchains; that’s fine for usage/help.
    std.debug.print("{s}", .{USAGE_TEXT});
}

// Simple test for CLI usage message
test "CLI usage message prints" {
    var buffer: [1024]u8 = undefined;
    var fbs = std.io.fixedBufferStream(&buffer);
    const writer = fbs.writer();

    try writer.writeAll(USAGE_TEXT);

    const written = fbs.getWritten();
    try std.testing.expect(std.mem.indexOf(u8, written, "docz build") != null);
}

<<<

`testutil.zig`: >>>

const std = @import("std");

pub const VERBOSE = @import("build_options").verbose_tests;

pub inline fn vprint(comptime fmt: []const u8, args: anytype) void {
    if (!VERBOSE) return;
    std.debug.print(fmt, args);
}

<<<

`handler.zig`: >>>

const std = @import("std");

// Import core pieces directly to avoid circular imports via root.zig
const Tokenizer = @import("../src/parser/tokenizer.zig");
const Parser = @import("../src/parser/parser.zig");
const Renderer = @import("../src/renderer/html.zig");

/// Minimal HTTP-ish response struct for the server layer to use.
pub const Response = struct {
    status_code: u16,
    mime: []const u8,
    body: []u8, // owned by caller's allocator

    pub fn deinit(self: *Response, allocator: std.mem.Allocator) void {
        allocator.free(self.body);
    }
};

/// Render a `.dcz` document (as bytes) to HTML (owned slice).
pub fn renderDoczToHtml(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    const tokens = try Tokenizer.tokenize(input, allocator);
    defer {
        // Free any token-owned lexemes before freeing the slice
        Tokenizer.freeTokens(allocator, tokens);
        allocator.free(tokens);
    }

    var ast = try Parser.parse(tokens, allocator);
    defer ast.deinit();

    return try Renderer.renderHTML(&ast, allocator);
}

/// Read a `.dcz` file from disk and render it to HTML.
/// Returns an owned HTML slice.
pub fn renderFileToHtml(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    var file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const stat = try file.stat();
    const buf = try allocator.alloc(u8, stat.size);
    defer allocator.free(buf);

    _ = try file.readAll(buf);
    return try renderDoczToHtml(allocator, buf);
}

/// Basic router that decides how to respond to a request path.
/// For now:
///   - `/`               → renders provided `default_docz_path`
///   - `/*.dcz`          → renders that file
///   - anything else     → 404
pub fn route(
    allocator: std.mem.Allocator,
    path: []const u8,
    default_docz_path: []const u8,
) !Response {
    if (std.mem.eql(u8, path, "/")) {
        const html = try renderFileToHtml(allocator, default_docz_path);
        return Response{
            .status_code = 200,
            .mime = "text/html",
            .body = html,
        };
    }

    if (std.mem.endsWith(u8, path, ".dcz")) {
        // strip leading slash
        const fs_path = if (path.len > 0 and path[0] == '/') path[1..] else path;
        const html = try renderFileToHtml(allocator, fs_path);
        return Response{
            .status_code = 200,
            .mime = "text/html",
            .body = html,
        };
    }

    // TODO: later we'll serve static assets (client JS/CSS) here too.
    const msg = "Not Found";
    const body = try allocator.dupe(u8, msg);
    return Response{
        .status_code = 404,
        .mime = "text/plain",
        .body = body,
    };
}

// ─────────────────────────────────────────────────────────────
// 🧪 Tests
// ─────────────────────────────────────────────────────────────

test "renderDoczToHtml: basic doc renders expected pieces" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const input =
        \\@meta(title="Hello")
        \\@heading(level=1) Welcome @end
        \\@code(language="zig")
        \\const x = 7;
        \\@end
    ;

    const html = try renderDoczToHtml(alloc, input);
    defer alloc.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<title>Hello</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h1>Welcome</h1>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "const x = 7;"));
}

test "renderFileToHtml: writes a temp file and renders it" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    // Create a temp .dcz file in the cwd. Use a unique-ish name.
    const filename = "handler_test_temp.dcz";
    {
        var f = try std.fs.cwd().createFile(filename, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="TempDoc")
            \\@heading(level=2) Hi From File @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(filename) catch {};

    const html = try renderFileToHtml(alloc, filename);
    defer alloc.free(html);

    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<title>TempDoc</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, html, 1, "<h2>Hi From File</h2>"));
}

test "route: / returns HTML for default_docz_path; 404 for unknowns" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const filename = "handler_route_default.dcz";
    {
        var f = try std.fs.cwd().createFile(filename, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="IndexDoc")
            \\@heading(level=1) Index @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(filename) catch {};

    // Root route
    var resp = try route(alloc, "/", filename);
    defer resp.deinit(alloc);
    try std.testing.expectEqual(@as(u16, 200), resp.status_code);
    try std.testing.expect(std.mem.eql(u8, resp.mime, "text/html"));
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<title>IndexDoc</title>"));

    // 404 route
    var not_found = try route(alloc, "/nope", filename);
    defer not_found.deinit(alloc);
    try std.testing.expectEqual(@as(u16, 404), not_found.status_code);
    try std.testing.expect(std.mem.eql(u8, not_found.mime, "text/plain"));
    try std.testing.expect(std.mem.containsAtLeast(u8, not_found.body, 1, "Not Found"));
}

test "route: /foo.dcz renders that explicit file" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    const fname = "explicit_file.dcz";
    {
        var f = try std.fs.cwd().createFile(fname, .{ .read = true, .truncate = true });
        defer f.close();

        const content =
            \\@meta(title="Explicit")
            \\@heading(level=3) Explicit Route @end
        ;
        _ = try f.write(content);
    }
    defer std.fs.cwd().deleteFile(fname) catch {};

    var resp = try route(alloc, "/explicit_file.dcz", "ignored-for-this-test.dcz");
    defer resp.deinit(alloc);

    try std.testing.expectEqual(@as(u16, 200), resp.status_code);
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<title>Explicit</title>"));
    try std.testing.expect(std.mem.containsAtLeast(u8, resp.body, 1, "<h3>Explicit Route</h3>"));
}

<<<

`hot_reload.zig`: >>>

const std = @import("std");

/// A lightweight Server-Sent Events (SSE) utility + broadcaster
/// used by the web-preview server to push hot-reload notifications.
pub const Sink = struct {
    ctx: *anyopaque,
    writeFn: *const fn (ctx: *anyopaque, bytes: []const u8) anyerror!void,
};

/// Small printf-to-ArrayList helper (Zig 0.16: no ArrayList.writer()).
fn appendFmt(A: std.mem.Allocator, list: *std.ArrayList(u8), comptime fmt: []const u8, args: anytype) !void {
    const s = try std.fmt.allocPrint(A, fmt, args);
    defer A.free(s);
    try list.appendSlice(A, s);
}

/// Build a valid SSE event payload. Splits `data` by lines and prefixes
/// each with `data: `. Includes an `event:` line when `event` is non-empty.
/// Returns an owned buffer; caller must free.
pub fn formatSseEvent(allocator: std.mem.Allocator, event: []const u8, data: []const u8) ![]u8 {
    var buf = std.ArrayList(u8){};
    errdefer buf.deinit(allocator);

    if (event.len != 0) {
        try appendFmt(allocator, &buf, "event: {s}\n", .{event});
    }

    var it = std.mem.splitScalar(u8, data, '\n');
    while (it.next()) |line| {
        try appendFmt(allocator, &buf, "data: {s}\n", .{line});
    }

    // SSE event terminator: exactly one blank line
    try buf.appendSlice(allocator, "\n");

    // Allocate result from `allocator`
    var out: []u8 = try buf.toOwnedSlice(allocator);

    // Normalize: ensure exactly one trailing '\n'
    var n = out.len;
    var tail: usize = 0;
    while (n > 0 and out[n - 1] == '\n') : (n -= 1) {
        tail += 1;
    }
    if (tail > 1) {
        out = try allocator.realloc(out, out.len - (tail - 1));
    }

    return out;
}

/// Broadcasts events to a dynamic set of sinks. On write error,
/// the failing sink is removed.
pub const Broadcaster = struct {
    const Client = struct {
        id: u64,
        sink: Sink,
    };

    allocator: std.mem.Allocator,
    clients: std.ArrayList(Client),
    next_id: u64 = 1,

    pub fn init(allocator: std.mem.Allocator) Broadcaster {
        return .{
            .allocator = allocator,
            .clients = std.ArrayList(Client){},
            .next_id = 1,
        };
    }

    pub fn deinit(self: *Broadcaster) void {
        self.clients.deinit(self.allocator);
    }

    /// Add a sink; returns a unique client id.
    pub fn add(self: *Broadcaster, sink: Sink) !u64 {
        const id = self.next_id;
        self.next_id += 1;
        try self.clients.append(self.allocator, .{ .id = id, .sink = sink });
        return id;
    }

    /// Remove a sink by id; returns true if it existed.
    pub fn remove(self: *Broadcaster, id: u64) bool {
        var i: usize = 0;
        while (i < self.clients.items.len) : (i += 1) {
            if (self.clients.items[i].id == id) {
                _ = self.clients.orderedRemove(i);
                return true;
            }
        }
        return false;
    }

    /// Send one SSE event to all active sinks. Any sink that errors is pruned.
    pub fn broadcast(self: *Broadcaster, event: []const u8, data: []const u8) !void {
        const payload = try formatSseEvent(self.allocator, event, data);
        defer self.allocator.free(payload);

        var i: usize = 0;
        while (i < self.clients.items.len) {
            const sink = self.clients.items[i].sink;

            // Attempt write; if it errors, drop this client and DON'T advance i.
            sink.writeFn(sink.ctx, payload) catch {
                _ = self.clients.orderedRemove(i);
                continue;
            };

            // Success: advance
            i += 1;
        }
    }
};

///////////////////////
//        Tests      //
///////////////////////

test "formatSseEvent: with event and multi-line data" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try formatSseEvent(A, "reload", "a\nb\n");
    defer A.free(out);

    const expected =
        \\event: reload
        \\data: a
        \\data: b
        \\data: 
        \\
    ;
    try std.testing.expectEqualStrings(expected, out);
}

test "formatSseEvent: data only (no event line)" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try formatSseEvent(A, "", "hello");
    defer A.free(out);

    const expected =
        \\data: hello
        \\
    ;
    try std.testing.expectEqualStrings(expected, out);
}

const TestBuffer = struct {
    allocator: std.mem.Allocator,
    list: std.ArrayList(u8),

    fn init(allocator: std.mem.Allocator) TestBuffer {
        return .{ .allocator = allocator, .list = std.ArrayList(u8){} };
    }
    fn deinit(self: *TestBuffer) void {
        self.list.deinit(self.allocator);
    }

    fn sink(self: *TestBuffer) Sink {
        return .{
            .ctx = self,
            .writeFn = write,
        };
    }

    fn write(ctx: *anyopaque, bytes: []const u8) !void {
        var self: *TestBuffer = @ptrCast(@alignCast(ctx));
        try self.list.appendSlice(self.allocator, bytes);
    }
};

test "Broadcaster: add, broadcast to two sinks, remove" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var bc = Broadcaster.init(A);
    defer bc.deinit();

    var buf1 = TestBuffer.init(A);
    defer buf1.deinit();
    var buf2 = TestBuffer.init(A);
    defer buf2.deinit();

    const id1 = try bc.add(buf1.sink());
    const id2 = try bc.add(buf2.sink());

    try bc.broadcast("ping", "X");

    const expected =
        \\event: ping
        \\data: X
        \\
    ;

    try std.testing.expectEqualStrings(expected, buf1.list.items);
    try std.testing.expectEqualStrings(expected, buf2.list.items);

    try std.testing.expect(bc.remove(id1));
    try std.testing.expect(bc.remove(id2));
    try std.testing.expect(!bc.remove(9999));
}

test "Broadcaster: auto-prunes a failing sink" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var bc = Broadcaster.init(A);
    defer bc.deinit();

    // good sink
    var good = TestBuffer.init(A);
    defer good.deinit();
    _ = try bc.add(good.sink());

    // bad sink that always errors
    const Bad = struct {
        fn make() Sink {
            return .{ .ctx = undefined, .writeFn = fail };
        }
        fn fail(_: *anyopaque, _: []const u8) !void {
            return error.Disconnected;
        }
    };
    _ = try bc.add(Bad.make());

    try bc.broadcast("tick", "ok");
    // After broadcast, the bad sink should have been removed; a second broadcast still succeeds.
    try bc.broadcast("tock", "ok");

    const expected_first =
        \\event: tick
        \\data: ok
        \\
    ;
    const expected_second =
        \\event: tock
        \\data: ok
        \\
    ;
    // good buffer should have both concatenated writes
    try std.testing.expect(std.mem.indexOf(u8, good.list.items, expected_first) != null);
    try std.testing.expect(std.mem.indexOf(u8, good.list.items, expected_second) != null);
}

<<<

`limits.zig`: >>>

const std = @import("std");

// ─────────────────────────────────────────────────────────────────────────────
// Limits & exported default
// ─────────────────────────────────────────────────────────────────────────────

/// Hard limits for HTTP parsing in the preview server.
pub const Limits = struct {
    /// Max bytes allowed for the request line (method SP target SP version CRLF).
    max_request_line: usize = 8 * 1024, // 8 KiB
    /// Max raw header bytes (from after request line through CRLF CRLF inclusive).
    max_headers_bytes: usize = 64 * 1024, // 64 KiB
    /// Max body size (when Content-Length is provided).
    max_body_bytes: usize = 4 * 1024 * 1024, // 4 MiB
};

/// Exported default limits (so callers don’t have to write `Limits{}`).
pub const DEFAULT: Limits = .{};

// ─────────────────────────────────────────────────────────────────────────────
// Error set & reader callback type
// ─────────────────────────────────────────────────────────────────────────────

pub const ReadError = error{
    RequestLineTooLong,
    HeadersTooLarge,
    Malformed,
    BodyTooLarge,
    EndOfStream,
};

/// Reader callback signature: returns number of bytes read or an error.
pub const ReadFn = fn (*anyopaque, []u8) anyerror!usize;

// ─────────────────────────────────────────────────────────────────────────────
// Request line
// ─────────────────────────────────────────────────────────────────────────────

/// Read the HTTP request line with a byte cap.
/// Returns the bytes of the request line **including** the trailing CRLF when possible.
pub fn readRequestLineWithLimit(
    ctx: *anyopaque,
    read_cb: ReadFn,
    allocator: std.mem.Allocator,
    lim: Limits,
) ReadError![]u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    defer buf.deinit(allocator);

    var prev: u8 = 0;
    while (true) {
        var tmp: [512]u8 = undefined;
        const n = read_cb(ctx, tmp[0..]) catch |e| switch (e) {
            error.WouldBlock, error.Interrupted => continue,
            else => return ReadError.Malformed,
        };
        if (n == 0) return ReadError.EndOfStream;

        // Append; map OOM → Malformed to keep error set stable
        buf.appendSlice(allocator, tmp[0..n]) catch return ReadError.Malformed;
        if (buf.items.len > lim.max_request_line) return ReadError.RequestLineTooLong;

        // Scan for CRLF between the newly appended bytes and the trailing edge.
        var i: usize = 0;
        while (i < n) : (i += 1) {
            const c = tmp[i];
            if (prev == '\r' and c == '\n') {
                // position right after LF in combined buffer
                const end = buf.items.len - (n - i - 1);
                return allocator.dupe(u8, buf.items[0..end]) catch return ReadError.Malformed;
            }
            prev = c;
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Headers
// ─────────────────────────────────────────────────────────────────────────────

/// Read raw header bytes until CRLF CRLF, enforcing max size.
/// Returns the full header block **including** the terminating CRLF CRLF.
pub fn readHeadersWithLimit(
    ctx: *anyopaque,
    read_cb: ReadFn,
    allocator: std.mem.Allocator,
    lim: Limits,
) ReadError![]u8 {
    var out: std.ArrayListUnmanaged(u8) = .{};
    defer out.deinit(allocator);

    var last4: [4]u8 = .{ 0, 0, 0, 0 };

    while (true) {
        var tmp: [1024]u8 = undefined;
        const n = read_cb(ctx, tmp[0..]) catch |e| switch (e) {
            error.WouldBlock, error.Interrupted => continue,
            else => return ReadError.Malformed,
        };
        if (n == 0) return ReadError.Malformed;

        out.appendSlice(allocator, tmp[0..n]) catch return ReadError.Malformed;
        if (out.items.len > lim.max_headers_bytes) return ReadError.HeadersTooLarge;

        var i: usize = 0;
        while (i < n) : (i += 1) {
            const c = tmp[i];
            last4 = .{ last4[1], last4[2], last4[3], c };
            if (last4[0] == '\r' and last4[1] == '\n' and last4[2] == '\r' and last4[3] == '\n') {
                return allocator.dupe(u8, out.items) catch return ReadError.Malformed;
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Content-Length
// ─────────────────────────────────────────────────────────────────────────────

/// Parse Content-Length (case-insensitive) from a raw header block.
/// Returns 0 if the header is absent or unparsable.
pub fn contentLengthFrom(headers: []const u8) u64 {
    var it = std.mem.splitScalar(u8, headers, '\n');
    while (it.next()) |line_with_cr| {
        const line = if (line_with_cr.len > 0 and line_with_cr[line_with_cr.len - 1] == '\r')
            line_with_cr[0 .. line_with_cr.len - 1]
        else
            line_with_cr;
        if (std.ascii.startsWithIgnoreCase(line, "content-length:")) {
            // Skip colon and optional whitespace
            var p = line[15..];
            while (p.len > 0 and (p[0] == ' ' or p[0] == '\t')) p = p[1..];
            // Read number until whitespace or end
            var j: usize = 0;
            while (j < p.len and std.ascii.isDigit(p[j])) : (j += 1) {}
            if (j == 0) return 0;
            return std.fmt.parseInt(u64, p[0..j], 10) catch 0;
        }
    }
    return 0;
}

// ─────────────────────────────────────────────────────────────────────────────
// Body
// ─────────────────────────────────────────────────────────────────────────────

/// Read exactly `Content-Length` bytes, enforcing `lim.max_body_bytes`.
/// Returns `BodyTooLarge` if the announced size exceeds the limit, or `Malformed`
/// if allocation fails or fewer bytes are received than promised.
pub fn readBodyWithLimit(
    ctx: *anyopaque,
    read_cb: ReadFn,
    allocator: std.mem.Allocator,
    lim: Limits,
    content_len: u64,
) ReadError![]u8 {
    if (content_len > lim.max_body_bytes) return ReadError.BodyTooLarge;
    const want: usize = @intCast(content_len);

    var out = allocator.alloc(u8, want) catch return ReadError.Malformed;
    var filled: usize = 0;
    while (filled < want) {
        const n = read_cb(ctx, out[filled..want]) catch |e| switch (e) {
            error.WouldBlock, error.Interrupted => continue,
            else => {
                allocator.free(out);
                return ReadError.Malformed;
            },
        };
        if (n == 0) break;
        filled += n;
    }

    if (filled != want) {
        allocator.free(out);
        return ReadError.Malformed;
    }
    return out;
}

// ─────────────────────────────────────────────────────────────────────────────
// Tests (quick smoke checks)
// ─────────────────────────────────────────────────────────────────────────────

const MockReader = struct {
    data: []const u8,
    pos: usize = 0,
    fn read(self: *MockReader, buf: []u8) !usize {
        if (self.pos >= self.data.len) return @as(usize, 0);
        const n = @min(buf.len, self.data.len - self.pos);
        @memcpy(buf[0..n], self.data[self.pos .. self.pos + n]);
        self.pos += n;
        return n;
    }
};

fn mockReadCb(ctx: *anyopaque, buf: []u8) !usize {
    const self: *MockReader = @ptrCast(@alignCast(ctx));
    return self.read(buf);
}

test "contentLengthFrom basic" {
    const hdr =
        "Host: x\r\n" ++
        "Content-Length: 42\r\n" ++
        "\r\n";
    try std.testing.expectEqual(@as(u64, 42), contentLengthFrom(hdr));
}

test "readRequestLineWithLimit finds CRLF and caps size" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const A = gpa.allocator();

    var mr = MockReader{ .data = "GET /view?path=docs/SPEC.dcz HTTP/1.1\r\nHost: x\r\n\r\n" };
    const line = try readRequestLineWithLimit(&mr, mockReadCb, A, DEFAULT);
    defer A.free(line);
    try std.testing.expect(std.mem.endsWith(u8, line, "\r\n"));
    try std.testing.expect(std.mem.startsWith(u8, line, "GET "));
}

test "readHeadersWithLimit collects until CRLFCRLF and enforces cap" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const A = gpa.allocator();

    const headers_bytes =
        "Host: x\r\n" ++
        "Content-Type: text/plain\r\n" ++
        "\r\n";
    var mr = MockReader{ .data = headers_bytes };
    const headers = try readHeadersWithLimit(&mr, mockReadCb, A, DEFAULT);
    defer A.free(headers);
    try std.testing.expect(std.mem.endsWith(u8, headers, "\r\n\r\n"));

    const big = try A.alloc(u8, (64 * 1024) + 10);
    defer A.free(big);
    @memset(big, 'a');
    var mr2 = MockReader{ .data = big };
    try std.testing.expectError(ReadError.HeadersTooLarge, readHeadersWithLimit(&mr2, mockReadCb, A, DEFAULT));
}

test "readBodyWithLimit respects Content-Length and cap" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const A = gpa.allocator();

    const body = "hello-world";
    var mr = MockReader{ .data = body };
    const out = try readBodyWithLimit(&mr, mockReadCb, A, DEFAULT, body.len);
    defer A.free(out);
    try std.testing.expectEqualStrings(body, out);

    var mr2 = MockReader{ .data = body };
    try std.testing.expectError(ReadError.BodyTooLarge, readBodyWithLimit(&mr2, mockReadCb, A, Limits{ .max_body_bytes = 4 }, body.len));
}

<<<

`server.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");

// Import sibling hot-reload as a module (not by relative path)
const hot = @import("web_preview_hot");

// Depend on docz public API, not individual source files
const docz = @import("docz");
const Tokenizer = docz.Tokenizer;
const Parser = docz.Parser;
const Renderer = docz.Renderer;

const LogMode = enum { plain, json };

fn getenvOwnedOrNull(a: std.mem.Allocator, key: []const u8) ?[]u8 {
    return std.process.getEnvVarOwned(a, key) catch |e| switch (e) {
        error.EnvironmentVariableNotFound => null,
        else => null,
    };
}

fn chooseLogMode(a: std.mem.Allocator) LogMode {
    if (getenvOwnedOrNull(a, "DOCZ_LOG")) |v| {
        defer a.free(v);
        if (std.ascii.eqlIgnoreCase(v, "json")) return .json;
    }
    return .plain;
}

fn jsonEscapeInto(buf: *std.ArrayListUnmanaged(u8), s: []const u8, A: std.mem.Allocator) !void {
    // minimal escape: quotes, backslashes, and common control chars
    for (s) |c| switch (c) {
        '"' => try buf.appendSlice(A, "\\\""),
        '\\' => try buf.appendSlice(A, "\\\\"),
        '\n' => try buf.appendSlice(A, "\\n"),
        '\r' => try buf.appendSlice(A, "\\r"),
        '\t' => try buf.appendSlice(A, "\\t"),
        else => try buf.append(A, c),
    };
}

fn logServerJSON(event: []const u8, fields: []const struct { []const u8, []const u8 }) void {
    // Build: {"ts":..., "ev":"...", "k":"v", ...}
    var buf = std.ArrayListUnmanaged(u8){};
    const A = std.heap.page_allocator;
    defer buf.deinit(A);

    const ts = std.time.milliTimestamp();

    _ = buf.appendSlice(A, "{\"ts\":") catch return;

    var ts_buf: [32]u8 = undefined;
    const ts_s = std.fmt.bufPrint(&ts_buf, "{d}", .{ts}) catch return;
    _ = buf.appendSlice(A, ts_s) catch return;

    _ = buf.appendSlice(A, ",\"ev\":\"") catch return;
    jsonEscapeInto(&buf, event, A) catch return;
    _ = buf.appendSlice(A, "\"") catch return;

    for (fields) |kv| {
        _ = buf.appendSlice(A, ",\"") catch return;
        _ = buf.appendSlice(A, kv[0]) catch return;
        _ = buf.appendSlice(A, "\":\"") catch return;
        jsonEscapeInto(&buf, kv[1], A) catch return;
        _ = buf.appendSlice(A, "\"") catch return;
    }

    _ = buf.appendSlice(A, "}\n") catch return;

    // In this Zig build, std.debug.print is the portable way to write to stderr.
    std.debug.print("{s}", .{buf.items});
}

fn decU64(n: u64, buf: *[24]u8) []const u8 {
    return std.fmt.bufPrint(buf, "{d}", .{n}) catch unreachable;
}

// ----------------------------
// Minimal HTTP primitives
// ----------------------------
const Header = struct { name: []const u8, value: []const u8 };

const Status = enum(u16) {
    ok = 200,
    partial_content = 206,
    no_content = 204,
    not_modified = 304,
    range_not_satisfiable = 416,
    internal_server_error = 500,
};

fn statusReason(s: Status) []const u8 {
    return switch (s) {
        .ok => "OK",
        .partial_content => "Partial Content",
        .no_content => "No Content",
        .not_modified => "Not Modified",
        .range_not_satisfiable => "Range Not Satisfiable",
        .internal_server_error => "Internal Server Error",
    };
}

const RespondOpts = struct {
    status: Status = .ok,
    extra_headers: []const Header = &.{},
};

const Request = struct {
    allocator: std.mem.Allocator,
    stream: *std.net.Stream,
    method: []const u8,
    target: []const u8,
    headers: []const u8, // raw header bytes including final CRLFCRLF (best-effort)

    fn respond(self: *Request, body: []const u8, opts: RespondOpts) !void {
        const code = @intFromEnum(opts.status);
        const reason = statusReason(opts.status);

        var len_buf: [24]u8 = undefined;
        const cl = decU64(body.len, &len_buf);

        const A = self.allocator;

        const status_line = try std.fmt.allocPrint(A, "HTTP/1.1 {d} {s}\r\n", .{ code, reason });
        defer A.free(status_line);
        try streamWriteAllCompat(self.stream, status_line);

        const cl_line = try std.fmt.allocPrint(A, "Content-Length: {s}\r\n", .{cl});
        defer A.free(cl_line);
        try streamWriteAllCompat(self.stream, cl_line);

        for (opts.extra_headers) |h| {
            const hline = try std.fmt.allocPrint(A, "{s}: {s}\r\n", .{ h.name, h.value });
            defer A.free(hline);
            try streamWriteAllCompat(self.stream, hline);
        }

        try streamWriteAllCompat(self.stream, "Connection: close\r\n\r\n");

        // HEAD: advertise length but do not send body
        if (!std.mem.eql(u8, self.method, "HEAD")) {
            try streamWriteAllCompat(self.stream, body);
        }
    }
};

// --- compat: write/read loops on sockets ---
fn writeAllCompat(w: anytype, bytes: []const u8) !void {
    var off: usize = 0;
    while (off < bytes.len) {
        const n = try w.write(bytes[off..]);
        if (n == 0) return error.EndOfStream;
        off += n;
    }
}

fn streamWriteAllCompat(s: *std.net.Stream, bytes: []const u8) !void {
    var off: usize = 0;
    while (off < bytes.len) {
        const n = try s.write(bytes[off..]);
        if (n == 0) return error.EndOfStream;
        off += n;
    }
}

// --- compat: read from TCP sockets via OS recv (avoids Windows ReadFile(87))
fn readStreamCompat(stream: *std.net.Stream, buf: []u8) !usize {
    if (builtin.os.tag == .windows) {
        const ws2 = std.os.windows.ws2_32;

        const ret: c_int = ws2.recv(
            stream.handle,
            buf.ptr,
            @as(c_int, @intCast(buf.len)),
            0,
        );
        if (ret == ws2.SOCKET_ERROR) {
            const werr = ws2.WSAGetLastError();
            const code: u16 = @intFromEnum(werr);
            return switch (code) {
                10035 => error.WouldBlock, // WSAEWOULDBLOCK
                10004 => error.Interrupted, // WSAEINTR
                10054 => error.ConnectionResetByPeer, // WSAECONNRESET
                else => error.Unexpected,
            };
        }
        return @as(usize, @intCast(ret));
    } else {
        const n = try std.posix.recv(stream.handle, buf, 0);
        return @as(usize, n);
    }
}

// ---- Minimal request reader (first line + best-effort headers), tolerant on Windows
fn receiveRequest(alloc: std.mem.Allocator, stream: *std.net.Stream) !Request {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    errdefer buf.deinit(alloc);

    const max_header_bytes: usize = 64 * 1024;
    const start_ms = std.time.milliTimestamp();
    const retry_budget_ms: i64 = 1800;

    // Read until we at least have a first line
    var have_first_line = false;
    while (!have_first_line and buf.items.len < max_header_bytes) {
        var tmp: [2048]u8 = undefined;
        const n = readStreamCompat(stream, tmp[0..]) catch |e| switch (e) {
            error.WouldBlock, error.Interrupted, error.ConnectionResetByPeer, error.Unexpected => {
                if (std.time.milliTimestamp() - start_ms < retry_budget_ms) {
                    std.Thread.sleep(150 * std.time.ns_per_ms);
                    continue;
                }
                return error.BadRequest;
            },
        };
        if (n == 0) break;
        try buf.appendSlice(alloc, tmp[0..n]);
        if (std.mem.indexOfScalar(u8, buf.items, '\n') != null) have_first_line = true;
    }
    if (buf.items.len == 0) return error.BadRequest;

    // Split out first line
    const nl_i_opt = std.mem.indexOfScalar(u8, buf.items, '\n');
    const line_end = nl_i_opt orelse buf.items.len;
    const line_raw = buf.items[0..line_end];
    const first = if (line_raw.len > 0 and line_raw[line_raw.len - 1] == '\r')
        line_raw[0 .. line_raw.len - 1]
    else
        line_raw;

    var it = std.mem.tokenizeScalar(u8, first, ' ');
    const m = it.next() orelse "GET";
    const t = it.next() orelse "/";

    // If we didn't already capture CRLFCRLF, keep reading headers
    var have_end = std.mem.endsWith(u8, buf.items, "\r\n\r\n");
    while (!have_end and buf.items.len < max_header_bytes) {
        var tmp2: [2048]u8 = undefined;
        const n2 = readStreamCompat(stream, tmp2[0..]) catch |e| switch (e) {
            error.WouldBlock, error.Interrupted, error.ConnectionResetByPeer, error.Unexpected => {
                if (std.time.milliTimestamp() - start_ms < retry_budget_ms) {
                    std.Thread.sleep(100 * std.time.ns_per_ms);
                    continue;
                }
                break; // best-effort; we'll parse what we have
            },
        };
        if (n2 == 0) break;
        try buf.appendSlice(alloc, tmp2[0..n2]);
        have_end = std.mem.indexOf(u8, buf.items, "\r\n\r\n") != null;
    }

    // Extract raw header bytes AFTER the first line up to CRLFCRLF (if present)
    var headers_slice: []const u8 = &.{};
    if (std.mem.indexOf(u8, buf.items, "\r\n\r\n")) |end_hdr| {
        if (line_end < end_hdr + 4 and line_end + 1 <= buf.items.len) {
            const start_hdr = line_end + 1; // after LF
            headers_slice = try alloc.dupe(u8, buf.items[start_hdr .. end_hdr + 4]);
        }
    }

    const method = try alloc.dupe(u8, m);
    const target = try alloc.dupe(u8, t);
    buf.deinit(alloc);

    return .{
        .allocator = alloc,
        .stream = stream,
        .method = method,
        .target = target,
        .headers = headers_slice,
    };
}

// ----------------------------
// Preview server
// ----------------------------

pub const PreviewServer = struct {
    allocator: std.mem.Allocator,
    doc_root: []const u8,
    broadcaster: hot.Broadcaster,
    stop_requested: bool = false, // TEST-ONLY stop flag to exit the accept loop gracefully
    log_mode: LogMode = .plain,

    pub fn init(allocator: std.mem.Allocator, doc_root: []const u8) !PreviewServer {
        const trimmed = try trimTrailingSlash(allocator, doc_root);
        errdefer allocator.free(trimmed);
        return .{
            .allocator = allocator,
            .doc_root = trimmed,
            .broadcaster = hot.Broadcaster.init(allocator),
            .log_mode = chooseLogMode(allocator),
        };
    }

    pub fn deinit(self: *PreviewServer) void {
        self.broadcaster.deinit();
        self.allocator.free(self.doc_root);
    }

    pub fn listenAndServe(self: *PreviewServer, port: u16) !void {
        const addr = try std.net.Address.parseIp4("127.0.0.1", port);
        var tcp = try std.net.Address.listen(addr, .{ .reuse_address = true });
        defer tcp.deinit();

        switch (self.log_mode) {
            .plain => std.debug.print("🔎 web-preview listening on http://127.0.0.1:{d}\n", .{port}),
            .json => logServerJSON("listen", &.{
                .{ "addr", "127.0.0.1" },
                .{ "port", blk: {
                    var b: [24]u8 = undefined;
                    break :blk std.fmt.bufPrint(&b, "{d}", .{port}) catch "0";
                } },
            }),
        }

        // --- TEST-ONLY: auto-stop after N ms if env var is set --------------
        const ms_opt: ?[]u8 = std.process.getEnvVarOwned(self.allocator, "DOCZ_TEST_AUTOSTOP_MS") catch null;
        if (ms_opt) |ms_s| {
            defer self.allocator.free(ms_s);
            const ms = std.fmt.parseInt(u64, ms_s, 10) catch 0;
            if (ms > 0) {
                _ = std.Thread.spawn(.{}, struct {
                    fn run(srv: *PreviewServer, p: u16, delay_ms: u64) void {
                        std.Thread.sleep(delay_ms * std.time.ns_per_ms);
                        srv.stop_requested = true;
                        pokeSelf(p) catch {};
                    }
                }.run, .{ self, port, ms }) catch {};
            }
        }

        // Hot-reload poller (best-effort)
        _ = std.Thread.spawn(.{}, pollFileAndBroadcast, .{ &self.broadcaster, "docs/SPEC.dcz", 250 }) catch {};

        while (true) {
            const net_conn = tcp.accept() catch |e| switch (e) {
                error.ConnectionAborted, error.ConnectionResetByPeer => continue,
                else => return e,
            };
            defer net_conn.stream.close();

            var req = receiveRequest(self.allocator, @constCast(&net_conn.stream)) catch |e| {
                if (e != error.BadRequest) {
                    std.debug.print("❌ receiveRequest error: {s}\n", .{@errorName(e)});
                }
                continue;
            };
            defer {
                self.allocator.free(req.method);
                self.allocator.free(req.target);
                if (req.headers.len != 0) self.allocator.free(req.headers);
            }

            const path = req.target;
            const bare_path = stripQuery(path);

            const is_hot = std.mem.eql(u8, bare_path, "/__docz_hot.txt");
            const is_favicon = std.mem.eql(u8, bare_path, "/favicon.ico");
            if (!is_hot and !is_favicon) {
                const pfx_len: usize = @min(path.len, @as(usize, 64));
                std.debug.print("→ {s} {s}\n", .{ path[0..pfx_len], path });
            }

            self.handle(&req) catch |he| {
                std.debug.print("❌ handler error: {s}\n", .{@errorName(he)});
                const msg = "Internal server error\n";
                _ = req.respond(msg, .{
                    .status = .internal_server_error,
                    .extra_headers = &.{.{ .name = "Content-Type", .value = "text/plain; charset=utf-8" }},
                }) catch {};
            };

            if (self.stop_requested) break;
        }
    }

    fn handle(self: *PreviewServer, req: *Request) !void {
        const path = req.target;

        if (std.mem.startsWith(u8, path, "/third_party/")) {
            const rel = path[1..];
            std.debug.print("  route=third_party hit={s}\n", .{rel});
            return self.serveFile(req, rel);
        }

        if (std.mem.eql(u8, stripQuery(path), "/ping")) {
            return req.respond("pong\n", .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/plain; charset=utf-8" }},
            });
        }

        // simple diagnostics endpoint for CI/health checks
        if (std.mem.eql(u8, stripQuery(path), "/healthz")) {
            const body = try std.fmt.allocPrint(self.allocator, "{{\"ok\":true,\"doc_root\":\"{s}\"}}", .{self.doc_root});
            defer self.allocator.free(body);
            return req.respond(body, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "application/json; charset=utf-8" }},
            });
        }

        if (std.mem.eql(u8, stripQuery(path), "/favicon.ico")) {
            return req.respond("", .{
                .status = .no_content,
                .extra_headers = &.{.{ .name = "Cache-Control", .value = "no-store" }},
            });
        }

        // test-only shutdown endpoint—flip flag so accept loop exits.
        if (std.mem.eql(u8, stripQuery(path), "/__docz_stop")) {
            self.stop_requested = true;
            return req.respond("stopping\n", .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/plain; charset=utf-8" }},
            });
        }

        // Placeholder SSE endpoint (non-streaming in this build)
        if (std.mem.eql(u8, stripQuery(path), "/hot")) {
            return handleSSE(req);
        }

        if (std.mem.startsWith(u8, path, "/render")) {
            const raw = queryParam(path, "path") orelse "docs/SPEC.dcz";
            const fs_path = try urlDecode(self.allocator, raw);
            defer self.allocator.free(fs_path);
            std.debug.print("  route=/render path={s}\n", .{fs_path});
            return self.serveRenderedFragment(req, fs_path);
        }

        if (std.mem.startsWith(u8, path, "/view")) {
            const raw = queryParam(path, "path") orelse "docs/SPEC.dcz";
            const fs_path = try urlDecode(self.allocator, raw);
            defer self.allocator.free(fs_path);
            std.debug.print("  route=/view path={s}\n", .{fs_path});
            return self.serveRenderedDcz(req, fs_path);
        }

        const safe_rel = try sanitizePath(self.allocator, path);
        defer self.allocator.free(safe_rel);

        if (safe_rel.len == 0 or std.mem.eql(u8, safe_rel, ".")) {
            return self.serveIndex(req);
        }

        const candidate_a = try join2(self.allocator, self.doc_root, safe_rel);
        defer self.allocator.free(candidate_a);
        if (fileExists(candidate_a)) {
            if (!std.mem.endsWith(u8, safe_rel, "__docz_hot.txt")) {
                std.debug.print("  route=static hit={s}\n", .{candidate_a});
            }
            return self.serveFile(req, candidate_a);
        }

        const rel_html = try withHtmlExt(self.allocator, safe_rel);
        defer self.allocator.free(rel_html);
        const candidate_b = try join2(self.allocator, self.doc_root, rel_html);
        defer self.allocator.free(candidate_b);
        if (fileExists(candidate_b)) {
            std.debug.print("  route=static hit={s}\n", .{candidate_b});
            return self.serveFile(req, candidate_b);
        }

        std.debug.print("  route=fallback → index\n", .{});
        return self.serveIndex(req);
    }

    fn handleSSE(req: *Request) !void {
        const body = "SSE endpoint placeholder (streaming disabled in this build).\n";
        return req.respond(body, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/plain; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
                .{ .name = "Connection", .value = "close" },
            },
        });
    }

    fn serveIndex(self: *PreviewServer, req: *Request) !void {
        const html = try buildIndexHtml(self.allocator);
        defer self.allocator.free(html);

        return req.respond(html, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
                .{ .name = "Connection", .value = "close" },
            },
        });
    }

    fn serveRenderedDcz(self: *PreviewServer, req: *Request, fs_path: []const u8) !void {
        var arena = std.heap.ArenaAllocator.init(self.allocator);
        defer arena.deinit();
        const A = arena.allocator();

        const t0 = std.time.milliTimestamp();
        const input = readFileAlloc(A, fs_path) catch |e| {
            std.debug.print("  read FAIL {s}: {s}\n", .{ fs_path, @errorName(e) });
            const body = try std.fmt.allocPrint(A, "<pre>Failed to read {s}: {s}</pre>", .{ fs_path, @errorName(e) });
            return req.respond(body, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        std.debug.print("  read ok {s} ({d} bytes, {d}ms)\n", .{ fs_path, input.len, std.time.milliTimestamp() - t0 });

        const t1 = std.time.milliTimestamp();
        const tokens = Tokenizer.tokenize(input, A) catch |e| {
            const msg = try std.fmt.allocPrint(
                A,
                "<pre>Tokenizer error: {s}\n(unterminated directive params or invalid syntax?)</pre>",
                .{@errorName(e)},
            );
            return req.respond(msg, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer Tokenizer.freeTokens(A, tokens);
        std.debug.print("  tokenize ok ({d} tokens, {d}ms)\n", .{ tokens.len, std.time.milliTimestamp() - t1 });

        const t2 = std.time.milliTimestamp();
        var ast = try Parser.parse(tokens, A);
        defer ast.deinit(A);
        std.debug.print("  parse ok ({d} nodes, {d}ms)\n", .{ ast.children.items.len, std.time.milliTimestamp() - t2 });

        const t3 = std.time.milliTimestamp();
        const html = try Renderer.renderHTML(&ast, A);
        std.debug.print("  render ok ({d} bytes, {d}ms)\n", .{ html.len, std.time.milliTimestamp() - t3 });

        return req.respond(html, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
            },
        });
    }

    fn serveRenderedFragment(self: *PreviewServer, req: *Request, fs_path: []const u8) !void {
        var arena = std.heap.ArenaAllocator.init(self.allocator);
        defer arena.deinit();
        const A = arena.allocator();

        const t0 = std.time.milliTimestamp();
        const input = readFileAlloc(A, fs_path) catch |e| {
            std.debug.print("  read FAIL {s}: {s}\n", .{ fs_path, @errorName(e) });
            const body = try std.fmt.allocPrint(A, "<pre>Failed to read {s}: {s}</pre>", .{ fs_path, @errorName(e) });
            return req.respond(body, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        std.debug.print("  read ok {s} ({d} bytes, {d}ms)\n", .{ fs_path, input.len, std.time.milliTimestamp() - t0 });

        const t1 = std.time.milliTimestamp();
        const tokens = Tokenizer.tokenize(input, A) catch |e| {
            const msg = try std.fmt.allocPrint(
                A,
                "<pre>Tokenizer error: {s}\n(unterminated directive params or invalid syntax?)</pre>",
                .{@errorName(e)},
            );
            return req.respond(msg, .{
                .status = .ok,
                .extra_headers = &.{.{ .name = "Content-Type", .value = "text/html; charset=utf-8" }},
            });
        };
        defer Tokenizer.freeTokens(A, tokens);
        std.debug.print("  tokenize ok ({d} tokens, {d}ms)\n", .{ tokens.len, std.time.milliTimestamp() - t1 });

        const t2 = std.time.milliTimestamp();
        var ast = try Parser.parse(tokens, A);
        defer ast.deinit(A);
        std.debug.print("  parse ok ({d} nodes, {d}ms)\n", .{ ast.children.items.len, std.time.milliTimestamp() - t2 });

        const t3 = std.time.milliTimestamp();
        const full = try Renderer.renderHTML(&ast, A);
        std.debug.print("  render ok ({d} bytes, {d}ms)\n", .{ full.len, std.time.milliTimestamp() - t3 });

        const t4 = std.time.milliTimestamp();
        const frag = try extractBodyFragment(A, full);
        std.debug.print("  extract body ok ({d} bytes, {d}ms)\n", .{ frag.len, std.time.milliTimestamp() - t4 });

        return req.respond(frag, .{
            .status = .ok,
            .extra_headers = &.{
                .{ .name = "Content-Type", .value = "text/html; charset=utf-8" },
                .{ .name = "Cache-Control", .value = "no-cache" },
            },
        });
    }

    fn serveFile(self: *PreviewServer, req: *Request, abs_path: []const u8) !void {
        var file = try std.fs.cwd().openFile(abs_path, .{});
        defer file.close();

        const stat = try file.stat();

        // Read file (simple, fine for tests and small assets)
        const body = try self.allocator.alloc(u8, stat.size);
        defer self.allocator.free(body);
        const n = try file.readAll(body);

        const ctype = mimeFromPath(abs_path);
        const is_third_party =
            std.mem.indexOf(u8, abs_path, "third_party/") != null or
            std.mem.startsWith(u8, abs_path, "third_party/");
        const cache_header =
            if (is_third_party) "public, max-age=31536000, immutable" else "no-cache";

        // Weak ETag based on mtime + size
        const mtime_u64: u64 = @intCast(stat.mtime);
        const etag = try std.fmt.allocPrint(self.allocator, "W/\"{x}-{d}\"", .{ mtime_u64, stat.size });
        defer self.allocator.free(etag);

        // 304 Not Modified if client ETag matches
        if (headerValue(req.headers, "If-None-Match")) |inm| {
            if (std.mem.eql(u8, inm, etag)) {
                const extra_304 = [_]Header{
                    .{ .name = "ETag", .value = etag },
                    .{ .name = "Cache-Control", .value = cache_header },
                };
                return req.respond("", .{
                    .status = .not_modified,
                    .extra_headers = &extra_304,
                });
            }
        }

        // Single-range support
        var status: Status = .ok;
        var send_slice: []const u8 = body[0..n];
        var extra_headers: [5]Header = .{
            .{ .name = "Content-Type", .value = ctype },
            .{ .name = "Cache-Control", .value = cache_header },
            .{ .name = "ETag", .value = etag },
            .{ .name = "Accept-Ranges", .value = "bytes" },
            .{ .name = "Content-Range", .value = "" }, // only set for 206/416
        };
        var extra_len: usize = 4; // append Content-Range if used

        if (headerValue(req.headers, "Range")) |rng| {
            if (parseSingleRange(rng, @intCast(n))) |r| {
                const lo: usize = @intCast(r.start);
                const hi: usize = @intCast(r.end);
                if (lo <= hi and hi < n) {
                    send_slice = body[lo .. hi + 1];
                    const cr = try std.fmt.allocPrint(self.allocator, "bytes {d}-{d}/{d}", .{ r.start, r.end, n });
                    defer self.allocator.free(cr);
                    extra_headers[4] = .{ .name = "Content-Range", .value = cr };
                    extra_len = 5;
                    status = .partial_content;
                }
            } else {
                // Invalid or unsatisfiable → 416
                const cr_all = try std.fmt.allocPrint(self.allocator, "bytes */{d}", .{n});
                defer self.allocator.free(cr_all);
                extra_headers[4] = .{ .name = "Content-Range", .value = cr_all };
                extra_len = 5;
                return req.respond("", .{
                    .status = .range_not_satisfiable,
                    .extra_headers = extra_headers[0..extra_len],
                });
            }
        }

        return req.respond(send_slice, .{
            .status = status,
            .extra_headers = extra_headers[0..extra_len],
        });
    }
};

// ----------------------------
// Helpers
// ----------------------------

fn headerValueCI(headers: []const u8, name: []const u8) ?[]const u8 {
    var it = std.mem.splitScalar(u8, headers, '\n');
    while (it.next()) |line_with_cr| {
        const line = if (line_with_cr.len > 0 and line_with_cr[line_with_cr.len - 1] == '\r')
            line_with_cr[0 .. line_with_cr.len - 1]
        else
            line_with_cr;

        if (line.len < name.len + 1) continue; // needs at least "name:"
        if (!std.ascii.startsWithIgnoreCase(line, name)) continue;
        if (line[name.len] != ':') continue;

        var v = line[name.len + 1 ..]; // after ':'
        while (v.len > 0 and (v[0] == ' ' or v[0] == '\t')) v = v[1..];
        return v;
    }
    return null;
}

fn headerValue(headers: []const u8, name_ci: []const u8) ?[]const u8 {
    if (headers.len == 0) return null;
    var it = std.mem.splitScalar(u8, headers, '\n');
    while (it.next()) |line_with_cr| {
        var line = line_with_cr;
        if (line.len == 0) continue;
        if (line[line.len - 1] == '\r') line = line[0 .. line.len - 1];
        const colon = std.mem.indexOfScalar(u8, line, ':') orelse continue;
        const key = line[0..colon];
        if (std.ascii.eqlIgnoreCase(key, name_ci)) {
            var v = line[colon + 1 ..];
            while (v.len > 0 and (v[0] == ' ' or v[0] == '\t')) v = v[1..];
            return v;
        }
    }
    return null;
}

const Range = struct { start: u64, end: u64 }; // inclusive

fn parseSingleRange(hval: []const u8, size: u64) ?Range {
    // Expect: "bytes=<start>-<end>" with either side optionally blank (suffix)
    if (!std.mem.startsWith(u8, hval, "bytes=")) return null;
    const spec = hval[6..];

    const dash = std.mem.indexOfScalar(u8, spec, '-') orelse return null;
    const a = spec[0..dash];
    const b = spec[dash + 1 ..];

    if (a.len == 0 and b.len == 0) return null;

    if (a.len == 0) {
        // suffix: last N bytes
        const n = std.fmt.parseInt(u64, b, 10) catch return null;
        if (n == 0) return null;
        const start: u64 = if (n >= size) 0 else size - n;
        const end: u64 = if (size == 0) 0 else size - 1;
        if (start > end) return null;
        return .{ .start = start, .end = end };
    } else {
        const start = std.fmt.parseInt(u64, a, 10) catch return null;
        const end: u64 = if (b.len == 0)
            (if (size == 0) 0 else size - 1)
        else
            (std.fmt.parseInt(u64, b, 10) catch return null);

        if (start >= size) return null;
        if (end < start) return null;

        const clamped_end = if (end >= size) size - 1 else end;
        return .{ .start = start, .end = clamped_end };
    }
}

fn trimTrailingSlash(allocator: std.mem.Allocator, s: []const u8) ![]const u8 {
    var end = s.len;
    while (end > 0 and s[end - 1] == '/') end -= 1;
    return allocator.dupe(u8, s[0..end]);
}

fn sanitizePath(allocator: std.mem.Allocator, raw: []const u8) ![]u8 {
    var norm = std.ArrayListUnmanaged(u8){};
    defer norm.deinit(allocator);
    try norm.ensureTotalCapacity(allocator, raw.len);
    for (raw) |c| try norm.append(allocator, if (c == '\\') '/' else c);

    var segs = std.ArrayListUnmanaged([]const u8){};
    defer segs.deinit(allocator);

    var it = std.mem.splitScalar(u8, norm.items, '/');
    var depth: usize = 0;
    while (it.next()) |seg| {
        if (seg.len == 0 or std.mem.eql(u8, seg, ".")) continue;
        if (std.mem.eql(u8, seg, "..")) {
            if (depth == 0) return allocator.alloc(u8, 0);
            segs.items.len -= 1;
            depth -= 1;
            continue;
        }
        var ok = true;
        for (seg) |ch| {
            if (!(std.ascii.isAlphanumeric(ch) or ch == '-' or ch == '_' or ch == '.')) {
                ok = false;
                break;
            }
        }
        if (!ok) return allocator.alloc(u8, 0);
        try segs.append(allocator, seg);
        depth += 1;
    }

    var out = std.ArrayListUnmanaged(u8){};
    defer out.deinit(allocator);
    var first = true;
    for (segs.items) |seg| {
        if (!first) try out.append(allocator, '/');
        first = false;
        try out.appendSlice(allocator, seg);
    }
    return out.toOwnedSlice(allocator);
}

fn withHtmlExt(allocator: std.mem.Allocator, rel: []const u8) ![]const u8 {
    return std.fmt.allocPrint(allocator, "{s}.html", .{rel});
}

fn join2(allocator: std.mem.Allocator, a: []const u8, b: []const u8) ![]const u8 {
    if (a.len == 0) return allocator.dupe(u8, b);
    if (b.len == 0) return allocator.dupe(u8, a);
    if (a[a.len - 1] == '/') return std.fmt.allocPrint(allocator, "{s}{s}", .{ a, b });
    return std.fmt.allocPrint(allocator, "{s}/{s}", .{ a, b });
}

fn fileExists(abs_path: []const u8) bool {
    std.fs.cwd().access(abs_path, .{}) catch return false;
    return true;
}

fn mimeFromPath(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, ".html") or std.mem.endsWith(u8, path, ".htm"))
        return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".css")) return "text/css; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".js")) return "text/javascript; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".json")) return "application/json; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".svg")) return "image/svg+xml";
    if (std.mem.endsWith(u8, path, ".png")) return "image/png";
    if (std.mem.endsWith(u8, path, ".jpg") or std.mem.endsWith(u8, path, ".jpeg")) return "image/jpeg";
    if (std.mem.endsWith(u8, path, ".gif")) return "image/gif";
    if (std.mem.endsWith(u8, path, ".txt")) return "text/plain; charset=utf-8";

    // useful extras
    if (std.mem.endsWith(u8, path, ".ico")) return "image/x-icon";
    if (std.mem.endsWith(u8, path, ".webp")) return "image/webp";
    if (std.mem.endsWith(u8, path, ".woff2")) return "font/woff2";
    if (std.mem.endsWith(u8, path, ".map")) return "application/json; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".wasm")) return "application/wasm";

    return "application/octet-stream";
}

fn stripQuery(p: []const u8) []const u8 {
    return p[0 .. std.mem.indexOfScalar(u8, p, '?') orelse p.len];
}

fn queryParam(target: []const u8, key: []const u8) ?[]const u8 {
    const qpos = std.mem.indexOfScalar(u8, target, '?') orelse return null;
    var it = std.mem.splitScalar(u8, target[qpos + 1 ..], '&');
    while (it.next()) |kv| {
        if (kv.len == 0) continue;
        const eq = std.mem.indexOfScalar(u8, kv, '=') orelse continue;
        if (std.mem.eql(u8, kv[0..eq], key)) return kv[eq + 1 ..];
    }
    return null;
}

fn urlDecode(allocator: std.mem.Allocator, enc: []const u8) ![]u8 {
    var out = try allocator.alloc(u8, enc.len);
    var j: usize = 0;
    var i: usize = 0;
    while (i < enc.len) : (i += 1) {
        const c = enc[i];
        if (c == '%' and i + 2 < enc.len) {
            const h1 = enc[i + 1];
            const h2 = enc[i + 2];
            const v1 = hexVal(h1) orelse blk: {
                out[j] = c;
                j += 1;
                break :blk null;
            };
            const v2 = hexVal(h2) orelse blk: {
                out[j] = c;
                j += 1;
                break :blk null;
            };
            if (v1 != null and v2 != null) {
                out[j] = (@as(u8, v1.?) << 4) | @as(u8, v2.?);
                j += 1;
                i += 2;
                continue;
            }
        }
        out[j] = c;
        j += 1;
    }
    return allocator.realloc(out, j);
}

fn hexVal(c: u8) ?u4 {
    return switch (c) {
        '0'...'9' => @intCast(c - '0'),
        'a'...'f' => @intCast(10 + (c - 'a')),
        'A'...'F' => @intCast(10 + (c - 'A')),
        else => null,
    };
}

fn readFileAlloc(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    return std.fs.cwd().readFileAlloc(path, allocator, @enumFromInt(1 << 26));
}

fn pollFileAndBroadcast(b: *hot.Broadcaster, path: []const u8, ms: u64) !void {
    var last: u64 = 0;
    while (true) {
        const mt = fileMtime(path) catch 0;
        if (mt != 0 and mt != last) {
            if (last != 0) try b.broadcast("reload", path);
            last = mt;
        }
        std.Thread.sleep(ms * std.time.ns_per_ms);
    }
}

fn fileMtime(path: []const u8) !u64 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();
    const s = try f.stat();
    return @intCast(s.mtime);
}

fn extractBodyFragment(allocator: std.mem.Allocator, full: []const u8) ![]u8 {
    const open_idx = std.mem.indexOf(u8, full, "<body");
    if (open_idx == null) return allocator.dupe(u8, full);

    const after_open_gt = std.mem.indexOfScalarPos(u8, full, open_idx.?, '>') orelse return allocator.dupe(u8, full);
    const rest = full[after_open_gt + 1 ..];
    const close_idx_rel = std.mem.indexOf(u8, rest, "</body>");
    if (close_idx_rel == null) return allocator.dupe(u8, rest);

    const inner = rest[0..close_idx_rel.?];
    return allocator.dupe(u8, inner);
}

fn buildIndexHtml(allocator: std.mem.Allocator) ![]u8 {
    const tpl =
        \\<!DOCTYPE html>
        \\<html>
        \\<head>
        \\  <meta charset="UTF-8" />
        \\  <meta name="viewport" content="width=device-width, initial-scale=1" />
        \\  <title>Docz Web Preview</title>
        \\  <script>
        \\    (function () {
        \\      const qs = new URLSearchParams(location.search);
        \\      const path = qs.get('path') || 'docs/SPEC.dcz';
        \\      const url = '/view?path=' + encodeURIComponent(path);
        \\      location.replace(url);
        \\    })();
        \\  </script>
        \\</head>
        \\<body>
        \\  <noscript>
        \\    <p>Preview requires JS to redirect. Open <code>/view?path=docs/SPEC.dcz</code>.</p>
        \\  </noscript>
        \\</body>
        \\</html>
    ;
    return allocator.dupe(u8, tpl);
}

// Wake up accept() by making a quick local connection.
fn pokeSelf(port: u16) !void {
    const addr = std.net.Address.initIp4(.{ 127, 0, 0, 1 }, port);
    var sock = try std.net.tcpConnectToAddress(addr);
    sock.close();
}

<<<

`timeout.zig`: >>>

const std = @import("std");

/// A thin deadline-based reader wrapper. If now() passes deadline_ns, returns error.Timeout.
pub fn DeadlineReader(comptime T: type) type {
    return struct {
        inner: T,
        clock: *std.time.Timer,
        deadline_ns: u64,

        pub fn init(inner: T, clock: *std.time.Timer, ms: u32) @This() {
            return .{
                .inner = inner,
                .clock = clock,
                .deadline_ns = clock.read() + (std.time.ns_per_ms * @as(u64, ms)),
            };
        }

        pub fn read(self: *@This(), buf: []u8) !usize {
            if (self.clock.read() > self.deadline_ns) return error.Timeout;
            // Non-blocking deadline enforcement would need OS-specific polling;
            // we keep it simple: rely on short OS read and re-check deadline.
            const n = try self.inner.read(buf);
            if (self.clock.read() > self.deadline_ns) return error.Timeout;
            return n;
        }
    };
}

<<<

`hash_manifest.zig`: >>>

const std = @import("std");

/// Minimal, stable helper used by integration/e2e to hash a manifest file.
/// This is a placeholder implementation that can be evolved later.
pub fn sha256File(allocator: std.mem.Allocator, path: []const u8) ![32]u8 {
    const bytes = try std.fs.cwd().readFileAlloc(path, allocator, 1 << 26);
    defer allocator.free(bytes);
    var out: [32]u8 = undefined;
    std.crypto.hash.sha2.Sha256.hash(bytes, &out);
    return out;
}

pub fn hexLower(b: []const u8, allocator: std.mem.Allocator) ![]u8 {
    const s = try allocator.alloc(u8, b.len * 2);
    _ = std.fmt.bufPrint(s, "{s}", .{std.fmt.fmtSliceHexLower(b)}) catch unreachable;
    return s;
}

test "sha256File exists-or-empty semantics" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const A = gpa.allocator();

    // Create a temp file
    var tmp = try std.testing.tmpDir(.{});
    defer tmp.cleanup();

    const p = "m.txt";
    try tmp.dir.writeFile(p, "abc");

    var h = try sha256File(A, try tmp.dir.realpathAlloc(A, p));
    // Known sha256("abc")
    const expected = [_]u8{ 0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23, 0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, 0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad };
    try std.testing.expect(std.mem.eql(u8, &h, &expected));
}

<<<

`html.zig`: >>>

const std = @import("std");
const ASTNode = @import("../parser/ast.zig").ASTNode;
const NodeType = @import("../parser/ast.zig").NodeType;

// -----------------------------------------------------------------------------
// Small writer adapter for ArrayList(u8) on this Zig version
// (Avoids std.ArrayList.writer() and std.io.Writer differences between builds.)
// -----------------------------------------------------------------------------
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    fn writeAll(self: *const ListWriter, bytes: []const u8) !void {
        try self.list.appendSlice(self.alloc, bytes);
    }

    fn print(self: *const ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// -----------------------------------------------------------------------------
// Asset options + VENDOR.lock reader
// -----------------------------------------------------------------------------

pub const RenderAssets = struct {
    enable_katex: bool = true,
    enable_tailwind: bool = true,
    third_party_root: []const u8 = "third_party",
};

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8, max: usize) ![]u8 {
    return std.fs.cwd().readFileAlloc(path, alloc, @enumFromInt(max));
}

/// Very small JSON helper: find string value for a top-level key, assuming
/// a simple object like: {"katex":"0.16.11","tailwind":"docz-theme-1.0.0"}
/// This intentionally avoids std.json for stability across Zig versions.
fn findJsonStringValue(buf: []const u8, key: []const u8) ?[]const u8 {
    // Look for "key"
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;

    // Find colon after key
    var i: usize = key_i + quoted_key.len;
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1;

    // Find opening quote of the value
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != '"') return null;
    i += 1; // start of value

    const start = i;
    // Find closing quote (no escape handling needed for plain versions/labels)
    while (i < buf.len and buf[i] != '"') : (i += 1) {}
    if (i >= buf.len) return null;

    return buf[start..i];
}

fn readVendorLock(alloc: std.mem.Allocator, third_party_root: []const u8) !struct {
    katex: ?[]const u8,
    tailwind: ?[]const u8,
} {
    const lock_path = try std.fs.path.join(alloc, &.{ third_party_root, "VENDOR.lock" });
    defer alloc.free(lock_path);

    const buf = readFileAlloc(alloc, lock_path, 1 << 16) catch |e| {
        if (e == error.FileNotFound) return .{ .katex = null, .tailwind = null };
        return e;
    };
    defer alloc.free(buf);

    const k = findJsonStringValue(buf, "katex");
    const t = findJsonStringValue(buf, "tailwind");

    return .{
        .katex = if (k) |s| try alloc.dupe(u8, s) else null,
        .tailwind = if (t) |s| try alloc.dupe(u8, s) else null,
    };
}

/// Emit <link>/<script> tags for vendored assets based on VENDOR.lock.
pub fn emitHeadAssets(alloc: std.mem.Allocator, w: anytype, opts: RenderAssets) !void {
    const lock = try readVendorLock(alloc, opts.third_party_root);
    defer if (lock.katex) |s| alloc.free(s);
    defer if (lock.tailwind) |s| alloc.free(s);

    if (opts.enable_tailwind) {
        if (lock.tailwind) |ver| {
            try w.print(
                "<link rel=\"stylesheet\" href=\"/third_party/tailwind/docz-theme-{s}/css/docz.tailwind.css\"/>\n",
                .{ver},
            );
        }
    }
    if (opts.enable_katex) {
        if (lock.katex) |ver| {
            try w.print(
                \\<link rel="stylesheet" href="/third_party/katex/{s}/dist/katex.min.css"/>
                \\<script defer src="/third_party/katex/{s}/dist/katex.min.js"></script>
                \\
            , .{ ver, ver });
        }
    }
}

// -----------------------------------------------------------------------------
// Existing helpers (kept)
// -----------------------------------------------------------------------------

fn lessStr(_: void, a: []const u8, b: []const u8) bool {
    return std.mem.lessThan(u8, a, b);
}

fn styleKeyPriority(k: []const u8) u8 {
    if (std.mem.eql(u8, k, "font-size")) return 0; // ensure font-size first
    if (std.mem.eql(u8, k, "color")) return 1; // then color
    return 100; // others later
}

fn styleKeyLess(_: void, a: []const u8, b: []const u8) bool {
    const pa = styleKeyPriority(a);
    const pb = styleKeyPriority(b);
    if (pa != pb) return pa < pb; // priority first
    return std.mem.lessThan(u8, a, b); // then lexicographic
}

/// Converts attributes → inline CSS string; excludes non-style keys (like "mode")
fn buildInlineStyle(attributes: std.StringHashMap([]const u8), allocator: std.mem.Allocator) ![]u8 {
    var keys = std.ArrayList([]const u8){};
    defer keys.deinit(allocator);

    var it = attributes.iterator();
    while (it.next()) |entry| {
        const k = entry.key_ptr.*;
        if (std.mem.eql(u8, k, "mode")) continue; // exclude control key
        try keys.append(allocator, k);
    }

    // sort with priority
    std.mem.sort([]const u8, keys.items, {}, styleKeyLess);

    var out = std.ArrayList(u8){};
    defer out.deinit(allocator);
    var lw = ListWriter{ .list = &out, .alloc = allocator };

    var first = true;
    for (keys.items) |k| {
        const v = attributes.get(k).?;
        if (!first) try lw.print(";", .{});
        try lw.print("{s}:{s}", .{ k, v });
        first = false;
    }
    try lw.print(";", .{}); // trailing ; expected by the test

    return try out.toOwnedSlice(allocator);
}

/// Converts style-def content into CSS
fn buildGlobalCSS(styleContent: []const u8, allocator: std.mem.Allocator) ![]u8 {
    var builder = std.ArrayList(u8){};
    defer builder.deinit(allocator);
    var lw = ListWriter{ .list = &builder, .alloc = allocator };

    var lines = std.mem.tokenizeScalar(u8, styleContent, '\n');
    while (lines.next()) |line| {
        var trimmed = std.mem.trim(u8, line, " \t\r");
        if (trimmed.len == 0) continue;

        const colonIndex = std.mem.indexOfScalar(u8, trimmed, ':') orelse continue;
        const className = std.mem.trim(u8, trimmed[0..colonIndex], " \t");
        const propsRaw = std.mem.trim(u8, trimmed[colonIndex + 1 ..], " \t");

        try lw.print(".{s} {{ ", .{className});

        var propsIter = std.mem.tokenizeScalar(u8, propsRaw, ',');
        var first = true;
        while (propsIter.next()) |prop| {
            var cleanProp = std.mem.trim(u8, prop, " \t");
            const eqIndex = std.mem.indexOfScalar(u8, cleanProp, '=') orelse continue;
            const key = std.mem.trim(u8, cleanProp[0..eqIndex], " \t");
            const value = std.mem.trim(u8, cleanProp[eqIndex + 1 ..], " \t\"");

            if (!first) try lw.print(" ", .{});
            try lw.print("{s}:{s};", .{ key, value });
            first = false;
        }

        try lw.print(" }}\n", .{});
    }

    return try builder.toOwnedSlice(allocator);
}

// -----------------------------------------------------------------------------
// Renderer
// -----------------------------------------------------------------------------

pub fn renderHTML(root: *const ASTNode, allocator: std.mem.Allocator) ![]u8 {
    var list = std.ArrayList(u8){};
    var w = ListWriter{ .list = &list, .alloc = allocator };

    try w.print("<!DOCTYPE html>\n<html>\n<head>\n", .{});

    // Meta information
    for (root.children.items) |node| {
        if (node.node_type == .Meta) {
            var it = node.attributes.iterator();
            while (it.next()) |entry| {
                if (std.mem.eql(u8, entry.key_ptr.*, "title")) {
                    try w.print("<title>{s}</title>\n", .{entry.value_ptr.*});
                } else {
                    try w.print("<meta name=\"{s}\" content=\"{s}\">\n", .{
                        entry.key_ptr.*, entry.value_ptr.*,
                    });
                }
            }
        }
    }

    // Global CSS (from Style nodes in "global" mode)
    var globalCSSBuilder = std.ArrayList(u8){};
    var gw = ListWriter{ .list = &globalCSSBuilder, .alloc = allocator };

    for (root.children.items) |node| {
        if (node.node_type == .Style) {
            if (node.attributes.get("mode")) |mode| {
                if (std.mem.eql(u8, mode, "global")) {
                    const css = try buildGlobalCSS(node.content, allocator);
                    defer allocator.free(css);
                    try gw.print("{s}\n", .{css});
                }
            }
        }
    }

    if (globalCSSBuilder.items.len > 0) {
        try w.print("<style>\n{s}</style>\n", .{globalCSSBuilder.items});
    }
    globalCSSBuilder.deinit(allocator);

    // Vendored assets (Tailwind / KaTeX), read from VENDOR.lock if present.
    try emitHeadAssets(allocator, w, .{});

    try w.print("</head>\n<body>\n", .{});

    // Body rendering
    for (root.children.items) |node| {
        switch (node.node_type) {
            .Meta => {
                // Meta already emitted into <head>; skip in body to avoid noise.
            },
            .Heading => {
                const level = node.attributes.get("level") orelse "1";
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                try w.print("<h{s}>{s}</h{s}>\n", .{ level, text, level });
            },
            .Content => {
                try w.print("<p>{s}</p>\n", .{node.content});
            },
            .CodeBlock => {
                try w.print("<pre><code>{s}</code></pre>\n", .{node.content});
            },
            .Math => {
                try w.print("<div class=\"math\">{s}</div>\n", .{node.content});
            },
            .Media => {
                const src = node.attributes.get("src") orelse "";
                try w.print("<img src=\"{s}\" />\n", .{src});
            },
            .Import => {
                const path = node.attributes.get("href") orelse "";
                try w.print("<link rel=\"stylesheet\" href=\"{s}\">\n", .{path});
            },
            .Style => {
                if (node.attributes.get("mode")) |mode| {
                    if (std.mem.eql(u8, mode, "inline")) {
                        const inlineCSS = try buildInlineStyle(node.attributes, allocator);
                        defer allocator.free(inlineCSS);
                        try w.print("<span style=\"{s}\">{s}</span>\n", .{ inlineCSS, node.content });
                    }
                }
            },
            else => {
                try w.print("<!-- Unhandled node: {s} -->\n", .{@tagName(node.node_type)});
            },
        }
    }

    try w.print("</body>\n</html>\n", .{});
    return try list.toOwnedSlice(allocator);
}

// ----------------------
// ✅ Tests
// ----------------------

test "Render HTML with inline style" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var root = ASTNode.init(allocator, NodeType.Document);
    defer root.deinit(allocator);

    var styleNode = ASTNode.init(allocator, NodeType.Style);
    try styleNode.attributes.put("mode", "inline");
    try styleNode.attributes.put("font-size", "18px");
    try styleNode.attributes.put("color", "blue");
    styleNode.content = "Styled Text";
    try root.children.append(allocator, styleNode);

    const html = try renderHTML(&root, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "style=\"font-size:18px;color:blue;\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "Styled Text") != null);
}

test "Render HTML with global style-def" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    var root = ASTNode.init(allocator, NodeType.Document);
    defer root.deinit(allocator);

    var globalStyleNode = ASTNode.init(allocator, NodeType.Style);
    // Zig 0.16 StringHashMap.put takes (key, value)
    try globalStyleNode.attributes.put("mode", "global");
    globalStyleNode.content =
        \\heading-level-1: font-size=36px, font-weight=bold
        \\body-text: font-family="Inter", line-height=1.6
    ;
    try root.children.append(allocator, globalStyleNode);

    const html = try renderHTML(&root, allocator);
    defer allocator.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, ".heading-level-1") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, ".body-text") != null);
}

<<<

`manager.zig`: >>>

const std = @import("std");

pub const Plugin = struct {
    name: []const u8,
    // Use function pointers so the struct is a runtime type (not comptime-only).
    onRegister: ?*const fn () void = null,
    onRender: ?*const fn ([]u8) []u8 = null,
};

pub const PluginManager = struct {
    allocator: std.mem.Allocator,
    plugins: std.ArrayList(Plugin),

    /// Initialize the PluginManager with a given allocator
    pub fn init(allocator: std.mem.Allocator) PluginManager {
        return .{
            .allocator = allocator,
            .plugins = std.ArrayList(Plugin){}, // no .init() on this Zig build
        };
    }

    /// Properly free all allocated resources
    pub fn deinit(self: *PluginManager) void {
        self.plugins.deinit(self.allocator);
    }

    /// Add a new plugin to the manager
    pub fn addPlugin(self: *PluginManager, plugin: Plugin) !void {
        try self.plugins.append(self.allocator, plugin);
    }

    /// Execute all registered onRegister hooks
    pub fn registerHooks(self: *PluginManager) void {
        for (self.plugins.items) |plugin| {
            if (plugin.onRegister) |hook| {
                hook();
            }
        }
    }

    /// Apply all onRender hooks to the given HTML input
    /// Returns a duplicated mutable buffer; caller must free.
    pub fn applyRenderHooks(self: *PluginManager, html: []const u8) ![]u8 {
        var result = try self.allocator.dupe(u8, html); // Create mutable copy
        // IMPORTANT: We return this buffer to caller; caller must free it.
        for (self.plugins.items) |plugin| {
            if (plugin.onRender) |hook| {
                result = hook(result);
            }
        }
        return result;
    }
};

// ----------------------
// Tests
// ----------------------
var called_register: bool = false;
var called_render: bool = false;

fn onRegisterHook() void {
    called_register = true;
}

fn onRenderHook(html: []u8) []u8 {
    called_render = true;
    return html;
}

test "PluginManager adds and applies hooks" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var manager = PluginManager.init(A);
    defer manager.deinit();

    // Reset global flags
    called_register = false;
    called_render = false;

    const plugin = Plugin{
        .name = "test-plugin",
        .onRegister = &onRegisterHook,
        .onRender = &onRenderHook,
    };

    try manager.addPlugin(plugin);
    manager.registerHooks();

    const output = try manager.applyRenderHooks("dummy");
    defer A.free(output);

    try std.testing.expect(called_register);
    try std.testing.expect(called_render);
}

<<<

`ast.zig`: >>>

const std = @import("std");

pub const NodeType = enum {
    Document,
    Meta,
    Heading,
    Content,
    CodeBlock,
    Math,
    Media,
    Import,
    Style, // semantic style application: @style(name) ... @end
    Css, // raw CSS block: @css() ... @end
    StyleDef, // semantic alias definitions: @style-def() ... @end
    Unknown, // future-proofing: retain unknown directives losslessly
};

pub const ASTNode = struct {
    node_type: NodeType,
    content: []const u8 = "",
    owns_content: bool = false,
    allocator: ?std.mem.Allocator = null,
    attributes: std.StringHashMap([]const u8),
    children: std.ArrayList(ASTNode),

    pub fn init(allocator: std.mem.Allocator, node_type: NodeType) ASTNode {
        return ASTNode{
            .node_type = node_type,
            .content = "",
            .owns_content = false,
            .allocator = allocator,
            .attributes = std.StringHashMap([]const u8).init(allocator),
            .children = std.ArrayList(ASTNode){},
        };
    }

    pub fn deinit(self: *ASTNode, alloc: std.mem.Allocator) void {
        // children first
        var i: usize = 0;
        while (i < self.children.items.len) : (i += 1) {
            self.children.items[i].deinit(alloc);
        }
        self.children.deinit(alloc);
        self.attributes.deinit();

        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        self.content = "";
        self.owns_content = false;
    }

    pub fn addChild(self: *ASTNode, alloc: std.mem.Allocator, child: ASTNode) !void {
        try self.children.append(alloc, child);
    }

    pub fn setContentBorrowed(self: *ASTNode, slice: []const u8) void {
        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        self.content = slice;
        self.owns_content = false;
    }

    pub fn setContentOwned(self: *ASTNode, allocator: std.mem.Allocator, slice: []const u8) !void {
        if (self.owns_content and self.content.len > 0) {
            if (self.allocator) |a| a.free(self.content);
        }
        const dup = try allocator.dupe(u8, slice);
        self.content = dup;
        self.owns_content = true;
        self.allocator = allocator;
    }

    pub fn addAttr(self: *ASTNode, key: []const u8, value: []const u8) !void {
        try self.attributes.put(key, value);
    }

    pub fn getAttr(self: *const ASTNode, key: []const u8) ?[]const u8 {
        if (self.attributes.get(key)) |v| return v;
        return null;
    }

    pub fn isBlockLike(self: *const ASTNode) bool {
        return switch (self.node_type) {
            .CodeBlock, .Math, .Style, .Css, .StyleDef => true,
            else => false,
        };
    }

    pub fn isHeadAsset(self: *const ASTNode) bool {
        return switch (self.node_type) {
            .Import, .Css, .Meta => true,
            else => false,
        };
    }

    pub fn cloneDeep(self: *const ASTNode, allocator: std.mem.Allocator) !ASTNode {
        var out = ASTNode.init(allocator, self.node_type);
        if (self.content.len > 0) {
            try out.setContentOwned(allocator, self.content);
        }
        var it = self.attributes.iterator();
        while (it.next()) |entry| {
            const k = try allocator.dupe(u8, entry.key_ptr.*);
            const v = try allocator.dupe(u8, entry.value_ptr.*);
            try out.attributes.put(k, v);
        }
        for (self.children.items) |child| {
            const dup_child = try child.cloneDeep(allocator);
            try out.children.append(allocator, dup_child);
        }
        return out;
    }

    pub fn parseStyleAliases(self: *const ASTNode, allocator: std.mem.Allocator) !std.StringHashMap([]const u8) {
        var map = std.StringHashMap([]const u8).init(allocator);
        errdefer {
            var it_free = map.iterator();
            while (it_free.next()) |e| {
                allocator.free(e.key_ptr.*);
                allocator.free(e.value_ptr.*);
            }
            map.deinit();
        }

        if (self.node_type != .StyleDef or self.content.len == 0) {
            return map;
        }

        var it = std.mem.splitScalar(u8, self.content, '\n');
        while (it.next()) |line_raw| {
            const line = std.mem.trim(u8, line_raw, " \t\r");
            if (line.len == 0 or line[0] == '#') continue;

            const colon_idx_opt = std.mem.indexOfScalar(u8, line, ':');
            if (colon_idx_opt == null) continue;
            const colon_idx = colon_idx_opt.?;

            const alias_trim = std.mem.trim(u8, line[0..colon_idx], " \t");
            const rhs = std.mem.trim(u8, line[colon_idx + 1 ..], " \t");
            if (alias_trim.len == 0 or rhs.len == 0) continue;

            const alias_owned = try allocator.dupe(u8, alias_trim);
            const classes_owned = try allocator.dupe(u8, rhs);

            const gop = try map.getOrPut(alias_owned);
            if (gop.found_existing) {
                allocator.free(alias_owned);
                allocator.free(gop.value_ptr.*);
                gop.value_ptr.* = classes_owned;
            } else {
                gop.key_ptr.* = alias_owned;
                gop.value_ptr.* = classes_owned;
            }
        }

        return map;
    }
};

// -------------
// Unit Tests
// -------------
test "ASTNode init and deinit with attributes and children" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, .Document);
    defer root.deinit(A);

    var heading = ASTNode.init(A, .Heading);
    heading.content = "Docz Title";
    try heading.attributes.put("level", "2");
    try root.addChild(A, heading);

    try std.testing.expect(root.children.items.len == 1);
    try std.testing.expect(std.mem.eql(u8, root.children.items[0].content, "Docz Title"));
    try std.testing.expect(root.children.items[0].attributes.contains("level"));
}

test "Css node isBlockLike and head asset" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var css = ASTNode.init(A, .Css);
    defer css.deinit(A);
    try css.setContentOwned(A,
        \\.card { border: 1px solid #ccc; }
    );

    try std.testing.expect(css.isBlockLike());
    try std.testing.expect(css.isHeadAsset());
    try std.testing.expect(css.owns_content);
    try std.testing.expect(std.mem.indexOfScalar(u8, css.content, '{') != null);
}

test "StyleDef parsing: alias → classes" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var def = ASTNode.init(A, .StyleDef);
    defer def.deinit(A);
    try def.setContentOwned(A,
        \\# comment
        \\heading-1: h1-xl h1-weight
        \\body-text: prose max-w-none
        \\  malformed line without colon
        \\title:   text-2xl   font-bold
    );

    var aliases = try def.parseStyleAliases(A);
    defer {
        var it = aliases.iterator();
        while (it.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        aliases.deinit();
    }

    try std.testing.expect(aliases.count() == 3);
    try std.testing.expect(std.mem.eql(u8, aliases.get("heading-1").?, "h1-xl h1-weight"));
    try std.testing.expect(std.mem.eql(u8, aliases.get("body-text").?, "prose max-w-none"));
    try std.testing.expect(std.mem.eql(u8, aliases.get("title").?, "text-2xl   font-bold"));
}

<<<

`parser.zig`: >>>

const std = @import("std");
const Token = @import("tokenizer.zig").Token;
const TokenType = @import("tokenizer.zig").TokenType;
const ASTNode = @import("ast.zig").ASTNode;
const NodeType = @import("ast.zig").NodeType;

/// Maps a directive string (e.g. "@meta") to a NodeType.
/// Includes simple aliases like "@css" → Style.
fn directiveToNodeType(directive: []const u8) NodeType {
    if (std.mem.eql(u8, directive, "@meta")) return NodeType.Meta;
    if (std.mem.eql(u8, directive, "@heading")) return NodeType.Heading;
    if (std.mem.eql(u8, directive, "@code")) return NodeType.CodeBlock;
    if (std.mem.eql(u8, directive, "@math")) return NodeType.Math;
    if (std.mem.eql(u8, directive, "@image")) return NodeType.Media;
    if (std.mem.eql(u8, directive, "@import")) return NodeType.Import;
    if (std.mem.eql(u8, directive, "@style")) return NodeType.Style;

    // Aliases / planned:
    if (std.mem.eql(u8, directive, "@css")) return NodeType.Style; // alias of style
    if (std.mem.eql(u8, directive, "@style-def")) return NodeType.StyleDef;

    // Fallback: treat as generic content; unknowns can be upgraded later
    return NodeType.Content;
}

fn isBlockDirective(nt: NodeType) bool {
    return switch (nt) {
        .CodeBlock, .Math, .Style, .Css, .StyleDef => true,
        else => false,
    };
}

/// Parses tokens into an ASTNode tree
pub fn parse(tokens: []const Token, allocator: std.mem.Allocator) !ASTNode {
    var root = ASTNode.init(allocator, .Document);

    var i: usize = 0;
    while (i < tokens.len) {
        const tok = tokens[i];

        if (tok.kind == .Directive) {
            const node_type = directiveToNodeType(tok.lexeme);
            var node = ASTNode.init(allocator, node_type);
            i += 1;

            // parameters
            while (i + 1 < tokens.len and tokens[i].kind == .ParameterKey and tokens[i + 1].kind == .ParameterValue) {
                try node.attributes.put(tokens[i].lexeme, tokens[i + 1].lexeme);
                i += 2;
            }

            // inline content (e.g. heading title after ")")
            if (i < tokens.len and tokens[i].kind == .Content) {
                node.content = tokens[i].lexeme; // not owned
                node.owns_content = false;
                i += 1;
            }

            // block body for fenced directives
            if (isBlockDirective(node_type)) {
                var block = std.ArrayList(u8){};
                defer block.deinit(allocator);

                while (i < tokens.len and tokens[i].kind != .BlockEnd) : (i += 1) {
                    try block.appendSlice(allocator, tokens[i].lexeme);
                    try block.append(allocator, '\n');
                }
                if (i < tokens.len and tokens[i].kind == .BlockEnd) {
                    i += 1; // skip @end
                }

                if (block.items.len > 0) {
                    node.content = try block.toOwnedSlice(allocator);
                    node.owns_content = true; // we allocated it
                }
            }

            try root.children.append(allocator, node);
            continue;
        }

        if (tok.kind == .Content) {
            var content_node = ASTNode.init(allocator, .Content);
            content_node.content = tok.lexeme; // not owned
            try root.children.append(allocator, content_node);
            i += 1;
            continue;
        }

        i += 1;
    }

    return root;
}

// ----------------------
// Tests
// ----------------------
test "Parse multiple directives" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    const tokenizer = @import("tokenizer.zig");
    const input =
        \\@meta(title="Docz Guide", author="Team") @end
        \\@heading(level=2) Welcome to Docz @end
        \\@code(language="zig")
        \\const x = 42;
        \\@end
    ;
    const tokens = try tokenizer.tokenize(input, allocator);
    defer allocator.free(tokens);

    var ast = try parse(tokens, allocator);
    defer ast.deinit(allocator);

    try std.testing.expectEqual(ast.children.items.len, 3);
    try std.testing.expectEqual(ast.children.items[0].node_type, .Meta);
    try std.testing.expectEqual(ast.children.items[1].node_type, .Heading);
    try std.testing.expectEqual(ast.children.items[2].node_type, .CodeBlock);

    try std.testing.expect(std.mem.containsAtLeast(u8, ast.children.items[2].content, 1, "const x = 42;"));
}

<<<

`tokenizer.zig`: >>>

const std = @import("std");

pub const TokenType = enum {
    Directive,
    ParameterKey,
    ParameterValue,
    Content,
    BlockEnd,
};

pub const Token = struct {
    kind: TokenType,
    lexeme: []const u8,
    is_allocated: bool = false, // track ownership for @@ case
};

/// Optional config (reserved for future knobs).
/// Use `tokenize()` for the default behavior; use `tokenizeWith()` if/when
/// you want to expose options without changing the public signature.
pub const TokenizerConfig = struct {
    /// Directives (with leading '@') that start a fenced raw block.
    fenced_directives: []const []const u8 = &.{ "@code", "@math", "@style", "@css" },

    pub fn isFenced(self: *const TokenizerConfig, dir: []const u8) bool {
        for (self.fenced_directives) |d| {
            if (std.mem.eql(u8, d, dir)) return true;
        }
        return false;
    }
};

/// Public, backward-compatible API used across the repo/tests.
pub fn tokenize(input: []const u8, allocator: std.mem.Allocator) ![]Token {
    return tokenizeWith(input, allocator, .{});
}

/// Extended API (kept internal for now) that accepts options.
pub fn tokenizeWith(input: []const u8, allocator: std.mem.Allocator, config: TokenizerConfig) ![]Token {
    const A = allocator;

    var tokens = std.ArrayList(Token){};
    errdefer tokens.deinit(A);

    var i: usize = 0;

    // Skip UTF-8 BOM if present
    if (input.len >= 3 and input[0] == 0xEF and input[1] == 0xBB and input[2] == 0xBF) {
        i = 3;
    }

    // Fence state: when non-empty, we are inside a raw block until a line that is "@end"
    // or ends with "@end" (after optional whitespace).
    var fence_name: []const u8 = "";

    // Global no-progress guard (defensive)
    var prev_i: usize = ~@as(usize, 0);
    var stuck_iters: usize = 0;

    while (i < input.len) : ({
        if (i == prev_i) {
            stuck_iters += 1;
            if (stuck_iters >= 10_000_000) return error.TokenizerStuck;
        } else {
            prev_i = i;
            stuck_iters = 0;
        }
    }) {
        // ── Fenced mode: slurp raw content until a closer appears.
        if (fence_name.len != 0) {
            // Skip a single leading newline so fenced content begins on its own line.
            if (i < input.len) {
                if (input[i] == '\r') {
                    if (i + 1 < input.len and input[i + 1] == '\n') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                } else if (input[i] == '\n') {
                    i += 1;
                }
            }

            // Optional heuristic: for math blocks only, strip leading indentation on the first content line.
            if (std.mem.eql(u8, fence_name, "@math")) {
                while (i < input.len and (input[i] == ' ' or input[i] == '\t')) : (i += 1) {}
            }

            const content_start = i;

            while (i < input.len) {
                const eol = lineEnd(input, i);
                const line = input[i..eol];

                // Case 1: whole trimmed line is "@end"
                if (trimmedEq(line, "@end")) {
                    if (content_start < i) {
                        try tokens.append(A, .{ .kind = .Content, .lexeme = input[content_start..i] });
                    }
                    try tokens.append(A, .{ .kind = .BlockEnd, .lexeme = "@end" });
                    i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                    fence_name = "";
                    break;
                }

                // Case 2: inline closer at end-of-line: "...something... @end[WS]"
                if (std.mem.indexOf(u8, line, "@end")) |pos| {
                    const after = line[pos..];
                    if (trimmedEq(after, "@end")) {
                        // trim any spaces/tabs immediately before "@end"
                        var cut_abs = i + pos;
                        while (cut_abs > content_start and (input[cut_abs - 1] == ' ' or input[cut_abs - 1] == '\t')) {
                            cut_abs -= 1;
                        }

                        if (content_start < cut_abs) {
                            try tokens.append(A, .{ .kind = .Content, .lexeme = input[content_start..cut_abs] });
                        }
                        try tokens.append(A, .{ .kind = .BlockEnd, .lexeme = "@end" });
                        // consume the rest of this line including newline
                        i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                        fence_name = "";
                        break;
                    }
                }

                // Not a closer: advance to next line
                i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
            }

            // EOF with no @end: emit remainder and exit fence
            if (fence_name.len != 0 and content_start < input.len) {
                try tokens.append(A, .{ .kind = .Content, .lexeme = input[content_start..input.len] });
                fence_name = "";
                i = input.len;
            }
            continue;
        }

        const c = input[i];

        // 1) Escaped literal '@' — "@@" + word → emit as Content("@word")
        if (c == '@' and i + 1 < input.len and input[i + 1] == '@') {
            i += 2; // skip "@@"
            const start = i;
            while (i < input.len and !std.ascii.isWhitespace(input[i])) : (i += 1) {}
            const word = input[start..i];

            const combined = try std.fmt.allocPrint(A, "@{s}", .{word});
            try tokens.append(A, .{
                .kind = .Content,
                .lexeme = combined,
                .is_allocated = true,
            });
            continue;
        }

        // 2) Standalone @end: only when the rest of this line (trimmed) is exactly "@end"
        if (c == '@' and i + 4 <= input.len and std.mem.eql(u8, input[i .. i + 4], "@end")) {
            const eol = lineEnd(input, i);
            if (trimmedEq(input[i..eol], "@end")) {
                try tokens.append(A, .{ .kind = .BlockEnd, .lexeme = "@end" });
                i = if (eol < input.len and input[eol] == '\n') eol + 1 else eol;
                continue;
            }
            // else: literal "`@end`" in prose → fall through
        }

        // 3) Directives at SOL (allow leading spaces/tabs)
        if (c == '@') {
            var j = i;
            while (j > 0 and (input[j - 1] == ' ' or input[j - 1] == '\t')) : (j -= 1) {}
            const at_sol = (j == 0) or (input[j - 1] == '\n' or input[j - 1] == '\r');

            if (at_sol) {
                const d_start = i;
                i += 1; // skip '@'

                // Allow letters, digits, '_' and '-' in directive identifiers.
                while (i < input.len) : (i += 1) {
                    const ch = input[i];
                    if (!(std.ascii.isAlphanumeric(ch) or ch == '_' or ch == '-')) break;
                }
                const directive_full = input[d_start..i]; // e.g. "@meta", "@style-def"

                if (directive_full.len == 1) {
                    try tokens.append(A, .{ .kind = .Content, .lexeme = "@" });
                    continue;
                }

                try tokens.append(A, .{ .kind = .Directive, .lexeme = directive_full });

                // Optional parameter list: (...)
                if (i < input.len and input[i] == '(') {
                    i += 1;

                    var inner_prev: usize = ~@as(usize, 0);
                    var inner_stuck: usize = 0;

                    while (i < input.len and input[i] != ')') : ({
                        if (i == inner_prev) {
                            inner_stuck += 1;
                            if (inner_stuck >= 10_000_000) return error.TokenizerStuck;
                        } else {
                            inner_prev = i;
                            inner_stuck = 0;
                        }
                    }) {
                        // skip whitespace
                        while (i < input.len and std.ascii.isWhitespace(input[i])) : (i += 1) {}
                        if (i >= input.len) break;

                        // commas
                        if (input[i] == ',') {
                            i += 1;
                            continue;
                        }

                        // key: allow letters, digits, '_' and '-' (to match directive style)
                        const key_start = i;
                        while (i < input.len) : (i += 1) {
                            const ch = input[i];
                            if (!(std.ascii.isAlphanumeric(ch) or ch == '_' or ch == '-')) break;
                        }
                        if (i > key_start) {
                            try tokens.append(A, .{ .kind = .ParameterKey, .lexeme = input[key_start..i] });
                        } else {
                            // skip one char to avoid infinite loop if malformed
                            if (i < input.len and input[i] != ')' and input[i] != ',') i += 1;
                            continue;
                        }

                        // '=' and value
                        if (i < input.len and input[i] == '=') {
                            i += 1;

                            if (i < input.len and input[i] == '"') {
                                i += 1; // opening quote
                                const str_start = i;
                                while (i < input.len) : (i += 1) {
                                    if (input[i] == '"') break;
                                }
                                const str_end = if (i < input.len) i else input.len;
                                try tokens.append(A, .{ .kind = .ParameterValue, .lexeme = input[str_start..str_end] });
                                if (i < input.len and input[i] == '"') i += 1;
                            } else {
                                const v_start = i;
                                while (i < input.len) : (i += 1) {
                                    const ch = input[i];
                                    if (std.ascii.isWhitespace(ch) or ch == ')' or ch == ',') break;
                                }
                                if (i > v_start) {
                                    try tokens.append(A, .{ .kind = .ParameterValue, .lexeme = input[v_start..i] });
                                }
                            }
                        }
                    }
                    if (i < input.len and input[i] == ')') i += 1;
                }

                // Fence-opening directives (configurable)
                if (config.isFenced(directive_full)) {
                    fence_name = directive_full; // any non-empty marker works
                }

                continue;
            }
        }

        // 4) Line comments starting with "#:" (to end of line)
        if (c == '#' and i + 1 < input.len and input[i + 1] == ':') {
            while (i < input.len and input[i] != '\n') : (i += 1) {}
            continue;
        }

        // 5) Whitespace: skip (includes newlines)
        if (std.ascii.isWhitespace(c)) {
            i += 1;
            continue;
        }

        // 6) Raw content until newline OR a standalone "@end" OR a SOL directive
        const content_start = i;
        while (i < input.len) : (i += 1) {
            const ch = input[i];
            if (ch == '\n' or ch == '\r') break;

            if (ch == '@') {
                // Break on "@@" so outer loop can emit the literal-@ token
                if (i + 1 < input.len and input[i + 1] == '@') break;

                // If remainder of this line (trimmed) is exactly "@end", stop here
                const eol2 = lineEnd(input, i);
                if (eol2 > i and trimmedEq(input[i..eol2], "@end")) break;

                // If it's a start-of-line directive (allowing indentation), let outer loop handle it.
                var k = i;
                while (k > 0 and (input[k - 1] == ' ' or input[k - 1] == '\t')) : (k -= 1) {}
                const sol = (k == 0) or (input[k - 1] == '\n' or input[k - 1] == '\r');
                if (sol) break;
            }
        }
        if (i > content_start) {
            try tokens.append(A, .{ .kind = .Content, .lexeme = input[content_start..i] });
        }
        // newline (if any) handled next iteration
    }

    return try tokens.toOwnedSlice(A);
}

/// Free all heap allocations in token list.
pub fn freeTokens(allocator: std.mem.Allocator, tokens: []Token) void {
    for (tokens) |t| {
        if (t.is_allocated) allocator.free(t.lexeme);
    }
}

// ── helpers ─────────────────────────────────────────────────

/// Return index of end-of-line (position of '\n' or input.len).
fn lineEnd(input: []const u8, pos: usize) usize {
    var j = pos;
    while (j < input.len and input[j] != '\n') : (j += 1) {}
    return j;
}

/// Compare slice (trimmed of spaces/tabs/CR) with needle.
fn trimmedEq(slice: []const u8, needle: []const u8) bool {
    const t = std.mem.trim(u8, slice, " \t\r");
    return std.mem.eql(u8, t, needle);
}

// ----------------------
// Tests
// ----------------------
test "Tokenize escape sequence @@ as literal @" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    var allocator = gpa.allocator();

    const input = "Contact @@support@example.com";
    const toks = try tokenize(input, allocator);
    defer {
        freeTokens(allocator, toks);
        allocator.free(toks);
    }

    try std.testing.expectEqual(@as(usize, 2), toks.len);
    try std.testing.expectEqualStrings("Contact ", toks[0].lexeme);
    try std.testing.expectEqualStrings("@support@example.com", toks[1].lexeme);
}

test "Unclosed parameter list does not hang" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@meta(title="Hello"
        \\Content after
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // We at least see the directive and some content; exact count is not strict.
    try std.testing.expect(toks.len >= 2);
}

test "Fenced code block captures raw until standalone or inline @end" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@code(language="txt")
        \\line 1
        \\line 2 @end
        \\After
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // Expect: Directive, ParamKey, ParamValue, Content("line 1\nline 2"), BlockEnd, Content("After")
    try std.testing.expect(toks.len >= 5);
    try std.testing.expect(toks[0].kind == .Directive);
    try std.testing.expect(toks[3].kind == .Content);
    try std.testing.expect(std.mem.indexOf(u8, toks[3].lexeme, "line 2") != null);
    // Ensure "@end" not included in content
    try std.testing.expect(std.mem.indexOf(u8, toks[3].lexeme, "@end") == null);
}

test "Inline `@end` in prose does not become BlockEnd (outside fence)" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\This paragraph mentions `@end` and continues.
        \\@heading(level=2) Title
        \\@end
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    var found_inline = false;
    var found_blockend = false;
    for (toks) |t| {
        if (t.kind == .Content and std.mem.indexOf(u8, t.lexeme, "`@end`") != null) found_inline = true;
        if (t.kind == .BlockEnd) found_blockend = true;
    }
    try std.testing.expect(found_inline);
    try std.testing.expect(found_blockend);
}

test "Alias @css fences like @style" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@css()
        \\p { color: green }
        \\@end
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // Expect: Directive(@css), params, Content, BlockEnd
    var saw_content = false;
    var saw_blockend = false;
    for (toks) |t| {
        if (t.kind == .Content and std.mem.indexOf(u8, t.lexeme, "color: green") != null) saw_content = true;
        if (t.kind == .BlockEnd) saw_blockend = true;
    }
    try std.testing.expect(saw_content);
    try std.testing.expect(saw_blockend);
}

test "Directive names and param keys may contain '-'" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const input =
        \\@style-def(theme-name="default")
        \\.x{}
        \\@end
    ;

    const toks = try tokenize(input, A);
    defer {
        freeTokens(A, toks);
        A.free(toks);
    }

    // First token should be a Directive whose lexeme includes "@style-def"
    try std.testing.expect(toks.len >= 3);
    try std.testing.expect(toks[0].kind == .Directive);
    try std.testing.expect(std.mem.eql(u8, toks[0].lexeme, "@style-def"));
    // ParameterKey should include '-'
    var saw_key = false;
    for (toks) |t| {
        if (t.kind == .ParameterKey and std.mem.eql(u8, t.lexeme, "theme-name")) saw_key = true;
    }
    try std.testing.expect(saw_key);
}

<<<

`registry.zig`: >>>


const std = @import("std");

/// Represents the canonical spelling of a directive, with aliases and metadata.
pub const DirectiveSpec = struct {
    name: []const u8,                 // canonical name, e.g. "heading"
    aliases: []const []const u8,      // e.g. ["h", "hdr"]
    requires_end: bool,               // does it require @end?
    description: []const u8,          // short summary

    pub fn matches(self: DirectiveSpec, ident: []const u8) bool {
        if (std.ascii.eqlIgnoreCase(ident, self.name)) return true;
        for (self.aliases) |a| {
            if (std.ascii.eqlIgnoreCase(ident, a)) return true;
        }
        return false;
    }
};

/// Registry: holds core directives + plugin registrations
pub const Registry = struct {
    arena: std.heap.ArenaAllocator,
    table: std.StringHashMap(*const DirectiveSpec),

    pub fn init(allocator: std.mem.Allocator) Registry {
        var arena = std.heap.ArenaAllocator.init(allocator);
        return Registry{
            .arena = arena,
            .table = std.StringHashMap(*const DirectiveSpec).init(arena.allocator()),
        };
    }

    pub fn deinit(self: *Registry) void {
        self.table.deinit();
        self.arena.deinit();
    }

    /// Register a directive spec (canonical + aliases).
    pub fn register(self: *Registry, spec: DirectiveSpec) !void {
        const alloc = self.arena.allocator();
        const spec_ptr = try alloc.create(DirectiveSpec);
        spec_ptr.* = spec;
        try self.table.put(spec.name, spec_ptr);
        for (spec.aliases) |a| {
            try self.table.put(a, spec_ptr);
        }
    }

    /// Look up by name or alias; returns canonical spec or null if unknown.
    pub fn lookup(self: *Registry, ident: []const u8) ?*const DirectiveSpec {
        return self.table.get(ident);
    }

    /// Normalize an identifier to canonical name (if known), else return original.
    pub fn normalize(self: *Registry, ident: []const u8) []const u8 {
        if (self.lookup(ident)) |spec| return spec.name;
        return ident;
    }
};

/// Initialize a registry with all core directives and their common shorthands.
pub fn initCoreRegistry(allocator: std.mem.Allocator) !Registry {
    var r = Registry.init(allocator);

    try r.register(.{
        .name = "meta",
        .aliases = &.{ "m" },
        .requires_end = true,
        .description = "Document metadata (title, author, etc.)",
    });

    try r.register(.{
        .name = "heading",
        .aliases = &.{ "h", "hdr" },
        .requires_end = true,
        .description = "Section heading (level=1..6)",
    });

    try r.register(.{
        .name = "paragraph",
        .aliases = &.{ "p" },
        .requires_end = true,
        .description = "Paragraph block (usually implicit)",
    });

    try r.register(.{
        .name = "code",
        .aliases = &.{ "c" },
        .requires_end = true,
        .description = "Code block",
    });

    try r.register(.{
        .name = "math",
        .aliases = &.{ "equation" },
        .requires_end = true,
        .description = "Math block",
    });

    try r.register(.{
        .name = "image",
        .aliases = &.{ "img" },
        .requires_end = false,
        .description = "Image/media embed",
    });

    try r.register(.{
        .name = "import",
        .aliases = &.{ "include" },
        .requires_end = false,
        .description = "Import external resource (css/js)",
    });

    try r.register(.{
        .name = "style",
        .aliases = &.{ "css" },
        .requires_end = true,
        .description = "Inline stylesheet block",
    });

    return r;
}

test "registry basic normalize and lookup" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const alloc = gpa.allocator();

    var r = try initCoreRegistry(alloc);
    defer r.deinit();

    const n1 = r.normalize("H"); // alias
    try std.testing.expect(std.mem.eql(u8, n1, "heading"));

    const n2 = r.normalize("code");
    try std.testing.expect(std.mem.eql(u8, n2, "code"));

    const n3 = r.normalize("unknown");
    try std.testing.expect(std.mem.eql(u8, n3, "unknown"));

    const spec = r.lookup("hdr").?;
    try std.testing.expect(std.mem.eql(u8, spec.name, "heading"));
}

<<<

`export.zig`: >>>

const std = @import("std");
const docz = @import("docz");

const ASTNode = docz.AST.ASTNode;

// ─────────────────────────────────────────────────────────────
// Small writer for ArrayList(u8) compatible with this Zig build
// ─────────────────────────────────────────────────────────────
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    pub fn writeAll(self: *ListWriter, bytes: []const u8) !void {
        try self.list.appendSlice(self.alloc, bytes);
    }

    pub fn print(self: *ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// ─────────────────────────────────────────────────────────────
// Minimal Markdown escaper (keep it conservative/on-demand)
// ─────────────────────────────────────────────────────────────
fn escapeInlineMd(A: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    for (s) |ch| switch (ch) {
        // escape characters that commonly flip formatting in inline text
        '*', '_', '`', '~', '\\' => {
            try out.append(A, '\\');
            try out.append(A, ch);
        },
        else => try out.append(A, ch),
    };

    return try out.toOwnedSlice(A);
}

// ─────────────────────────────────────────────────────────────
// Block helpers
// ─────────────────────────────────────────────────────────────
fn clampHeadingLevel(raw: []const u8) usize {
    const n = std.fmt.parseInt(usize, raw, 10) catch 1;
    if (n == 0) return 1;
    if (n > 6) return 6;
    return n;
}

fn writeHeading(w: *ListWriter, node: *const ASTNode, A: std.mem.Allocator) !void {
    const level = clampHeadingLevel(node.attributes.get("level") orelse "1");

    var hashes_buf: [6]u8 = .{ '#', '#', '#', '#', '#', '#' };
    const text = std.mem.trimRight(u8, node.content, " \t\r\n");
    const esc = try escapeInlineMd(A, text);
    defer A.free(esc);

    try w.writeAll(hashes_buf[0..level]);
    try w.print(" {s}\n\n", .{esc});
}

fn writeParagraph(w: *ListWriter, node: *const ASTNode, A: std.mem.Allocator) !void {
    const text = std.mem.trimRight(u8, node.content, " \t\r\n");
    if (text.len == 0) return;
    const esc = try escapeInlineMd(A, text);
    defer A.free(esc);
    try w.print("{s}\n\n", .{esc});
}

fn writeCodeBlock(w: *ListWriter, node: *const ASTNode) !void {
    const lang = node.attributes.get("language") orelse
        (node.attributes.get("lang") orelse "");
    try w.print("```{s}\n{s}\n```\n\n", .{ lang, node.content });
}

fn writeMath(w: *ListWriter, node: *const ASTNode) !void {
    // Keep simple & portable: fenced display math
    try w.print("$$\n{s}\n$$\n\n", .{node.content});
}

fn writeMedia(w: *ListWriter, node: *const ASTNode, A: std.mem.Allocator) !void {
    const src = node.attributes.get("src") orelse "";
    if (src.len == 0) return;

    // Try to use alt text if present; otherwise a placeholder
    const alt = node.attributes.get("alt") orelse "image";

    const esc_alt = try escapeInlineMd(A, alt);
    defer A.free(esc_alt);

    // URLs usually safe; don’t escape by default
    try w.print("![{s}]({s})\n\n", .{ esc_alt, src });
}

// ─────────────────────────────────────────────────────────────
// Public API
// ─────────────────────────────────────────────────────────────

/// Primary Markdown export function.
pub fn exportMarkdown(root: *const ASTNode, A: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    var w = ListWriter{ .list = &out, .alloc = A };

    // Walk top-level nodes in order and emit Markdown
    for (root.children.items) |node| {
        switch (node.node_type) {
            .Heading => try writeHeading(&w, &node, A),
            .Content => try writeParagraph(&w, &node, A),
            .CodeBlock => try writeCodeBlock(&w, &node),
            .Math => try writeMath(&w, &node),
            .Media => try writeMedia(&w, &node, A),

            // Skip head/alias/import blocks in .md output
            .Meta, .Css, .Style, .StyleDef, .Import => {},

            // Other node kinds: ignore (forward-compat)
            else => {},
        }
    }

    return try out.toOwnedSlice(A);
}

/// Back-compat name used by the CLI (`convert.zig`).
pub fn exportAstToMarkdown(root: *const ASTNode, A: std.mem.Allocator) ![]u8 {
    return exportMarkdown(root, A);
}

// ─────────────────────────────────────────────────────────────
// Tests
// ─────────────────────────────────────────────────────────────
test "markdown: headings, paragraph, code" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var doc = ASTNode.init(A, .Document);
    defer doc.deinit(A);

    {
        var h = ASTNode.init(A, .Heading);
        try h.attributes.put("level", "2");
        h.content = "Hello *Docz*";
        try doc.children.append(A, h);
    }
    {
        var p = ASTNode.init(A, .Content);
        p.content = "Some paragraph with `inline`.";
        try doc.children.append(A, p);
    }
    {
        var c = ASTNode.init(A, .CodeBlock);
        try c.attributes.put("language", "zig");
        c.content = "const x: u8 = 42;";
        try doc.children.append(A, c);
    }

    const md = try exportMarkdown(&doc, A);
    defer A.free(md);

    try std.testing.expect(std.mem.containsAtLeast(u8, md, 1, "## Hello \\*Docz\\*"));
    try std.testing.expect(std.mem.containsAtLeast(u8, md, 1, "Some paragraph with \\`inline\\`."));
    try std.testing.expect(std.mem.containsAtLeast(u8, md, 1, "```zig"));
    try std.testing.expect(std.mem.containsAtLeast(u8, md, 1, "const x: u8 = 42;"));
}

<<<

`import.zig`: >>>

const std = @import("std");

// -----------------------------------------------------------------------------
// Small writer adapter for ArrayList(u8) on this Zig version (no std.io.Writer)
// -----------------------------------------------------------------------------
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    pub fn write(self: *ListWriter, bytes: []const u8) !usize {
        try self.list.appendSlice(self.alloc, bytes);
        return bytes.len;
    }
    pub fn writeAll(self: *ListWriter, bytes: []const u8) !void {
        _ = try self.write(bytes);
    }
    pub fn print(self: *ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// -------------------------
// Small helpers
// -------------------------

fn flushParagraph(
    allocator: std.mem.Allocator,
    out: *std.ArrayList(u8),
    para: *std.ArrayList(u8),
) !void {
    if (para.items.len == 0) return;

    // Trim leading/trailing whitespace in the paragraph buffer
    const trimmed = std.mem.trim(u8, para.items, " \t\r\n");
    if (trimmed.len != 0) {
        try out.appendSlice(allocator, trimmed);
        try out.append(allocator, '\n');
    }

    para.clearRetainingCapacity();
}

fn trimSpaces(s: []const u8) []const u8 {
    return std.mem.trim(u8, s, " \t\r\n");
}

fn isIdentChar(c: u8) bool {
    return std.ascii.isAlphabetic(c);
}

/// Reads a LaTeX command name starting at `start` where `tex[start] == '\'`.
/// Returns name slice and index just after the name.
fn readCommandName(tex: []const u8, start: usize) ?struct { name: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '\\') return null;
    var j = start + 1;
    while (j < tex.len and isIdentChar(tex[j])) : (j += 1) {}
    if (j == start + 1) return null;
    return .{ .name = tex[start + 1 .. j], .next = j };
}

/// If the next non-space is `[`, read until matching `]` (no nesting).
/// Returns slice inside `[]` and index after `]`. If not present, returns null.
fn readOptionalBracket(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    var i = start;
    while (i < tex.len and std.ascii.isWhitespace(tex[i])) : (i += 1) {}
    if (i >= tex.len or tex[i] != '[') return null;

    var j = i + 1;
    while (j < tex.len and tex[j] != ']') : (j += 1) {}
    const end = if (j < tex.len) j else tex.len;
    const body = tex[i + 1 .. end];
    const next = if (j < tex.len) j + 1 else j;
    return .{ .body = body, .next = next };
}

/// Read a `{...}` group with brace-depth counting. Start must point at `{`.
/// Returns slice inside braces and index after closing `}`.
fn readBalancedBraces(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '{') return null;
    var depth: usize = 1;
    var j = start + 1;
    while (j < tex.len) : (j += 1) {
        const c = tex[j];
        if (c == '{') {
            depth += 1;
        } else if (c == '}') {
            depth -= 1;
            if (depth == 0) {
                const body = tex[start + 1 .. j];
                return .{ .body = body, .next = j + 1 };
            }
        }
    }
    return null; // unclosed
}

/// Read a \begin{name} ... \end{name} environment starting at `start` where tex[start] == '\\'.
/// Returns env name, body, and index just after the matching end.
fn readEnvironment(tex: []const u8, start: usize) ?struct {
    env: []const u8,
    body: []const u8,
    next: usize,
} {
    const begin_cmd = readCommandName(tex, start) orelse return null;
    if (!std.ascii.eqlIgnoreCase(begin_cmd.name, "begin")) return null;

    const begin_brace = readBalancedBraces(tex, begin_cmd.next) orelse return null;
    const env_name = begin_brace.body;

    var scan = begin_brace.next;
    while (scan < tex.len) {
        const maybe_cmd = readCommandName(tex, scan) orelse {
            scan += 1;
            continue;
        };
        if (std.ascii.eqlIgnoreCase(maybe_cmd.name, "end")) {
            if (readBalancedBraces(tex, maybe_cmd.next)) |end_brace| {
                if (std.ascii.eqlIgnoreCase(end_brace.body, env_name)) {
                    const body_slice = tex[begin_brace.next..scan];
                    return .{ .env = env_name, .body = body_slice, .next = end_brace.next };
                }
            }
        }
        scan = maybe_cmd.next;
    }
    return null;
}

/// Collapse all whitespace runs to a single space and trim ends.
fn collapseSpaces(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    var i: usize = 0;
    var in_space = false;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (c == ' ' or c == '\t' or c == '\n' or c == '\r') {
            if (!in_space) {
                in_space = true;
                try out.append(allocator, ' ');
            }
        } else {
            in_space = false;
            try out.append(allocator, c);
        }
    }
    // trim leading/trailing single space
    while (out.items.len != 0 and out.items[0] == ' ')
        _ = out.orderedRemove(0);
    while (out.items.len != 0 and out.items[out.items.len - 1] == ' ')
        _ = out.pop();

    return out.toOwnedSlice(allocator);
}

/// Remove all backslashes, then trim spaces.
fn stripBackslashesAndTrim(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var tmp = std.ArrayList(u8){};
    errdefer tmp.deinit(allocator);
    for (s) |ch| {
        if (ch != '\\') try tmp.append(allocator, ch);
    }
    const v = trimSpaces(tmp.items);
    return allocator.dupe(u8, v);
}

// -------------------------
// Emit helpers (dcz)
// -------------------------

fn emitMetaKV(w: anytype, k: []const u8, v: []const u8) !void {
    const key = trimSpaces(k);
    const val = trimSpaces(v);
    if (key.len == 0 or val.len == 0) return;
    try w.print("@meta({s}=\"{s}\") @end\n", .{ key, val });
}

fn emitTitle(w: anytype, title: []const u8) !void {
    const t = trimSpaces(title);
    if (t.len == 0) return;
    try w.print("@meta(title=\"{s}\") @end\n", .{t});
}

fn emitHeading(w: anytype, level: u8, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("@heading(level={d}) {s} @end\n", .{ level, t });
}

fn emitPara(w: anytype, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("{s}\n", .{t});
}

fn emitImage(w: anytype, src: []const u8) !void {
    const s = trimSpaces(src);
    if (s.len == 0) return;
    try w.print("@image(src=\"{s}\") @end\n", .{s});
}

fn emitCode(w: anytype, body: []const u8) !void {
    try w.print("@code(language=\"\")\n{s}\n@end\n", .{body});
}

fn emitMath(w: anytype, body: []const u8) !void {
    const t = trimSpaces(body);
    if (t.len == 0) return;
    try w.print("@math {s} @end\n", .{t});
}

fn flushPara(wr: anytype, buf: *std.ArrayList(u8)) !void {
    const t = trimSpaces(buf.items);
    if (t.len != 0) try emitPara(wr, t);
    buf.clearRetainingCapacity();
}

// -------------------------
// Core conversion
// -------------------------

/// Convert a small, practical subset of LaTeX to .dcz text.
/// Non-matching commands are skipped; plain text becomes paragraphs.
pub fn importLatexToDcz(allocator: std.mem.Allocator, tex: []const u8) ![]u8 {
    var out_buf = std.ArrayList(u8){};
    errdefer out_buf.deinit(allocator);

    var para_buf = std.ArrayList(u8){};
    defer para_buf.deinit(allocator);

    // Writer instance over the output buffer
    var lw = ListWriter{ .list = &out_buf, .alloc = allocator };
    const wr = &lw;

    var i: usize = 0;
    while (i < tex.len) {
        const c = tex[i];

        // Blank line = paragraph boundary
        if (c == '\n') {
            const next_nl: u8 = if (i + 1 < tex.len) tex[i + 1] else 0;
            if (next_nl == '\n') {
                try flushParagraph(allocator, &out_buf, &para_buf);
                i += 2;
                continue;
            }
        }

        if (c == '\\') {
            // Handle "\\" disambiguation
            if (i + 1 < tex.len and tex[i + 1] == '\\') {
                if (i + 2 < tex.len and std.ascii.isAlphabetic(tex[i + 2])) {
                    i += 1; // let the next '\' start a command
                } else {
                    // Real LaTeX line break -> single space
                    const need_space =
                        para_buf.items.len == 0 or
                        (para_buf.items[para_buf.items.len - 1] != ' ' and
                            para_buf.items[para_buf.items.len - 1] != '\n');
                    if (need_space) try para_buf.append(allocator, ' ');
                    i += 2;
                    continue;
                }
            }

            // 1) Environments: \begin{...} ... \end{...}
            if (readEnvironment(tex, i)) |env| {
                try flushParagraph(allocator, &out_buf, &para_buf);

                if (std.ascii.eqlIgnoreCase(env.env, "verbatim")) {
                    try emitCode(wr, env.body);
                } else if (std.ascii.eqlIgnoreCase(env.env, "equation") or
                    std.ascii.eqlIgnoreCase(env.env, "equation*"))
                {
                    // Normalize whitespace inside math.
                    const collapsed = try collapseSpaces(allocator, env.body);
                    defer allocator.free(collapsed);

                    // Trim any trailing '\' (and spaces before it) from the math body.
                    var view = collapsed;
                    while (view.len > 0 and (view[view.len - 1] == ' ' or view[view.len - 1] == '\\')) {
                        view = view[0 .. view.len - 1];
                    }

                    if (view.len != 0) {
                        try emitMath(wr, view);
                    }
                } else {
                    // Unknown env: ignore for now.
                }

                i = env.next;
                continue;
            }

            // 2) Simple commands
            if (readCommandName(tex, i)) |cmd| {
                const name = cmd.name;

                // \title{...} / \author{...}
                if (std.ascii.eqlIgnoreCase(name, "title") or
                    std.ascii.eqlIgnoreCase(name, "author"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(allocator, &out_buf, &para_buf);
                        if (std.ascii.eqlIgnoreCase(name, "title")) {
                            try emitTitle(wr, grp.body);
                        } else {
                            try emitMetaKV(wr, "author", grp.body);
                        }
                        i = grp.next;
                        continue;
                    }
                }

                // \section / \subsection / \subsubsection
                if (std.ascii.eqlIgnoreCase(name, "section") or
                    std.ascii.eqlIgnoreCase(name, "subsection") or
                    std.ascii.eqlIgnoreCase(name, "subsubsection"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(allocator, &out_buf, &para_buf);
                        const lvl: u8 =
                            if (std.ascii.eqlIgnoreCase(name, "section")) 1 else if (std.ascii.eqlIgnoreCase(name, "subsection")) 2 else 3;
                        try emitHeading(wr, lvl, grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // \includegraphics[...]{path}
                if (std.ascii.eqlIgnoreCase(name, "includegraphics")) {
                    const opt = readOptionalBracket(tex, cmd.next); // ignored for now
                    const after = if (opt) |o| o.next else cmd.next;
                    if (readBalancedBraces(tex, after)) |grp| {
                        try flushParagraph(allocator, &out_buf, &para_buf);
                        try emitImage(wr, grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // Unknown command: drop command + one braced arg if present
                if (readBalancedBraces(tex, cmd.next)) |grp| {
                    i = grp.next;
                } else {
                    i = cmd.next;
                }
                continue;
            }
        }

        // Default: accumulate paragraph text
        try para_buf.append(allocator, c);
        i += 1;
    }

    // Final flush
    try flushParagraph(allocator, &out_buf, &para_buf);
    return out_buf.toOwnedSlice(allocator);
}

// -------------------------
// Low-level bracket readers
// -------------------------

fn readBraced(allocator: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '{') return allocator.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '{') depth += 1 else if (tex[i] == '}') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return allocator.dupe(u8, tex[start .. i - 1]);
}

fn readBracketed(allocator: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '[') return allocator.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '[') depth += 1 else if (tex[i] == ']') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return allocator.dupe(u8, tex[start .. i - 1]);
}

// -------------------------
// Unit tests (with helpful failure dumps)
// -------------------------

fn assertContains(hay: []const u8, needle: []const u8) !void {
    if (std.mem.indexOf(u8, hay, needle) == null) {
        std.debug.print(
            "\nASSERT CONTAINS failed.\n--- needle ---\n{s}\n--- hay ---\n{s}\n--------------\n",
            .{ needle, hay },
        );
        return error.TestUnexpectedResult;
    }
}

test "latex_import: title and author to meta" {
    const tex =
        \\\\title{My Paper}
        \\\\author{Jane Doe}
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@meta(title=\"My Paper\") @end");
    try assertContains(out, "@meta(author=\"Jane Doe\") @end");
}

test "latex_import: sections to headings" {
    const tex =
        \\\\section{Intro}
        \\Some text.
        \\\\subsection{Background}
        \\More text.
        \\\\subsubsection{Details}
        \\End.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@heading(level=1) Intro @end");
    try assertContains(out, "@heading(level=2) Background @end");
    try assertContains(out, "@heading(level=3) Details @end");
}

test "latex_import: graphics, verbatim, equation, and paragraphs" {
    const tex =
        \\Here is an intro paragraph.
        \\
        \\\\includegraphics[width=3in]{figs/plot.pdf}
        \\
        \\\\begin{verbatim}
        \\const x = 42;
        \\\\end{verbatim}
        \\
        \\\\begin{equation}
        \\E = mc^2
        \\\\end{equation}
        \\
        \\A final paragraph.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Here is an intro paragraph.\n");
    try assertContains(out, "@image(src=\"figs/plot.pdf\") @end");
    try assertContains(out,
        \\@code(language="")
    );
    try assertContains(out, "const x = 42;");
    try assertContains(out, "@math E = mc^2 @end");
    try assertContains(out, "A final paragraph.\n");
}

test "latex_import: ignores unknown commands and keeps text" {
    const tex =
        \\Some \\unknowncmd{stuff} remains as text.
        \\And \\alpha more text.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Some  remains as text.");
    try assertContains(out, "And  more text.");
}

<<<

`export.zig`: >>>

const std = @import("std");

// Expose a simple AST surface via your public docz module
const docz = @import("docz");
const AST = docz.AST;
const ASTNode = AST.ASTNode;
const NodeType = AST.NodeType;

// -----------------------------------------------------------------------------
// Tiny buffer writer for Zig 0.16 (avoid std.io.Writer diffs)
// -----------------------------------------------------------------------------
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    fn writeAll(self: *ListWriter, bytes: []const u8) !void {
        try self.list.appendSlice(self.alloc, bytes);
    }

    fn print(self: *ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// -----------------------------------------------------------------------------
// Minimal helpers
// -----------------------------------------------------------------------------
fn trimRight(s: []const u8) []const u8 {
    return std.mem.trimRight(u8, s, " \t\r\n");
}

fn emitMeta(w: *ListWriter, node: *const ASTNode) !void {
    // We only care about title / author for tests.
    if (node.attributes.get("title")) |t| {
        const v = trimRight(t);
        if (v.len != 0) try w.print("\\title{{{s}}}\n", .{v});
        return;
    }
    if (node.attributes.get("author")) |a| {
        const v = trimRight(a);
        if (v.len != 0) try w.print("\\author{{{s}}}\n", .{v});
        return;
    }
}

fn emitHeading(w: *ListWriter, node: *const ASTNode) !void {
    const level_str = node.attributes.get("level") orelse "1";
    const txt = trimRight(node.content);

    // Map: 1 -> \section, 2 -> \subsection, >=3 -> \subsubsection
    var cmd: []const u8 = "\\section";
    if (std.mem.eql(u8, level_str, "2")) cmd = "\\subsection" else if (!std.mem.eql(u8, level_str, "1")) cmd = "\\subsubsection";

    try w.print("{s}{{{s}}}\n\n", .{ cmd, txt });
}

fn emitParagraph(w: *ListWriter, node: *const ASTNode) !void {
    const t = trimRight(node.content);
    if (t.len == 0) return;
    try w.print("{s}\n\n", .{t});
}

fn emitCode(w: *ListWriter, node: *const ASTNode) !void {
    try w.writeAll("\\begin{verbatim}\n");
    try w.writeAll(node.content);
    // Ensure body ends with a single newline before the end tag
    if (node.content.len == 0 or node.content[node.content.len - 1] != '\n') {
        try w.writeAll("\n");
    }
    try w.writeAll("\\end{verbatim}\n\n");
}

fn emitMath(w: *ListWriter, node: *const ASTNode) !void {
    try w.writeAll("\\begin{equation}\n");
    try w.writeAll(trimRight(node.content));
    try w.writeAll("\n\\end{equation}\n\n");
}

fn emitImage(w: *ListWriter, node: *const ASTNode) !void {
    const src = node.attributes.get("src") orelse "";
    if (src.len == 0) return;
    try w.print("\\includegraphics{{{s}}}\n\n", .{src});
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------
pub fn exportAstToLatex(root: *const ASTNode, A: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    var lw = ListWriter{ .list = &out, .alloc = A };

    // Walk the top-level nodes in order and emit LaTeX fragments.
    for (root.children.items) |node| {
        switch (node.node_type) {
            .Meta => try emitMeta(&lw, &node),
            .Heading => try emitHeading(&lw, &node),
            .Content => try emitParagraph(&lw, &node),
            .CodeBlock => try emitCode(&lw, &node),
            .Math => try emitMath(&lw, &node),
            .Media => try emitImage(&lw, &node),

            // These are not part of the LaTeX export surface for the tests:
            .Import, .Css, .Style, .StyleDef => {},

            else => {}, // ignore anything unexpected
        }
    }

    // Ensure a single trailing newline exists (safe for normalizer in tests)
    if (out.items.len == 0 or out.items[out.items.len - 1] != '\n') {
        try out.append(A, '\n');
    }

    return try out.toOwnedSlice(A);
}

// -----------------------------------------------------------------------------
// Tiny smoke tests (local to this module)
// -----------------------------------------------------------------------------
test "latex export: basics" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit(A);

    { // meta
        var m1 = ASTNode.init(A, NodeType.Meta);
        try m1.attributes.put("title", "Roundtrip Spec");
        try root.children.append(A, m1);

        var m2 = ASTNode.init(A, NodeType.Meta);
        try m2.attributes.put("author", "Docz");
        try root.children.append(A, m2);
    }
    { // heading + para
        var h = ASTNode.init(A, NodeType.Heading);
        try h.attributes.put("level", "1");
        h.content = "Intro";
        try root.children.append(A, h);

        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Hello world paragraph.";
        try root.children.append(A, p);
    }
    { // code
        var c = ASTNode.init(A, NodeType.CodeBlock);
        c.content = "const x = 1;";
        try root.children.append(A, c);
    }
    { // math
        var m = ASTNode.init(A, NodeType.Math);
        m.content = "E = mc^2";
        try root.children.append(A, m);
    }
    { // image
        var img = ASTNode.init(A, NodeType.Media);
        try img.attributes.put("src", "img/logo.png");
        try root.children.append(A, img);
    }

    const tex = try exportAstToLatex(&root, A);
    defer A.free(tex);

    try std.testing.expect(std.mem.indexOf(u8, tex, "\\title{Roundtrip Spec}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\author{Docz}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\section{Intro}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "Hello world paragraph.\n\n") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\begin{verbatim}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\end{verbatim}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\begin{equation}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\end{equation}") != null);
    try std.testing.expect(std.mem.indexOf(u8, tex, "\\includegraphics{img/logo.png}") != null);
}

<<<

`import.zig`: >>>

const std = @import("std");

// -----------------------------------------------------------------------------
// Small writer adapter for ArrayList(u8) on this Zig version
//   - No std.io.Writer dependency
//   - Supports writeAll + print via std.fmt.format(self, ...)
// -----------------------------------------------------------------------------
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    pub fn write(self: *ListWriter, bytes: []const u8) !usize {
        try self.list.appendSlice(self.alloc, bytes);
        return bytes.len;
    }

    pub fn writeAll(self: *ListWriter, bytes: []const u8) !void {
        _ = try self.write(bytes);
    }

    // zig 0.16 friendly: allocate formatted text, append, free
    pub fn print(self: *ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// -------------------------
// Small helpers
// -------------------------

fn flushParagraph(A: std.mem.Allocator, out: *std.ArrayList(u8), para: *std.ArrayList(u8)) !void {
    if (para.items.len == 0) return;

    // Trim leading/trailing whitespace in the paragraph buffer
    const trimmed = std.mem.trim(u8, para.items, " \t\r\n");
    if (trimmed.len != 0) {
        try out.appendSlice(A, trimmed);
        try out.append(A, '\n');
    }

    para.clearRetainingCapacity();
}

fn trimSpaces(s: []const u8) []const u8 {
    return std.mem.trim(u8, s, " \t\r\n");
}

fn isIdentChar(c: u8) bool {
    return std.ascii.isAlphabetic(c);
}

/// Reads a LaTeX command name starting at `start` where `tex[start] == '\'`.
/// Returns name slice and index just after the name.
fn readCommandName(tex: []const u8, start: usize) ?struct { name: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '\\') return null;
    var j = start + 1;
    while (j < tex.len and isIdentChar(tex[j])) : (j += 1) {}
    if (j == start + 1) return null;
    return .{ .name = tex[start + 1 .. j], .next = j };
}

/// If the next non-space is `[`, read until matching `]` (no nesting).
/// Returns slice inside `[]` and index after `]`. If not present, returns null.
fn readOptionalBracket(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    var i = start;
    while (i < tex.len and std.ascii.isWhitespace(tex[i])) : (i += 1) {}
    if (i >= tex.len or tex[i] != '[') return null;

    var j = i + 1;
    while (j < tex.len and tex[j] != ']') : (j += 1) {}
    const end = if (j < tex.len) j else tex.len;
    const body = tex[i + 1 .. end];
    const next = if (j < tex.len) j + 1 else j;
    return .{ .body = body, .next = next };
}

/// Read a `{...}` group with brace-depth counting. Start must point at `{`.
/// Returns slice inside braces and index after closing `}`.
fn readBalancedBraces(tex: []const u8, start: usize) ?struct { body: []const u8, next: usize } {
    if (start >= tex.len or tex[start] != '{') return null;
    var depth: usize = 1;
    var j = start + 1;
    while (j < tex.len) : (j += 1) {
        const c = tex[j];
        if (c == '{') {
            depth += 1;
        } else if (c == '}') {
            depth -= 1;
            if (depth == 0) {
                const body = tex[start + 1 .. j];
                return .{ .body = body, .next = j + 1 };
            }
        }
    }
    return null; // unclosed
}

/// Read a \begin{name} ... \end{name} environment starting at `start` where tex[start] == '\\'.
/// Returns env name, body, and index just after the matching end.
fn readEnvironment(tex: []const u8, start: usize) ?struct {
    env: []const u8,
    body: []const u8,
    next: usize,
} {
    const begin_cmd = readCommandName(tex, start) orelse return null;
    if (!std.ascii.eqlIgnoreCase(begin_cmd.name, "begin")) return null;

    const begin_brace = readBalancedBraces(tex, begin_cmd.next) orelse return null;
    const env_name = begin_brace.body;

    var scan = begin_brace.next;
    while (scan < tex.len) {
        const maybe_cmd = readCommandName(tex, scan) orelse {
            scan += 1;
            continue;
        };
        if (std.ascii.eqlIgnoreCase(maybe_cmd.name, "end")) {
            if (readBalancedBraces(tex, maybe_cmd.next)) |end_brace| {
                if (std.ascii.eqlIgnoreCase(end_brace.body, env_name)) {
                    const body_slice = tex[begin_brace.next..scan];
                    return .{ .env = env_name, .body = body_slice, .next = end_brace.next };
                }
            }
        }
        scan = maybe_cmd.next;
    }
    return null;
}

/// Collapse all whitespace runs to a single space and trim ends.
fn collapseSpaces(A: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    var i: usize = 0;
    var in_space = false;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (c == ' ' or c == '\t' or c == '\n' or c == '\r') {
            if (!in_space) {
                in_space = true;
                try out.append(A, ' ');
            }
        } else {
            in_space = false;
            try out.append(A, c);
        }
    }
    // trim leading/trailing single space
    while (out.items.len != 0 and out.items[0] == ' ')
        _ = out.orderedRemove(0);
    while (out.items.len != 0 and out.items[out.items.len - 1] == ' ')
        _ = out.pop();

    return try out.toOwnedSlice(A);
}

/// Remove all backslashes, then trim spaces.
fn stripBackslashesAndTrim(A: std.mem.Allocator, s: []const u8) ![]u8 {
    var tmp = std.ArrayList(u8){};
    errdefer tmp.deinit(A);
    for (s) |ch| {
        if (ch != '\\') try tmp.append(A, ch);
    }
    const v = trimSpaces(tmp.items);
    return A.dupe(u8, v);
}

// -------------------------
// Emit helpers (dcz)
// -------------------------

fn emitMetaKV(w: anytype, k: []const u8, v: []const u8) !void {
    const key = trimSpaces(k);
    const val = trimSpaces(v);
    if (key.len == 0 or val.len == 0) return;
    try w.print("@meta({s}=\"{s}\") @end\n", .{ key, val });
}

fn emitTitle(w: anytype, title: []const u8) !void {
    const t = trimSpaces(title);
    if (t.len == 0) return;
    try w.print("@meta(title=\"{s}\") @end\n", .{t});
}

fn emitHeading(w: anytype, level: u8, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("@heading(level={d}) {s} @end\n", .{ level, t });
}

fn emitPara(w: anytype, text: []const u8) !void {
    const t = trimSpaces(text);
    if (t.len == 0) return;
    try w.print("{s}\n", .{t});
}

fn emitImage(w: anytype, src: []const u8) !void {
    const s = trimSpaces(src);
    if (s.len == 0) return;
    try w.print("@image(src=\"{s}\") @end\n", .{s});
}

fn emitCode(w: anytype, body: []const u8) !void {
    try w.print("@code(language=\"\")\n{s}\n@end\n", .{body});
}

fn emitMath(w: anytype, body: []const u8) !void {
    const t = trimSpaces(body);
    if (t.len == 0) return;
    try w.print("@math {s} @end\n", .{t});
}

fn flushPara(wr: anytype, buf: *std.ArrayList(u8)) !void {
    const t = trimSpaces(buf.items);
    if (t.len != 0) try emitPara(wr, t);
    buf.clearRetainingCapacity();
}

// -------------------------
// Core conversion
// -------------------------

/// Convert a small, practical subset of LaTeX to .dcz text.
/// Non-matching commands are skipped; plain text becomes paragraphs.
pub fn importLatexToDcz(A: std.mem.Allocator, tex: []const u8) ![]u8 {
    var out_buf = std.ArrayList(u8){};
    errdefer out_buf.deinit(A);

    var para_buf = std.ArrayList(u8){};
    defer para_buf.deinit(A);

    // writer over out_buf
    var lw = ListWriter{ .list = &out_buf, .alloc = A };
    const wr = &lw;

    var i: usize = 0;
    while (i < tex.len) {
        const c = tex[i];

        // Blank line = paragraph boundary
        if (c == '\n') {
            const next_nl: u8 = if (i + 1 < tex.len) tex[i + 1] else 0;
            if (next_nl == '\n') {
                try flushParagraph(A, &out_buf, &para_buf);
                i += 2;
                continue;
            }
        }

        if (c == '\\') {
            // Handle "\\" disambiguation
            if (i + 1 < tex.len and tex[i + 1] == '\\') {
                if (i + 2 < tex.len and std.ascii.isAlphabetic(tex[i + 2])) {
                    i += 1; // let the next '\' start a command
                } else {
                    // Real LaTeX line break -> single space
                    const need_space =
                        para_buf.items.len == 0 or
                        (para_buf.items[para_buf.items.len - 1] != ' ' and
                            para_buf.items[para_buf.items.len - 1] != '\n');
                    if (need_space) try para_buf.append(A, ' ');
                    i += 2;
                    continue;
                }
            }

            // 1) Environments: \begin{...} ... \end{...}
            if (readEnvironment(tex, i)) |env| {
                try flushParagraph(A, &out_buf, &para_buf);

                if (std.ascii.eqlIgnoreCase(env.env, "verbatim")) {
                    try emitCode(wr, env.body);
                } else if (std.ascii.eqlIgnoreCase(env.env, "equation") or
                    std.ascii.eqlIgnoreCase(env.env, "equation*"))
                {
                    // Normalize whitespace inside math.
                    const collapsed = try collapseSpaces(A, env.body);
                    defer A.free(collapsed);

                    // Trim any trailing '\' (and spaces before it) from the math body.
                    var view = collapsed;
                    while (view.len > 0 and (view[view.len - 1] == ' ' or view[view.len - 1] == '\\')) {
                        view = view[0 .. view.len - 1];
                    }

                    if (view.len != 0) {
                        try emitMath(wr, view);
                    }
                } else {
                    // Unknown env: ignore for now.
                }

                i = env.next;
                continue;
            }

            // 2) Simple commands
            if (readCommandName(tex, i)) |cmd| {
                const name = cmd.name;

                // \title{...} / \author{...}
                if (std.ascii.eqlIgnoreCase(name, "title") or
                    std.ascii.eqlIgnoreCase(name, "author"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(A, &out_buf, &para_buf);
                        if (std.ascii.eqlIgnoreCase(name, "title")) {
                            try emitTitle(wr, grp.body);
                        } else {
                            try emitMetaKV(wr, "author", grp.body);
                        }
                        i = grp.next;
                        continue;
                    }
                }

                // \section / \subsection / \subsubsection
                if (std.ascii.eqlIgnoreCase(name, "section") or
                    std.ascii.eqlIgnoreCase(name, "subsection") or
                    std.ascii.eqlIgnoreCase(name, "subsubsection"))
                {
                    if (readBalancedBraces(tex, cmd.next)) |grp| {
                        try flushParagraph(A, &out_buf, &para_buf);
                        const lvl: u8 =
                            if (std.ascii.eqlIgnoreCase(name, "section")) 1 else if (std.ascii.eqlIgnoreCase(name, "subsection")) 2 else 3;
                        try emitHeading(wr, lvl, grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // \includegraphics[...]{path}
                if (std.ascii.eqlIgnoreCase(name, "includegraphics")) {
                    const opt = readOptionalBracket(tex, cmd.next); // ignored for now
                    const after = if (opt) |o| o.next else cmd.next;
                    if (readBalancedBraces(tex, after)) |grp| {
                        try flushParagraph(A, &out_buf, &para_buf);
                        try emitImage(wr, grp.body);
                        i = grp.next;
                        continue;
                    }
                }

                // Unknown command: drop command + one braced arg if present
                if (readBalancedBraces(tex, cmd.next)) |grp| {
                    i = grp.next;
                } else {
                    i = cmd.next;
                }
                continue;
            }
        }

        // Default: accumulate paragraph text
        try para_buf.append(A, c);
        i += 1;
    }

    // Final flush
    try flushParagraph(A, &out_buf, &para_buf);
    return try out_buf.toOwnedSlice(A);
}

// -------------------------
// Low-level bracket readers
// -------------------------

fn readBraced(A: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '{') return A.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '{') depth += 1 else if (tex[i] == '}') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return A.dupe(u8, tex[start .. i - 1]);
}

fn readBracketed(A: std.mem.Allocator, tex: []const u8, idx: *usize) ![]u8 {
    var i = idx.*;
    if (i >= tex.len or tex[i] != '[') return A.alloc(u8, 0);
    i += 1;
    const start = i;
    var depth: usize = 1;
    while (i < tex.len and depth > 0) {
        if (tex[i] == '[') depth += 1 else if (tex[i] == ']') depth -= 1;
        i += 1;
    }
    idx.* = i;
    return A.dupe(u8, tex[start .. i - 1]);
}

// -------------------------
// Unit tests (with helpful failure dumps)
// -------------------------

fn assertContains(hay: []const u8, needle: []const u8) !void {
    if (std.mem.indexOf(u8, hay, needle) == null) {
        std.debug.print(
            "\nASSERT CONTAINS failed.\n--- needle ---\n{s}\n--- hay ---\n{s}\n--------------\n",
            .{ needle, hay },
        );
        return error.TestUnexpectedResult;
    }
}

test "latex_import: title and author to meta" {
    const tex =
        \\\\title{My Paper}
        \\\\author{Jane Doe}
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@meta(title=\"My Paper\") @end");
    try assertContains(out, "@meta(author=\"Jane Doe\") @end");
}

test "latex_import: sections to headings" {
    const tex =
        \\\\section{Intro}
        \\Some text.
        \\\\subsection{Background}
        \\More text.
        \\\\subsubsection{Details}
        \\End.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "@heading(level=1) Intro @end");
    try assertContains(out, "@heading(level=2) Background @end");
    try assertContains(out, "@heading(level=3) Details @end");
}

test "latex_import: graphics, verbatim, equation, and paragraphs" {
    const tex =
        \\Here is an intro paragraph.
        \\
        \\\\includegraphics[width=3in]{figs/plot.pdf}
        \\
        \\\\begin{verbatim}
        \\const x = 42;
        \\\\end{verbatim}
        \\
        \\\\begin{equation}
        \\E = mc^2
        \\\\end{equation}
        \\
        \\A final paragraph.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Here is an intro paragraph.\n");
    try assertContains(out, "@image(src=\"figs/plot.pdf\") @end");
    try assertContains(out,
        \\@code(language="")
    );
    try assertContains(out, "const x = 42;");
    try assertContains(out, "@math E = mc^2 @end");
    try assertContains(out, "A final paragraph.\n");
}

test "latex_import: ignores unknown commands and keeps text" {
    const tex =
        \\Some \\unknowncmd{stuff} remains as text.
        \\And \\alpha more text.
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importLatexToDcz(A, tex);
    defer A.free(out);

    try assertContains(out, "Some  remains as text.");
    try assertContains(out, "And  more text.");
}

<<<

`renderer.zig`: >>>

const std = @import("std");

// ─────────────────────────────────────────────────────────────
// Public attrs struct + free()
// ─────────────────────────────────────────────────────────────

pub const InlineStyleAttrs = struct {
    name: ?[]const u8 = null,
    class_attr: ?[]const u8 = null,
    style: ?[]const u8 = null,
    on_click: ?[]const u8 = null,
    on_hover: ?[]const u8 = null,
    on_focus: ?[]const u8 = null,
};

pub fn freeInlineStyleAttrs(allocator: std.mem.Allocator, a: *InlineStyleAttrs) void {
    if (a.name) |v| allocator.free(v);
    if (a.class_attr) |v| allocator.free(v);
    if (a.style) |v| allocator.free(v);
    if (a.on_click) |v| allocator.free(v);
    if (a.on_hover) |v| allocator.free(v);
    if (a.on_focus) |v| allocator.free(v);
    a.* = InlineStyleAttrs{};
}

// ─────────────────────────────────────────────────────────────
// Small helpers
// ─────────────────────────────────────────────────────────────

fn isSpace(c: u8) bool {
    return c == ' ' or c == '\t' or c == '\n' or c == '\r';
}

fn skipSpacesAndCommas(s: []const u8, start: usize) usize {
    var j = start;
    while (j < s.len and (s[j] == ' ' or s[j] == '\t' or s[j] == '\n' or s[j] == '\r' or s[j] == ',')) : (j += 1) {}
    return j;
}

fn classLooksLikeCss(s: []const u8) bool {
    return std.mem.indexOfScalar(u8, s, ':') != null or std.mem.indexOfScalar(u8, s, ';') != null or std.mem.indexOfScalar(u8, s, '=') != null;
}

fn findClosingParenQuoteAware(s: []const u8, start: usize) ?usize {
    var i = start;
    var in_str = false;
    var q: u8 = 0;
    var esc = false;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (in_str) {
            if (esc) {
                esc = false;
            } else if (c == '\\') {
                esc = true;
            } else if (c == q) {
                in_str = false;
            }
            continue;
        }
        if (c == '"' or c == '\'') {
            in_str = true;
            q = c;
            continue;
        }
        if (c == ')') return i;
    }
    return null;
}

fn scanBracedBodyQuoteAware(s: []const u8, open_idx: usize) ?usize {
    if (open_idx >= s.len or s[open_idx] != '{') return null;
    var i: usize = open_idx + 1;
    var depth: usize = 1;
    var in_str = false;
    var q: u8 = 0;
    var esc = false;

    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (in_str) {
            if (esc) {
                esc = false;
            } else if (c == '\\') {
                esc = true;
            } else if (c == q) {
                in_str = false;
            }
            continue;
        }
        if (c == '"' or c == '\'') {
            in_str = true;
            q = c;
            continue;
        }
        if (c == '{') {
            depth += 1;
        } else if (c == '}') {
            depth -= 1;
            if (depth == 0) return i;
        }
    }
    return null;
}

fn findAtEndOutsideQuotes(s: []const u8, start: usize) ?usize {
    var i = start;
    var in_str = false;
    var q: u8 = 0;
    var esc = false;

    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (in_str) {
            if (esc) {
                esc = false;
            } else if (c == '\\') {
                esc = true;
            } else if (c == q) {
                in_str = false;
            }
            continue;
        }
        if (c == '"' or c == '\'') {
            in_str = true;
            q = c;
            continue;
        }
        if (c == '@' and i + 4 <= s.len and std.mem.eql(u8, s[i .. i + 4], "@end")) {
            return i;
        }
    }
    return null;
}

// ─────────────────────────────────────────────────────────────
// Escapers
// ─────────────────────────────────────────────────────────────

pub fn escapeHtml(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    for (s) |ch| {
        switch (ch) {
            '<' => try out.appendSlice(allocator, "&lt;"),
            '>' => try out.appendSlice(allocator, "&gt;"),
            '&' => try out.appendSlice(allocator, "&amp;"),
            '"' => try out.appendSlice(allocator, "&quot;"),
            '\'' => try out.appendSlice(allocator, "&#39;"),
            else => try out.append(allocator, ch),
        }
    }
    return out.toOwnedSlice(allocator);
}

pub fn escapeHtmlAttr(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    return escapeHtml(allocator, s);
}

fn decodeHtmlQuoteEntities(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    var changed = false;
    var i: usize = 0;
    while (i < s.len) {
        if (std.mem.startsWith(u8, s[i..], "&quot;")) {
            try out.append(allocator, '"');
            i += "&quot;".len;
            changed = true;
            continue;
        }
        if (std.mem.startsWith(u8, s[i..], "&#34;")) {
            try out.append(allocator, '"');
            i += "&#34;".len;
            changed = true;
            continue;
        }
        try out.append(allocator, s[i]);
        i += 1;
    }
    if (!changed) return error.NoChange;
    return out.toOwnedSlice(allocator);
}

// ─────────────────────────────────────────────────────────────
// Attribute parser for @(...)
// ─────────────────────────────────────────────────────────────

fn parseInlineStyleAttrs(allocator: std.mem.Allocator, raw: []const u8) InlineStyleAttrs {
    var owned_buf: ?[]u8 = null;
    const needs_decode = std.mem.indexOf(u8, raw, "&quot;") != null or std.mem.indexOf(u8, raw, "&#34;") != null;

    if (needs_decode) {
        owned_buf = decodeHtmlQuoteEntities(allocator, raw) catch null;
    }
    const s: []const u8 = if (owned_buf) |buf| buf else raw;
    defer if (owned_buf) |buf| allocator.free(buf);

    var out = InlineStyleAttrs{};
    var i: usize = 0;

    while (i < s.len) {
        i = skipSpacesAndCommas(s, i);
        if (i >= s.len) break;

        const key_start = i;
        while (i < s.len and s[i] != '=' and s[i] != ':' and s[i] != ' ' and s[i] != ',' and s[i] != ')') : (i += 1) {}
        const key = std.mem.trim(u8, s[key_start..i], " \t\r\n");

        i = skipSpacesAndCommas(s, i);
        if (i < s.len and (s[i] == '=' or s[i] == ':')) i += 1;
        i = skipSpacesAndCommas(s, i);
        if (i >= s.len) break;

        var value: []const u8 = "";
        if (s[i] == '"') {
            i += 1;
            const vstart = i;
            while (i < s.len and s[i] != '"') : (i += 1) {}
            value = s[vstart..@min(i, s.len)];
            if (i < s.len and s[i] == '"') i += 1;
        } else {
            const vstart = i;
            while (i < s.len and s[i] != ',' and s[i] != ' ' and s[i] != ')') : (i += 1) {}
            value = s[vstart..i];
        }

        if (std.ascii.eqlIgnoreCase(key, "name")) {
            out.name = allocator.dupe(u8, value) catch null;
        } else if (std.ascii.eqlIgnoreCase(key, "class") or std.ascii.eqlIgnoreCase(key, "classes")) {
            out.class_attr = allocator.dupe(u8, value) catch null;
        } else if (std.ascii.eqlIgnoreCase(key, "style")) {
            out.style = allocator.dupe(u8, value) catch null;
        } else if (std.ascii.eqlIgnoreCase(key, "on-click")) {
            out.on_click = allocator.dupe(u8, value) catch null;
        } else if (std.ascii.eqlIgnoreCase(key, "on-hover")) {
            out.on_hover = allocator.dupe(u8, value) catch null;
        } else if (std.ascii.eqlIgnoreCase(key, "on-focus")) {
            out.on_focus = allocator.dupe(u8, value) catch null;
        }

        i = skipSpacesAndCommas(s, i);
        if (i < s.len and s[i] == ',') i += 1;
    }

    return out;
}

// ─────────────────────────────────────────────────────────────
// URL sanity + backticks
// ─────────────────────────────────────────────────────────────

fn urlSafe(s: []const u8) bool {
    var has_alpha = false;
    var has_sep = false;
    for (s) |ch| {
        if ((ch >= 'A' and ch <= 'Z') or (ch >= 'a' and ch <= 'z')) has_alpha = true;
        if (ch == '.' or ch == ':' or ch == '/') has_sep = true;
    }
    return has_alpha and has_sep;
}

fn findBacktickEnd(s: []const u8, start_after_tick: usize) ?usize {
    var j = start_after_tick;
    while (j < s.len) : (j += 1) {
        if (s[j] == '\\' and j + 1 < s.len) {
            j += 1;
            continue;
        }
        if (s[j] == '`') return j;
    }
    return null;
}

fn rewriteBackticks(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    var i: usize = 0;
    while (i < s.len) : (i += 1) {
        if (s[i] == '\\' and i + 1 < s.len) {
            const next = s[i + 1];
            if (next == '`' or next == '$' or next == '\\') {
                try out.append(allocator, next);
                i += 1;
                continue;
            }
        }
        if (s[i] != '`') {
            try out.append(allocator, s[i]);
            continue;
        }

        const end_opt = findBacktickEnd(s, i + 1);
        if (end_opt == null) {
            try out.append(allocator, '`');
            continue;
        }
        const end = end_opt.?;
        const inner = s[i + 1 .. end];
        const escaped = try escapeHtml(allocator, inner);
        defer allocator.free(escaped);

        try out.appendSlice(allocator, "<code>");
        try out.appendSlice(allocator, escaped);
        try out.appendSlice(allocator, "</code>");

        i = end;
    }

    return out.toOwnedSlice(allocator);
}

// ─────────────────────────────────────────────────────────────
// <span ...> builder
// ─────────────────────────────────────────────────────────────

fn renderSpanOpenFromAttrs(
    allocator: std.mem.Allocator,
    out: *std.ArrayList(u8),
    attrs: InlineStyleAttrs,
    aliases: *const std.StringHashMap([]const u8),
) !void {
    try out.appendSlice(allocator, "<span");

    var class_val: ?[]u8 = null;
    var style_val: ?[]u8 = null;
    defer {
        if (class_val) |v| allocator.free(v);
        if (style_val) |v| allocator.free(v);
    }

    if (attrs.class_attr) |raw_class| {
        if (classLooksLikeCss(raw_class)) {
            style_val = try escapeHtmlAttr(allocator, raw_class);
        } else {
            class_val = try escapeHtmlAttr(allocator, raw_class);
        }
    } else if (attrs.name) |nm| {
        if (aliases.get(nm)) |resolved| {
            class_val = try escapeHtmlAttr(allocator, resolved);
        }
    }

    if (attrs.style) |sty_raw| {
        const esc = try escapeHtmlAttr(allocator, sty_raw);
        if (style_val == null) {
            style_val = esc;
        } else {
            var merged = std.ArrayList(u8){};
            defer merged.deinit(allocator);
            try merged.appendSlice(allocator, style_val.?);
            try merged.appendSlice(allocator, "; ");
            try merged.appendSlice(allocator, esc);
            allocator.free(style_val.?);
            allocator.free(esc);
            style_val = try merged.toOwnedSlice(allocator);
        }
    }

    if (class_val) |cv| {
        try out.appendSlice(allocator, " class=\"");
        try out.appendSlice(allocator, cv);
        try out.appendSlice(allocator, "\"");
    }
    if (style_val) |sv| {
        try out.appendSlice(allocator, " style=\"");
        try out.appendSlice(allocator, sv);
        try out.appendSlice(allocator, "\"");
    }

    if (attrs.on_click) |v| {
        const vv = try escapeHtmlAttr(allocator, v);
        defer allocator.free(vv);
        try out.appendSlice(allocator, " data-on-click=\"");
        try out.appendSlice(allocator, vv);
        try out.appendSlice(allocator, "\"");
    }
    if (attrs.on_hover) |v| {
        const vv = try escapeHtmlAttr(allocator, v);
        defer allocator.free(vv);
        try out.appendSlice(allocator, " data-on-hover=\"");
        try out.appendSlice(allocator, vv);
        try out.appendSlice(allocator, "\"");
    }
    if (attrs.on_focus) |v| {
        const vv = try escapeHtmlAttr(allocator, v);
        defer allocator.free(vv);
        try out.appendSlice(allocator, " data-on-focus=\"");
        try out.appendSlice(allocator, vv);
        try out.appendSlice(allocator, "\"");
    }

    try out.append(allocator, '>');
}

// ─────────────────────────────────────────────────────────────
// Inline style rewriting
// ─────────────────────────────────────────────────────────────

fn rewriteInlineStyles(
    allocator: std.mem.Allocator,
    s: []const u8,
    aliases: *const std.StringHashMap([]const u8),
) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    var i: usize = 0;

    while (i < s.len) {
        const idx_paren = std.mem.indexOfPos(u8, s, i, "@(");
        const idx_style = std.mem.indexOfPos(u8, s, i, "@style(");

        if (idx_paren == null and idx_style == null) {
            try out.appendSlice(allocator, s[i..]);
            break;
        }

        var start = s.len;
        var kind: u8 = 0; // 1 = paren, 2 = style
        if (idx_paren) |a| {
            start = a;
            kind = 1;
        }
        if (idx_style) |b| {
            if (b < start) {
                start = b;
                kind = 2;
            }
        }

        try out.appendSlice(allocator, s[i..start]);

        var p: usize = start + (if (kind == 1) 2 else "@style(".len);
        const close_paren = findClosingParenQuoteAware(s, p) orelse {
            try out.appendSlice(allocator, s[start..]);
            return out.toOwnedSlice(allocator);
        };
        var attrs = parseInlineStyleAttrs(allocator, s[p..close_paren]);
        defer freeInlineStyleAttrs(allocator, &attrs);

        p = close_paren + 1;
        while (p < s.len and isSpace(s[p])) : (p += 1) {}

        if (p < s.len and s[p] == '{') {
            const close_brace = scanBracedBodyQuoteAware(s, p) orelse {
                try out.appendSlice(allocator, s[start..]);
                return out.toOwnedSlice(allocator);
            };
            const inner = s[p + 1 .. close_brace];

            try renderSpanOpenFromAttrs(allocator, &out, attrs, aliases);
            try out.appendSlice(allocator, inner);
            try out.appendSlice(allocator, "</span>");

            i = close_brace + 1;
            continue;
        }

        const at_end = findAtEndOutsideQuotes(s, p) orelse {
            try out.appendSlice(allocator, s[start..]);
            return out.toOwnedSlice(allocator);
        };
        const inner2 = s[p..at_end];

        try renderSpanOpenFromAttrs(allocator, &out, attrs, aliases);
        try out.appendSlice(allocator, inner2);
        try out.appendSlice(allocator, "</span>");

        i = at_end + "@end".len;
    }

    return out.toOwnedSlice(allocator);
}

// ─────────────────────────────────────────────────────────────
// Markdown link: [text](url)
// ─────────────────────────────────────────────────────────────

fn rewriteLinks(allocator: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(allocator);

    var i: usize = 0;
    while (i < s.len) {
        const lb_opt = std.mem.indexOfScalarPos(u8, s, i, '[');
        if (lb_opt == null) break;
        const lb = lb_opt.?;
        const rb_opt = std.mem.indexOfScalarPos(u8, s, lb + 1, ']');
        if (rb_opt == null) break;
        const rb = rb_opt.?;

        if (rb + 1 >= s.len or s[rb + 1] != '(') {
            i = rb + 1;
            continue;
        }
        const par_close = std.mem.indexOfScalarPos(u8, s, rb + 2, ')') orelse {
            i = rb + 1;
            continue;
        };

        const text_raw = s[lb + 1 .. rb];
        const url_raw = std.mem.trim(u8, s[rb + 2 .. par_close], " \t\r\n");

        if (!urlSafe(url_raw)) {
            try out.appendSlice(allocator, s[i .. par_close + 1]);
            i = par_close + 1;
            continue;
        }

        try out.appendSlice(allocator, s[i..lb]);

        const text = try escapeHtml(allocator, text_raw);
        defer allocator.free(text);
        const url = try escapeHtmlAttr(allocator, url_raw);
        defer allocator.free(url);

        try out.appendSlice(allocator, "<a href=\"");
        try out.appendSlice(allocator, url);
        try out.appendSlice(allocator, "\">");
        try out.appendSlice(allocator, text);
        try out.appendSlice(allocator, "</a>");

        i = par_close + 1;
    }

    try out.appendSlice(allocator, s[i..]);
    return out.toOwnedSlice(allocator);
}

// ─────────────────────────────────────────────────────────────
// Public: master inline pass
// ─────────────────────────────────────────────────────────────

pub fn renderInline(
    allocator: std.mem.Allocator,
    raw: []const u8,
    aliases: *const std.StringHashMap([]const u8),
) ![]u8 {
    const step1 = try rewriteBackticks(allocator, raw);
    defer allocator.free(step1);

    const step2 = try rewriteInlineStyles(allocator, step1, aliases);
    defer allocator.free(step2);

    const step3 = try rewriteLinks(allocator, step2);
    return step3;
}

// ─────────────────────────────────────────────────────────────
// Tests
// ─────────────────────────────────────────────────────────────

test "inline: backticks and links and style shorthand" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var aliases = std.StringHashMap([]const u8).init(A);
    defer {
        var it = aliases.iterator();
        while (it.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        aliases.deinit();
    }
    try aliases.put(try A.dupe(u8, "note"), try A.dupe(u8, "rounded bg-yellow-50 px-2"));

    const s =
        \\Use `code` and a [link](https://ziglang.org).
        \\ @(name="note"){nice}
    ;
    const out = try renderInline(A, s, &aliases);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "<code>code</code>") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "<a href=\"https://ziglang.org\">link</a>") != null);
    try std.testing.expect(std.mem.indexOf(u8, out, "<span class=\"rounded bg-yellow-50 px-2\">nice</span>") != null);
}

test "inline: explicit @style(... ) content @end is rewritten (class→style heuristic)" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var aliases = std.StringHashMap([]const u8).init(A);
    defer aliases.deinit();

    const s = "The @style(class=\"color = red\") preview @end server.";
    const out = try renderInline(A, s, &aliases);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "The <span style=\"color = red\">preview </span> server.") != null);
}

test "inline: explicit with &quot; decodes and rewrites" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var aliases = std.StringHashMap([]const u8).init(A);
    defer aliases.deinit();

    const s = "The @style(class=&quot;color = red&quot;) preview @end server.";
    const out = try renderInline(A, s, &aliases);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "<span style=\"color = red\">preview </span>") != null);
}

test "inline: shorthand paren with quoted brace content" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var aliases = std.StringHashMap([]const u8).init(A);
    defer aliases.deinit();

    const s = "@(class=\"x\"){this has \"}\" inside}";
    const out = try renderInline(A, s, &aliases);
    defer A.free(out);

    try std.testing.expect(std.mem.indexOf(u8, out, "<span class=\"x\">this has \"}\" inside</span>") != null);
}

test "inline: currency $4.39 is not touched" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var aliases = std.StringHashMap([]const u8).init(A);

    const s = "Price is $4.39 today (no closing dollar).";
    const out = try renderInline(A, s, &aliases);
    defer A.free(out);

    try std.testing.expect(std.mem.eql(u8, out, s));
    aliases.deinit();
}

<<<

`export.zig`: >>>

const std = @import("std");

// This module is built as "html_export" (see build.zig) and is also re-exported
// by the public "docz" module. We import docz for AST types and the inline
// renderer pass.
const docz = @import("docz");
const AST = docz.AST;
const ASTNode = AST.ASTNode;
const NodeType = AST.NodeType;

// Inline renderer facade (matches your root.zig: renderer.inline_.renderInline)
const Inline = docz.renderer.inline_;

// -----------------------------------------------------------------------------
// Small writer adapter for ArrayList(u8) on this Zig version
// -----------------------------------------------------------------------------
const ListWriter = struct {
    list: *std.ArrayList(u8),
    alloc: std.mem.Allocator,

    pub fn writeAll(self: *ListWriter, bytes: []const u8) !void {
        try self.list.appendSlice(self.alloc, bytes);
    }

    pub fn print(self: *ListWriter, comptime fmt: []const u8, args: anytype) !void {
        const s = try std.fmt.allocPrint(self.alloc, fmt, args);
        defer self.alloc.free(s);
        try self.list.appendSlice(self.alloc, s);
    }
};

// -----------------------------------------------------------------------------
// Small HTML escaper (used for <title> etc.)
// -----------------------------------------------------------------------------
fn escapeHtml(A: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    for (s) |ch| switch (ch) {
        '<' => try out.appendSlice(A, "&lt;"),
        '>' => try out.appendSlice(A, "&gt;"),
        '&' => try out.appendSlice(A, "&amp;"),
        '"' => try out.appendSlice(A, "&quot;"),
        '\'' => try out.appendSlice(A, "&#39;"),
        else => try out.append(A, ch),
    };
    return try out.toOwnedSlice(A);
}

// -----------------------------------------------------------------------------
// Style alias utilities (shared notion with inline renderer)
// -----------------------------------------------------------------------------
fn buildStyleAliases(doc: *const ASTNode, A: std.mem.Allocator) !std.StringHashMap([]const u8) {
    var out = std.StringHashMap([]const u8).init(A);
    errdefer {
        var itf = out.iterator();
        while (itf.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        out.deinit(); // no allocator param on this Zig
    }

    for (doc.children.items) |node| {
        if (node.node_type != .StyleDef) continue;

        var parsed = try node.parseStyleAliases(A);

        var it = parsed.iterator();
        while (it.next()) |e| {
            const alias = e.key_ptr.*;
            const classes = e.value_ptr.*;

            const gop = try out.getOrPut(try A.dupe(u8, alias));
            if (gop.found_existing) {
                A.free(gop.key_ptr.*);
                A.free(gop.value_ptr.*);
            }
            gop.value_ptr.* = try A.dupe(u8, classes);
        }

        var itp = parsed.iterator();
        while (itp.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        parsed.deinit();
    }

    return out;
}

fn resolveStyleClasses(style_node: *const ASTNode, aliases: *const std.StringHashMap([]const u8)) []const u8 {
    if (style_node.attributes.get("classes")) |cls| return cls;
    if (style_node.attributes.get("name")) |alias| {
        if (aliases.get(alias)) |resolved| return resolved;
    }
    return "";
}

// -----------------------------------------------------------------------------
// Title extraction
//   - prefer Heading level=1
//   - then Meta name=title / title=...
//   - fallback: "Docz"
// -----------------------------------------------------------------------------
fn extractTitle(doc: *const ASTNode) []const u8 {
    const candidate: []const u8 = "Docz";

    for (doc.children.items) |node| {
        switch (node.node_type) {
            .Heading => {
                if (node.attributes.get("level")) |lv| {
                    if (std.mem.eql(u8, lv, "1")) return node.content;
                }
            },
            .Meta => {
                if (node.attributes.get("title")) |t| return t;
                if (node.attributes.get("name")) |n| {
                    if (std.ascii.eqlIgnoreCase(n, "title")) {
                        if (node.attributes.get("content")) |c| return c;
                        return node.content;
                    }
                }
            },
            else => {},
        }
    }

    return candidate;
}

// -----------------------------------------------------------------------------
// Minimal HTML framing
// -----------------------------------------------------------------------------
fn writeHeadStart(w: anytype, title_text: []const u8, A: std.mem.Allocator) !void {
    const esc = try escapeHtml(A, title_text);
    defer A.free(esc);

    try w.writeAll(
        \\<!DOCTYPE html>
        \\<html>
        \\  <head>
        \\    <meta charset="utf-8">
        \\    <meta name="viewport" content="width=device-width, initial-scale=1" />
        \\
    );
    try w.print("    <title>{s}</title>\n", .{esc});
    try w.writeAll("  </head>\n  <body>\n");
}

fn writeHeadEnd(w: anytype) !void {
    try w.writeAll(
        \\  </body>
        \\</html>
        \\
    );
}

// -----------------------------------------------------------------------------
// Body writer (delegates inline to Inline.renderInline)
// -----------------------------------------------------------------------------
fn writeBodyFromAst(
    root: *const ASTNode,
    w: anytype,
    A: std.mem.Allocator,
) !void {
    // build aliases once
    var aliases = try buildStyleAliases(root, A);
    defer {
        var it = aliases.iterator();
        while (it.next()) |e| {
            A.free(e.key_ptr.*);
            A.free(e.value_ptr.*);
        }
        aliases.deinit(); // no allocator param
    }

    for (root.children.items) |node| {
        switch (node.node_type) {
            .Meta => {}, // head/meta handled separately

            .Heading => {
                const level = node.attributes.get("level") orelse "1";
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                try w.print("<h{s}>{s}</h{s}>\n", .{ level, text, level });
            },

            .Content => {
                const text = std.mem.trimRight(u8, node.content, " \t\r\n");
                if (text.len == 0) continue;

                // Inline rewrite pass (code spans, @(...)… forms, links, etc.)
                const inlined = try Inline.renderInline(A, text, &aliases);
                defer A.free(inlined);

                try w.print("<p>{s}</p>\n", .{inlined});
            },

            .CodeBlock => {
                try w.print("<pre><code>{s}</code></pre>\n", .{node.content});
            },

            .Math => {
                try w.print("<div class=\"math\">{s}</div>\n", .{node.content});
            },

            .Media => {
                const src = node.attributes.get("src") orelse "";
                if (src.len != 0) try w.print("<img src=\"{s}\" />\n", .{src});
            },

            .Style => {
                const classes = resolveStyleClasses(&node, &aliases);
                if (classes.len != 0)
                    try w.print("<div class=\"{s}\">{s}</div>\n", .{ classes, node.content })
                else
                    try w.print("<div>{s}</div>\n", .{node.content});
            },

            .Import, .Css, .StyleDef => {
                // handled by CLI/link-injection or separate head assembly
            },

            else => {
                try w.print("<!-- Unhandled node: {s} -->\n", .{@tagName(node.node_type)});
            },
        }
    }
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------
pub fn exportHtml(doc: *const ASTNode, A: std.mem.Allocator) ![]u8 {
    var buf = std.ArrayList(u8){};
    errdefer buf.deinit(A);

    var lw = ListWriter{ .list = &buf, .alloc = A };
    const w = &lw;

    const title_text = extractTitle(doc);
    try writeHeadStart(w, title_text, A);
    try writeBodyFromAst(doc, w, A);
    try writeHeadEnd(w);

    return try buf.toOwnedSlice(A);
}

// -----------------------------------------------------------------------------
// CSS helpers (string scanning)
// -----------------------------------------------------------------------------
pub fn collectInlineCss(html: []const u8, A: std.mem.Allocator) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    var i: usize = 0;
    while (i < html.len) {
        const open = std.mem.indexOfPos(u8, html, i, "<style");
        if (open == null) break;
        var j = open.?;
        const gt = std.mem.indexOfPos(u8, html, j, ">") orelse break;
        j = gt + 1;
        const close = std.mem.indexOfPos(u8, html, j, "</style>");
        if (close == null) break;

        try out.appendSlice(A, html[j..close.?]);
        try out.append(A, '\n');

        i = close.? + "</style>".len;
    }

    return try out.toOwnedSlice(A);
}

// Remove only the first <style>...</style> block from HTML and return the new
// string. If none found, returns a copy of the original.
pub fn stripFirstStyleBlock(html: []const u8, A: std.mem.Allocator) ![]u8 {
    const open = std.mem.indexOf(u8, html, "<style");
    if (open == null) return A.dupe(u8, html);
    const gt = std.mem.indexOfPos(u8, html, open.? + 1, ">") orelse return A.dupe(u8, html);
    const close = std.mem.indexOfPos(u8, html, gt + 1, "</style>") orelse return A.dupe(u8, html);

    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    try out.appendSlice(A, html[0..open.?]);
    try out.appendSlice(A, html[close + "</style>".len ..]);

    return try out.toOwnedSlice(A);
}

// -----------------------------------------------------------------------------
// Tests (kept concise, no nested functions)
// -----------------------------------------------------------------------------
test "exportHtml: title extraction + heading renders text" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit(A);

    {
        var t = ASTNode.init(A, NodeType.Heading);
        try t.attributes.put("level", "1");
        t.content = "Integration Test";
        try root.children.append(A, t);
    }
    {
        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Hello paragraph.";
        try root.children.append(A, p);
    }

    const html = try exportHtml(&root, A);
    defer A.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "<title>Integration Test</title>") != null);
    try std.testing.expect(std.mem.indexOf(u8, html, "Integration Test") != null);
}

test "exportHtml: paragraph delegates to inline renderer" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    var root = ASTNode.init(A, NodeType.Document);
    defer root.deinit(A);

    {
        var p = ASTNode.init(A, NodeType.Content);
        p.content = "Visit [Zig](https://ziglang.org).";
        try root.children.append(A, p);
    }

    const html = try exportHtml(&root, A);
    defer A.free(html);

    try std.testing.expect(std.mem.indexOf(u8, html, "<a href=\"https://ziglang.org\">Zig</a>") != null);
}

test "css helpers: collect + strip first style block" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const html =
        \\<html><head>
        \\<style>/* one */ .a{}</style>
        \\<style>/* two */ .b{}</style>
        \\</head><body></body></html>
    ;

    const css = try collectInlineCss(html, A);
    defer A.free(css);
    try std.testing.expect(std.mem.indexOf(u8, css, "/* one */") != null);
    try std.testing.expect(std.mem.indexOf(u8, css, "/* two */") != null);

    const stripped = try stripFirstStyleBlock(html, A);
    defer A.free(stripped);
    try std.testing.expect(std.mem.indexOf(u8, stripped, "/* one */") == null);
    try std.testing.expect(std.mem.indexOf(u8, stripped, "/* two */") != null);
}

<<<

`import.zig`: >>>

const std = @import("std");

// Tiny, test-focused HTML → DCZ importer that exposes:
//   pub fn importHtmlToDcz(allocator, html) ![]u8
// Handles exactly what the integration tests assert:
//   - <title>          → @meta(title="...") @end
//   - <meta name="author" content="..."> → @meta(author="...") @end
//   - first <h1>..</h1> → @heading(level=1) .. @end
//   - all <p>..</p>     → "text\n"
//   - <img src="...">   → @image(src="...") @end
//   - <pre><code class="language-XYZ">BODY</code></pre>
//       → @code(language="XYZ")\nBODY\n@end\n
//
// This is NOT a real HTML parser; it’s a tolerant scanner geared for the tests.

fn trim(s: []const u8) []const u8 {
    return std.mem.trim(u8, s, " \t\r\n");
}

fn findBetween(hay: []const u8, a: []const u8, b: []const u8) ?[]const u8 {
    const i = std.mem.indexOf(u8, hay, a) orelse return null;
    const j = std.mem.indexOfPos(u8, hay, i + a.len, b) orelse return null;
    return hay[i + a.len .. j];
}

fn findAttr(tag: []const u8, attr: []const u8) ?[]const u8 {
    // Look for attr="
    const i = std.mem.indexOf(u8, tag, attr) orelse return null;
    var j = i + attr.len;
    if (j >= tag.len or tag[j] != '=') return null;
    j += 1;
    if (j >= tag.len or tag[j] != '"') return null;
    j += 1; // start of value

    const start = j;
    while (j < tag.len and tag[j] != '"') : (j += 1) {}
    if (j >= tag.len) return null;

    return tag[start..j];
}

fn appendFmt(A: std.mem.Allocator, out: *std.ArrayList(u8), comptime fmt: []const u8, args: anytype) !void {
    const s = try std.fmt.allocPrint(A, fmt, args);
    defer A.free(s);
    try out.appendSlice(A, s);
}

pub fn importHtmlToDcz(A: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(A);

    // <title>...</title>
    if (findBetween(html, "<title>", "</title>")) |t| {
        const title = trim(t);
        if (title.len != 0) try appendFmt(A, &out, "@meta(title=\"{s}\") @end\n", .{title});
    }

    // <meta ...> tags — look for author
    var scan: usize = 0;
    while (true) {
        const i = std.mem.indexOfPos(u8, html, scan, "<meta") orelse break;
        const close = std.mem.indexOfPos(u8, html, i, ">") orelse break;
        const tag = html[i .. close + 1];
        scan = close + 1;

        if (findAttr(tag, "name")) |name_val| {
            if (std.ascii.eqlIgnoreCase(name_val, "author")) {
                if (findAttr(tag, "content")) |content_val| {
                    const v = trim(content_val);
                    if (v.len != 0) try appendFmt(A, &out, "@meta(author=\"{s}\") @end\n", .{v});
                }
            }
        }
    }

    // first <h1>..</h1> → heading level 1
    if (findBetween(html, "<h1>", "</h1>")) |h1| {
        const text = trim(h1);
        if (text.len != 0) try appendFmt(A, &out, "@heading(level=1) {s} @end\n", .{text});
    }

    // all <p>..</p> → paragraphs
    scan = 0;
    while (true) {
        const i = std.mem.indexOfPos(u8, html, scan, "<p>") orelse break;
        const j = std.mem.indexOfPos(u8, html, i + 3, "</p>") orelse break;
        const inner = trim(html[i + 3 .. j]);
        if (inner.len != 0) {
            try out.appendSlice(A, inner);
            try out.append(A, '\n');
        }
        scan = j + 4;
    }

    // <img ... src="..."> → image
    scan = 0;
    while (true) {
        const i = std.mem.indexOfPos(u8, html, scan, "<img") orelse break;
        const close = std.mem.indexOfPos(u8, html, i, ">") orelse break;
        const tag = html[i .. close + 1];
        if (findAttr(tag, "src")) |src| {
            const s = trim(src);
            if (s.len != 0) try appendFmt(A, &out, "@image(src=\"{s}\") @end\n", .{s});
        }
        scan = close + 1;
    }

    // <pre><code class="language-XYZ">BODY</code></pre> → code block
    scan = 0;
    while (true) {
        const pre_i = std.mem.indexOfPos(u8, html, scan, "<pre>") orelse break;
        const code_i = std.mem.indexOfPos(u8, html, pre_i, "<code") orelse break;
        const code_gt = std.mem.indexOfPos(u8, html, code_i, ">") orelse break;
        const code_tag = html[code_i .. code_gt + 1];

        var lang: []const u8 = "";
        if (findAttr(code_tag, "class")) |cls| {
            if (std.mem.indexOf(u8, cls, "language-")) |k| {
                lang = cls[k + "language-".len ..];
            }
        }

        const code_end = std.mem.indexOfPos(u8, html, code_gt + 1, "</code>") orelse break;
        const body = html[code_gt + 1 .. code_end];

        const pre_end = std.mem.indexOfPos(u8, html, code_end, "</pre>") orelse break;

        try appendFmt(A, &out, "@code(language=\"{s}\")\n", .{lang});
        try out.appendSlice(A, body);
        try out.appendSlice(A, "\n@end\n");

        scan = pre_end + "</pre>".len;
    }

    return try out.toOwnedSlice(A);
}

// ─────────────────────────────────────────────────────────────
// Unit tests
// ─────────────────────────────────────────────────────────────

fn expectContains(hay: []const u8, needle: []const u8) !void {
    try std.testing.expect(std.mem.indexOf(u8, hay, needle) != null);
}

test "html_import: title + author + h1 + single paragraph" {
    const html =
        \\<html><head><title>T</title>
        \\  <meta name="author" content="Docz Team">
        \\</head>
        \\<body><h1>Hi</h1><p>Para</p></body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try expectContains(out, "@meta(title=\"T\") @end");
    try expectContains(out, "@meta(author=\"Docz Team\") @end");
    try expectContains(out, "@heading(level=1) Hi @end");
    try expectContains(out, "Para\n");
}

test "html_import: multiple paragraphs are each newline-terminated" {
    const html =
        \\<html><body>
        \\  <p>First</p>
        \\  <p>Second</p>
        \\</body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try expectContains(out, "First\n");
    try expectContains(out, "Second\n");
}

test "html_import: image and language-qualified code block" {
    const html =
        \\<html><body>
        \\  <img src="/img/logo.png" alt="x">
        \\  <pre><code class="language-zig">const x = 42;</code></pre>
        \\</body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try expectContains(out, "@image(src=\"/img/logo.png\") @end");
    try expectContains(out,
        \\@code(language="zig")
    );
    try expectContains(out, "const x = 42;");
    try expectContains(out, "\n@end\n");
}

test "html_import: trims whitespace inside title/h1/p and ignores empties" {
    const html =
        \\<html><head>
        \\  <title>   Trim Me   </title>
        \\</head><body>
        \\  <h1>   Head   </h1>
        \\  <p>   A  para  </p>
        \\  <p>     </p> <!-- empty -->
        \\</body></html>
    ;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    try expectContains(out, "@meta(title=\"Trim Me\") @end");
    try expectContains(out, "@heading(level=1) Head @end");
    try expectContains(out, "A  para\n"); // inner spacing preserved, ends trimmed
}

test "html_import: missing pieces produce nothing extraneous" {
    const html = "<html><body>No tags we scan for.</body></html>";

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const A = gpa.allocator();

    const out = try importHtmlToDcz(A, html);
    defer A.free(out);

    // no @meta/@heading/@image/@code or stray newlines
    try std.testing.expect(std.mem.indexOf(u8, out, "@meta(") == null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@heading(") == null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@image(") == null);
    try std.testing.expect(std.mem.indexOf(u8, out, "@code(") == null);
}

<<<

`assets.zig`: >>>

const std = @import("std");

// Prefer monorepo-built theme if present,
// otherwise choose newest vendored theme by mtime (tie-break lexicographically).
pub fn findTailwindCss(alloc: std.mem.Allocator) !?[]u8 {
    // 1) Monorepo theme (takes priority)
    const mono_css = "themes/default/dist/docz.tailwind.css";
    const mono_ok = blk1: {
        std.fs.cwd().access(mono_css, .{}) catch break :blk1 false;
        break :blk1 true;
    };
    if (mono_ok) return try alloc.dupe(u8, mono_css);

    // 2) Vendored: third_party/tailwind/docz-theme-*/css/docz.tailwind.css
    const root = "third_party/tailwind";
    var dir = std.fs.cwd().openDir(root, .{ .iterate = true }) catch |e| {
        if (e == error.FileNotFound) return null;
        return e;
    };
    defer dir.close();

    var it = dir.iterate();

    var best_path: ?[]u8 = null;
    var best_name: ?[]u8 = null;
    var best_mtime: i128 = 0;

    while (try it.next()) |ent| {
        if (ent.kind != .directory) continue;
        if (!std.mem.startsWith(u8, ent.name, "docz-theme-")) continue;

        const css_abs = try std.fs.path.join(alloc, &.{ root, ent.name, "css", "docz.tailwind.css" });
        const present = blk2: {
            std.fs.cwd().access(css_abs, .{}) catch break :blk2 false;
            break :blk2 true;
        };
        if (!present) {
            alloc.free(css_abs);
            continue;
        }

        const st = std.fs.cwd().statFile(css_abs) catch {
            // fall back to lexicographic name if stat fails
            const better = if (best_name) |bn| std.mem.lessThan(u8, bn, ent.name) else true;
            if (better) {
                if (best_path) |bp| alloc.free(bp);
                if (best_name) |bn| alloc.free(bn);
                best_path = css_abs;
                best_name = try alloc.dupe(u8, ent.name);
            } else {
                alloc.free(css_abs);
            }
            continue;
        };

        const better = if (best_path == null)
            true
        else
            (st.mtime > best_mtime) or
                (st.mtime == best_mtime and if (best_name) |bn| std.mem.lessThan(u8, bn, ent.name) else true);

        if (better) {
            if (best_path) |bp| alloc.free(bp);
            if (best_name) |bn| alloc.free(bn);
            best_path = css_abs;
            best_name = try alloc.dupe(u8, ent.name);
            best_mtime = st.mtime;
        } else {
            alloc.free(css_abs);
        }
    }

    if (best_name) |bn| alloc.free(bn);
    return best_path;
}

// Discover newest KaTeX under third_party/katex/*/dist and
// return *hrefs* that the preview server can serve (prefix: /third_party/...).
pub fn findKatexAssets(alloc: std.mem.Allocator) !?struct {
    css_href: []u8,
    js_href: []u8,
    auto_href: []u8,
} {
    const root = "third_party/katex";
    var dir = std.fs.cwd().openDir(root, .{ .iterate = true }) catch |e| {
        if (e == error.FileNotFound) return null;
        return e;
    };
    defer dir.close();

    var it = dir.iterate();

    var best_ver: ?[]u8 = null;
    var best_mtime: i128 = 0;

    while (try it.next()) |ent| {
        if (ent.kind != .directory) continue;
        if (ent.name.len == 0 or ent.name[0] == '.') continue;

        const css_disk = try std.fs.path.join(alloc, &.{ root, ent.name, "dist", "katex.min.css" });
        const present = blk: {
            std.fs.cwd().access(css_disk, .{}) catch break :blk false;
            break :blk true;
        };
        if (!present) {
            alloc.free(css_disk);
            continue;
        }

        const st = std.fs.cwd().statFile(css_disk) catch {
            alloc.free(css_disk);
            // lexicographic fallback
            const better = if (best_ver) |bv| std.mem.lessThan(u8, bv, ent.name) else true;
            if (better) {
                if (best_ver) |bv| alloc.free(bv);
                best_ver = try alloc.dupe(u8, ent.name);
            }
            continue;
        };
        alloc.free(css_disk);

        const better_time = (best_ver == null) or (st.mtime > best_mtime) or
            (st.mtime == best_mtime and if (best_ver) |bv| std.mem.lessThan(u8, bv, ent.name) else true);

        if (better_time) {
            if (best_ver) |bv| alloc.free(bv);
            best_ver = try alloc.dupe(u8, ent.name);
            best_mtime = st.mtime;
        }
    }

    if (best_ver == null) return null;
    defer alloc.free(best_ver.?);

    const css_href = try std.fmt.allocPrint(alloc, "/third_party/katex/{s}/dist/katex.min.css", .{best_ver.?});
    const js_href = try std.fmt.allocPrint(alloc, "/third_party/katex/{s}/dist/katex.min.js", .{best_ver.?});
    const auto_href = try std.fmt.allocPrint(alloc, "/third_party/katex/{s}/dist/contrib/auto-render.min.js", .{best_ver.?});

    return .{ .css_href = css_href, .js_href = js_href, .auto_href = auto_href };
}

// ─────────────────────────────────────────────────────────────
// Tiny file helpers (used by run.zig)
// ─────────────────────────────────────────────────────────────

pub fn copyFileStreaming(src_abs: []const u8, dest_abs: []const u8) !void {
    if (std.fs.path.dirname(dest_abs)) |d| try std.fs.cwd().makePath(d);

    var in_file = try std.fs.cwd().openFile(src_abs, .{});
    defer in_file.close();

    var out_file = try std.fs.cwd().createFile(dest_abs, .{ .truncate = true });
    defer out_file.close();

    var buf: [64 * 1024]u8 = undefined;
    while (true) {
        const n = try in_file.read(&buf);
        if (n == 0) break;
        try out_file.writeAll(buf[0..n]);
    }
}

pub fn fileMTime(path: []const u8) !i128 {
    const st = try std.fs.cwd().statFile(path);
    return st.mtime;
}

<<<

`build_cmd.zig`: >>>

const std = @import("std");
const docz = @import("docz"); // exposes Tokenizer, Parser, Renderer (HTML)
const html_export = @import("html_export");

pub fn run(A: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const in_path = it.next() orelse {
        std.debug.print("Usage: docz build <file.dcz>\n", .{});
        return error.Invalid;
    };

    // 1) Read input
    const input = try readFileAlloc(A, in_path);
    defer A.free(input);

    // 2) DCZ -> tokens -> AST
    const tokens = try docz.Tokenizer.tokenize(input, A);
    defer {
        docz.Tokenizer.freeTokens(A, tokens);
        A.free(tokens);
    }

    var ast = try docz.Parser.parse(tokens, A);
    defer ast.deinit(A);

    // 3) Render HTML
    const html = try html_export.exportHtml(&ast, A);
    defer A.free(html);

    // 4) Write <in>.html
    const out_path = try std.fmt.allocPrint(A, "{s}.html", .{in_path});
    defer A.free(out_path);

    try writeFile(out_path, html);

    // 5) Match existing CLI message shape
    std.debug.print("✔ Built {s} → {s}\n", .{ in_path, out_path });
}

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    // order: (path, alloc, std.Io.Limit)
    return std.fs.cwd().readFileAlloc(path, alloc, @enumFromInt(1 << 26));
}

fn writeFile(path: []const u8, data: []const u8) !void {
    var f = try std.fs.cwd().createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

<<<

`common.zig`: >>>

const std = @import("std");

pub const Kind = enum { dcz, md, html, tex };

// ---------- stderr helper ----------
fn errW() std.fs.File.Writer {
    var f = std.fs.File{ .handle = std.io.getStdErrHandle() };
    return f.writer();
}

// ---------- file helpers ----------
pub fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    // Zig 0.16: Dir.readFileAlloc(path, allocator, Io.Limit)
    return std.fs.cwd().readFileAlloc(path, alloc, @enumFromInt(1 << 26));
}

pub fn writeFile(path: []const u8, data: []const u8) !void {
    const cwd = std.fs.cwd();
    if (std.fs.path.dirname(path)) |dirpart| {
        try cwd.makePath(dirpart);
    }
    var f = try cwd.createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

// ---------- kind detection ----------
pub fn detectKindFromPath(p: []const u8) ?Kind {
    const ext = std.fs.path.extension(p);
    if (ext.len == 0) return null;
    if (std.ascii.eqlIgnoreCase(ext, ".dcz")) return .dcz;
    if (std.ascii.eqlIgnoreCase(ext, ".md")) return .md;
    if (std.ascii.eqlIgnoreCase(ext, ".html") or std.ascii.eqlIgnoreCase(ext, ".htm")) return .html;
    if (std.ascii.eqlIgnoreCase(ext, ".tex")) return .tex;
    return null;
}

// ---------- tiny arg helper used by convert CLI ----------
pub fn parseTo(it: *std.process.ArgIterator) !?[]const u8 {
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--to") or std.mem.eql(u8, arg, "-t")) {
            return it.next() orelse {
                try errW().writeAll("--to requires a value\n");
                return error.Invalid;
            };
        } else {
            try errW().print("unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }
    return null;
}

// -----------------------------------------------------------------------------
// Settings (file + CLI merge)
// -----------------------------------------------------------------------------

pub const Settings = struct {
    root: []const u8 = ".",
    port: u16 = 5173,
    open: bool = true, // CLI may flip this (e.g., preview default false)
    // Renderer-related toggles (passed through later):
    enable_katex: bool = true,
    enable_tailwind: bool = true,
    third_party_root: []const u8 = "third_party",
};

/// Minimal, stable JSON reader for a flat object:
/// Supports "root", "third_party_root" (strings),
/// "port" (int), "open", "enable_katex", "enable_tailwind" (bools).
pub fn loadSettings(alloc: std.mem.Allocator, path_opt: ?[]const u8) !Settings {
    var s: Settings = .{};
    const path = path_opt orelse "docz.settings.json";

    // Read whole file in one go using Dir.readFileAlloc; tolerate missing file.
    const data = std.fs.cwd().readFileAlloc(path, alloc, @enumFromInt(1 << 16)) catch |e| {
        if (e == error.FileNotFound) return s; // defaults if missing
        return e;
    };
    defer alloc.free(data);

    // Strings
    if (findJsonStringValue(data, "root")) |v| s.root = try alloc.dupe(u8, v);
    if (findJsonStringValue(data, "third_party_root")) |v| s.third_party_root = try alloc.dupe(u8, v);
    // Ints
    if (findJsonIntValue(u16, data, "port")) |p| s.port = p;
    // Bools
    if (findJsonBoolValue(data, "open")) |b| s.open = b;
    if (findJsonBoolValue(data, "enable_katex")) |b| s.enable_katex = b;
    if (findJsonBoolValue(data, "enable_tailwind")) |b| s.enable_tailwind = b;

    return s;
}

/// Apply CLI overrides on top of file settings.
pub fn withCliOverrides(
    base: Settings,
    cli: struct {
        root: ?[]const u8 = null,
        port: ?u16 = null,
        no_open: bool = false,
        enable_katex: ?bool = null,
        enable_tailwind: ?bool = null,
        third_party_root: ?[]const u8 = null,
    },
) Settings {
    var out = base;
    if (cli.root) |r| out.root = r;
    if (cli.port) |p| out.port = p;
    if (cli.no_open) out.open = false;
    if (cli.enable_katex) |b| out.enable_katex = b;
    if (cli.enable_tailwind) |b| out.enable_tailwind = b;
    if (cli.third_party_root) |r| out.third_party_root = r;
    return out;
}

// -----------------------------------------------------------------------------
// Tiny JSON helpers (flat, tolerant, no escapes)
// -----------------------------------------------------------------------------

fn findJsonStringValue(buf: []const u8, key: []const u8) ?[]const u8 {
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;

    var i: usize = key_i + quoted_key.len;
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1; // after ':'

    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != '"') return null;
    i += 1; // start of value

    const start = i;
    while (i < buf.len and buf[i] != '"') : (i += 1) {}
    if (i >= buf.len) return null;

    return buf[start..i];
}

fn findJsonIntValue(comptime T: type, buf: []const u8, key: []const u8) ?T {
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;

    var i: usize = key_i + quoted_key.len;
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1; // after ':'

    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len) return null;

    const start = i;
    while (i < buf.len and (buf[i] >= '0' and buf[i] <= '9')) : (i += 1) {}
    if (i == start) return null;

    return std.fmt.parseInt(T, buf[start..i], 10) catch null;
}

fn findJsonBoolValue(buf: []const u8, key: []const u8) ?bool {
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;

    var i: usize = key_i + quoted_key.len;
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1; // after ':'

    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    if (i >= buf.len) return null;

    if (std.mem.startsWith(u8, buf[i..], "true")) return true;
    if (std.mem.startsWith(u8, buf[i..], "false")) return false;
    return null;
}

// ----------------------
// ✅ Tests (existing)
// ----------------------

test "common.detectKindFromPath: case-insensitive mapping" {
    try std.testing.expect(detectKindFromPath("x.dcz") == .dcz);
    try std.testing.expect(detectKindFromPath("x.DCZ") == .dcz);

    try std.testing.expect(detectKindFromPath("x.md") == .md);
    try std.testing.expect(detectKindFromPath("x.MD") == .md);

    try std.testing.expect(detectKindFromPath("x.html") == .html);
    try std.testing.expect(detectKindFromPath("x.htm") == .html);
    try std.testing.expect(detectKindFromPath("x.HTML") == .html);
    try std.testing.expect(detectKindFromPath("x.HTM") == .html);

    try std.testing.expect(detectKindFromPath("x.tex") == .tex);
    try std.testing.expect(detectKindFromPath("x.TEX") == .tex);

    try std.testing.expect(detectKindFromPath("x") == null);
    try std.testing.expect(detectKindFromPath("x.unknown") == null);
}

<<<

`convert.zig`: >>>

const std = @import("std");
const docz = @import("docz");

// internal converters (wired via build.zig)
const html_import = @import("html_import");
const html_export = @import("html_export");
const md_import = @import("md_import");
const md_export = @import("md_export");
const latex_import = @import("latex_import");
const latex_export = @import("latex_export");

pub const Kind = enum { dcz, md, html, tex };

/// Try a handful of possible symbol names for the Markdown→DCZ importer.
/// If none exist in this build, return a specific error instead of @compileError.
fn importMarkdownToDczCompat(alloc: std.mem.Allocator, input: []const u8) ![]u8 {
    if (comptime @hasDecl(md_import, "importMarkdownToDcz")) {
        return md_import.importMarkdownToDcz(alloc, input);
    } else if (comptime @hasDecl(md_import, "importToDcz")) {
        return md_import.importToDcz(alloc, input);
    } else if (comptime @hasDecl(md_import, "importMdToDcz")) {
        return md_import.importMdToDcz(alloc, input);
    } else if (comptime @hasDecl(md_import, "fromMarkdownToDcz")) {
        return md_import.fromMarkdownToDcz(alloc, input);
    } else if (comptime @hasDecl(md_import, "importMarkdown")) {
        // Some trees expose a generic name
        return md_import.importMarkdown(alloc, input);
    } else {
        return error.MarkdownImportUnavailable;
    }
}

fn detectKindFromPath(p: []const u8) ?Kind {
    const ext = std.fs.path.extension(p);
    if (ext.len == 0) return null;
    if (std.ascii.eqlIgnoreCase(ext, ".dcz")) return .dcz;
    if (std.ascii.eqlIgnoreCase(ext, ".md")) return .md;
    if (std.ascii.eqlIgnoreCase(ext, ".html") or std.ascii.eqlIgnoreCase(ext, ".htm")) return .html;
    if (std.ascii.eqlIgnoreCase(ext, ".tex")) return .tex;
    return null;
}

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    var f = try std.fs.cwd().openFile(path, .{});
    defer f.close();

    var out = std.ArrayList(u8){};
    defer out.deinit(alloc);

    var buf: [16 * 1024]u8 = undefined;
    var total: usize = 0;
    while (true) {
        const n = try f.read(&buf);
        if (n == 0) break;
        total += n;
        // optional safety cap (~64 MiB)
        if (total > (1 << 26)) return error.FileTooLarge;
        try out.appendSlice(alloc, buf[0..n]);
    }

    return try out.toOwnedSlice(alloc);
}

fn writeFile(path: []const u8, data: []const u8) !void {
    const cwd = std.fs.cwd();
    if (std.fs.path.dirname(path)) |dirpart| {
        try cwd.makePath(dirpart);
    }
    var f = try cwd.createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(data);
}

fn replaceExt(alloc: std.mem.Allocator, path: []const u8, new_ext_with_dot: []const u8) ![]u8 {
    const dir = std.fs.path.dirname(path);
    const stem = std.fs.path.stem(path);
    if (dir) |d| {
        return try std.fmt.allocPrint(alloc, "{s}{c}{s}{s}", .{ d, std.fs.path.sep, stem, new_ext_with_dot });
    } else {
        return try std.fmt.allocPrint(alloc, "{s}{s}", .{ stem, new_ext_with_dot });
    }
}

fn insertCssLinkBeforeHeadClose(alloc: std.mem.Allocator, html: []const u8, href: []const u8) ![]u8 {
    const needle = "</head>";
    const idx_opt = std.mem.indexOf(u8, html, needle);
    if (idx_opt == null) {
        return try std.fmt.allocPrint(alloc, "<link rel=\"stylesheet\" href=\"{s}\">\n{s}", .{ href, html });
    }
    const idx = idx_opt.?;

    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);

    try out.appendSlice(alloc, html[0..idx]);
    try out.appendSlice(alloc, "<link rel=\"stylesheet\" href=\"");
    try out.appendSlice(alloc, href);
    try out.appendSlice(alloc, "\">\n");
    try out.appendSlice(alloc, html[idx..]);

    return out.toOwnedSlice(alloc);
}

fn writeIndent(w: anytype, n: usize) !void {
    var k: usize = 0;
    while (k < n) : (k += 1) try w.writeByte(' ');
}

fn isWs(b: u8) bool {
    return b == ' ' or b == '\t' or b == '\r';
}
fn lowerAscii(c: u8) u8 {
    return if (c >= 'A' and c <= 'Z') c + 32 else c;
}
fn eqLower(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    var i: usize = 0;
    while (i < a.len) : (i += 1) {
        if (lowerAscii(a[i]) != lowerAscii(b[i])) return false;
    }
    return true;
}
fn isVoidTag(name: []const u8) bool {
    return eqLower(name, "area") or eqLower(name, "base") or eqLower(name, "br") or
        eqLower(name, "col") or eqLower(name, "embed") or eqLower(name, "hr") or
        eqLower(name, "img") or eqLower(name, "input") or eqLower(name, "link") or
        eqLower(name, "meta") or eqLower(name, "param") or eqLower(name, "source") or
        eqLower(name, "track") or eqLower(name, "wbr");
}

fn prettyHtml(alloc: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);

    var indent: usize = 0;
    var i: usize = 0;

    while (i < html.len) {
        const line_start = i;
        while (i < html.len and html[i] != '\n') : (i += 1) {}
        const raw = html[line_start..i];
        if (i < html.len and html[i] == '\n') i += 1;

        const line = std.mem.trim(u8, raw, " \t\r");
        if (line.len == 0) {
            try out.append(alloc, '\n');
            continue;
        }

        var j: usize = 0;
        while (j < line.len and isWs(line[j])) : (j += 1) {}

        const starts_with_lt = (j < line.len and line[j] == '<');

        var pre_decr: usize = 0;
        var post_incr: usize = 0;

        if (starts_with_lt) {
            const after_lt = j + 1;
            const is_close = after_lt < line.len and line[after_lt] == '/';
            const is_decl_or_comment = after_lt < line.len and (line[after_lt] == '!' or line[after_lt] == '?');

            var name_start: usize = after_lt;
            if (is_close) name_start += 1;
            while (name_start < line.len and isWs(line[name_start])) : (name_start += 1) {}

            var name_end = name_start;
            while (name_end < line.len) : (name_end += 1) {
                const ch = line[name_end];
                if (ch == '>' or ch == '/' or isWs(ch) or ch == '\n') break;
            }
            const tag_name = if (name_end > name_start) line[name_start..name_end] else line[name_start..name_start];

            const self_closed_syntax = line.len >= 2 and line[line.len - 2] == '/' and line[line.len - 1] == '>';
            const voidish = isVoidTag(tag_name);
            const has_inline_close = std.mem.indexOf(u8, line, "</") != null;

            if (is_close and !is_decl_or_comment) {
                if (indent > 0) pre_decr = 1;
            } else if (!is_decl_or_comment and !self_closed_syntax and !voidish) {
                if (!has_inline_close) post_incr = 1;
            }
        }

        if (pre_decr > 0 and indent >= pre_decr) indent -= pre_decr;

        try out.appendNTimes(alloc, ' ', indent * 2);
        try out.appendSlice(alloc, line);
        try out.append(alloc, '\n');

        indent += post_incr;
    }

    return out.toOwnedSlice(alloc);
}

// ─────────────────────────────────────────────────────────────
// PUBLIC ENTRY
// ─────────────────────────────────────────────────────────────
pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const usage =
        "Usage: docz convert <input.{dcz|md|html|htm|tex}> [--to|-t <output.{dcz|md|html|tex}>]\n" ++
        "       [--css inline|file] [--css-file <path>] [--pretty|--no-pretty]\n";

    const in_path = it.next() orelse {
        std.debug.print("{s}", .{usage});
        return error.Invalid;
    };

    var out_path: ?[]const u8 = null;

    const CssMode = enum { inline_css, file };
    var css_mode: CssMode = .inline_css;
    var css_file: ?[]const u8 = null;

    var pretty: bool = true;

    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--to") or std.mem.eql(u8, arg, "-t")) {
            out_path = it.next() orelse {
                std.debug.print("convert: --to requires a value\n", .{});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--css")) {
            const v = it.next() orelse {
                std.debug.print("convert: --css requires a value: inline|file\n", .{});
                return error.Invalid;
            };
            if (std.mem.eql(u8, v, "inline")) css_mode = .inline_css else if (std.mem.eql(u8, v, "file")) css_mode = .file else {
                std.debug.print("convert: --css must be 'inline' or 'file' (got '{s}')\n", .{v});
                return error.Invalid;
            }
        } else if (std.mem.eql(u8, arg, "--css-file")) {
            css_file = it.next() orelse {
                std.debug.print("convert: --css-file requires a value\n", .{});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--pretty")) {
            pretty = true;
        } else if (std.mem.eql(u8, arg, "--no-pretty")) {
            pretty = false;
        } else {
            std.debug.print("convert: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    const in_kind = detectKindFromPath(in_path) orelse {
        std.debug.print("convert: unsupported input type: {s}\n", .{in_path});
        return error.Invalid;
    };

    const input = readFileAlloc(alloc, in_path) catch |e| {
        const cwd_buf: ?[]u8 = std.fs.cwd().realpathAlloc(alloc, ".") catch null;
        defer if (cwd_buf) |buf| alloc.free(buf);
        const cwd = cwd_buf orelse "<?>";

        std.debug.print("convert: failed to read '{s}' (cwd: {s}): {s}\n", .{ in_path, cwd, @errorName(e) });
        return e;
    };
    defer alloc.free(input);

    var out_buf: []u8 = &[_]u8{};
    defer if (out_buf.len != 0 and out_buf.ptr != input.ptr) alloc.free(out_buf);

    if (in_kind == .dcz) {
        const tokens = try docz.Tokenizer.tokenize(input, alloc);
        defer {
            docz.Tokenizer.freeTokens(alloc, tokens);
            alloc.free(tokens);
        }

        var ast = try docz.Parser.parse(tokens, alloc);
        defer ast.deinit(alloc);

        const out_kind = if (out_path) |p| detectKindFromPath(p) else null;

        if (out_kind == null or out_kind.? == .dcz) {
            out_buf = try alloc.dupe(u8, input);
        } else switch (out_kind.?) {
            .md => out_buf = try md_export.exportAstToMarkdown(&ast, alloc),

            .html => {
                const html_inline = try html_export.exportHtml(&ast, alloc);
                errdefer alloc.free(html_inline);

                if (css_mode == .file) {
                    var css_path: []const u8 = undefined;
                    var css_path_needs_free = false;
                    if (css_file) |p| {
                        css_path = p;
                    } else if (out_path) |to_path| {
                        css_path = try replaceExt(alloc, to_path, ".css");
                        css_path_needs_free = true;
                    } else {
                        css_path = "docz.css";
                    }
                    defer if (css_path_needs_free) alloc.free(css_path);

                    const css_blob = try html_export.collectInlineCss(html_inline, alloc);
                    defer alloc.free(css_blob);
                    try writeFile(css_path, css_blob);

                    const html_no_style = try html_export.stripFirstStyleBlock(html_inline, alloc);
                    alloc.free(html_inline);

                    const html_linked = try insertCssLinkBeforeHeadClose(alloc, html_no_style, css_path);
                    alloc.free(html_no_style);

                    if (pretty) {
                        const pretty_buf = try prettyHtml(alloc, html_linked);
                        alloc.free(html_linked);
                        out_buf = pretty_buf;
                    } else {
                        out_buf = html_linked;
                    }
                } else {
                    if (pretty) {
                        const pretty_buf = try prettyHtml(alloc, html_inline);
                        alloc.free(html_inline);
                        out_buf = pretty_buf;
                    } else {
                        out_buf = html_inline;
                    }
                }
            },

            .tex => out_buf = try latex_export.exportAstToLatex(&ast, alloc),
            .dcz => unreachable,
        }
    } else {
        switch (in_kind) {
            .md => {
                out_buf = importMarkdownToDczCompat(alloc, input) catch |e| {
                    if (e == error.MarkdownImportUnavailable) {
                        std.debug.print(
                            "convert: this build lacks a Markdown→DCZ importer in md_import; " ++
                                "rebuild with the markdown importer or use .dcz/.html/.tex.\n",
                            .{},
                        );
                        return error.Invalid;
                    }
                    return e;
                };
            },
            .html => out_buf = try html_import.importHtmlToDcz(alloc, input),
            .tex => out_buf = try latex_import.importLatexToDcz(alloc, input),
            .dcz => unreachable,
        }
    }

    if (out_path) |p| {
        if (detectKindFromPath(p) == null) {
            std.debug.print("convert: unsupported output type: {s}\n", .{p});
            return error.Invalid;
        }
        try writeFile(p, out_buf);
    } else {
        std.debug.print("{s}", .{out_buf});
    }
}

test "convert.detectKindFromPath: basic mapping" {
    try std.testing.expect(detectKindFromPath("a.dcz") == .dcz);
    try std.testing.expect(detectKindFromPath("a.MD") == .md);
    try std.testing.expect(detectKindFromPath("a.html") == .html);
    try std.testing.expect(detectKindFromPath("a.HTM") == .html);
    try std.testing.expect(detectKindFromPath("a.tex") == .tex);
    try std.testing.expect(detectKindFromPath("noext") == null);
}

<<<

`enable_wasm.zig`: >>>

const std = @import("std");

/// `docz enable wasm`
pub fn run(_: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    // Expect exactly one arg: "wasm"
    const sub = it.next() orelse {
        std.debug.print("Usage: docz enable wasm\n", .{});
        return error.Invalid;
    };

    if (!std.mem.eql(u8, sub, "wasm")) {
        std.debug.print("Usage: docz enable wasm\n", .{});
        return error.Invalid;
    }

    // Do whatever enabling would mean later; for now just a friendly confirmation.
    std.debug.print("Enabling WASM execution support...\n", .{});
}

<<<

`fallback.zig`: >>>

const std = @import("std");

// ─────────────────────────────────────────────────────────────
// Tiny HTML escaper
// ─────────────────────────────────────────────────────────────
fn htmlAppendEscChar(out: *std.ArrayList(u8), alloc: std.mem.Allocator, ch: u8) !void {
    switch (ch) {
        '&' => try out.appendSlice(alloc, "&amp;"),
        '<' => try out.appendSlice(alloc, "&lt;"),
        '>' => try out.appendSlice(alloc, "&gt;"),
        '"' => try out.appendSlice(alloc, "&quot;"),
        '\'' => try out.appendSlice(alloc, "&#39;"),
        else => try out.append(alloc, ch),
    }
}

fn htmlEscape(alloc: std.mem.Allocator, s: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);
    for (s) |ch| try htmlAppendEscChar(&out, alloc, ch);
    return out.toOwnedSlice(alloc);
}

fn flushParagraph(p: *std.ArrayList(u8), out: *std.ArrayList(u8), alloc: std.mem.Allocator) !void {
    if (p.items.len == 0) return;
    try out.appendSlice(alloc, "<p>");
    try out.appendSlice(alloc, p.items);
    try out.appendSlice(alloc, "</p>\n");
    p.clearRetainingCapacity();
}

// ─────────────────────────────────────────────────────────────
// Inline formatter: **bold**, *italic*, `code`, [text](url)
// ─────────────────────────────────────────────────────────────
fn inlineFormat(alloc: std.mem.Allocator, line: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);

    var i: usize = 0;
    var em_on = false;
    var strong_on = false;
    var code_on = false;

    while (i < line.len) {
        const c = line[i];

        // Toggle inline code: `code`
        if (c == '`') {
            if (code_on)
                try out.appendSlice(alloc, "</code>")
            else
                try out.appendSlice(alloc, "<code>");
            code_on = !code_on;
            i += 1;
            continue;
        }

        if (!code_on) {
            // Markdown link: [text](url)
            if (c == '[') {
                const close_br = std.mem.indexOfScalarPos(u8, line, i + 1, ']') orelse {
                    try htmlAppendEscChar(&out, alloc, c);
                    i += 1;
                    continue;
                };
                if (close_br + 1 < line.len and line[close_br + 1] == '(') {
                    const close_par = std.mem.indexOfScalarPos(u8, line, close_br + 2, ')') orelse {
                        try htmlAppendEscChar(&out, alloc, c);
                        i += 1;
                        continue;
                    };
                    const text_raw = line[i + 1 .. close_br];
                    const url_raw = line[close_br + 2 .. close_par];

                    const text_esc = try htmlEscape(alloc, text_raw);
                    defer alloc.free(text_esc);
                    const url_esc = try htmlEscape(alloc, url_raw);
                    defer alloc.free(url_esc);

                    try out.appendSlice(alloc, "<a href=\"");
                    try out.appendSlice(alloc, url_esc);
                    try out.appendSlice(alloc, "\">");
                    try out.appendSlice(alloc, text_esc);
                    try out.appendSlice(alloc, "</a>");

                    i = close_par + 1;
                    continue;
                }
            }

            // Strong: **...**
            if (i + 1 < line.len and line[i] == '*' and line[i + 1] == '*') {
                if (strong_on)
                    try out.appendSlice(alloc, "</strong>")
                else
                    try out.appendSlice(alloc, "<strong>");
                strong_on = !strong_on;
                i += 2;
                continue;
            }

            // Emphasis: *...*
            if (line[i] == '*') {
                if (em_on)
                    try out.appendSlice(alloc, "</em>")
                else
                    try out.appendSlice(alloc, "<em>");
                em_on = !em_on;
                i += 1;
                continue;
            }
        }

        // Plain character (escaped)
        try htmlAppendEscChar(&out, alloc, c);
        i += 1;
    }

    // Close any unclosed tags (best-effort)
    if (strong_on) try out.appendSlice(alloc, "</strong>");
    if (em_on) try out.appendSlice(alloc, "</em>");
    if (code_on) try out.appendSlice(alloc, "</code>");

    return out.toOwnedSlice(alloc);
}

// ─────────────────────────────────────────────────────────────
// Minimal fallback renderer (headings/paragraphs/code/math)
// Extracts @meta(title:"...") to fill <title>
// ─────────────────────────────────────────────────────────────
pub fn render(alloc: std.mem.Allocator, dcz: []const u8) ![]u8 {
    var body = std.ArrayList(u8){};
    errdefer body.deinit(alloc);

    var in_style = false;

    var in_code = false;
    var code_lang: []const u8 = "text";

    var in_math = false;
    var math_buf = std.ArrayList(u8){};
    defer math_buf.deinit(alloc);

    var para = std.ArrayList(u8){};
    defer para.deinit(alloc);

    // (optional) title from @meta(title:"...")
    var title_buf = std.ArrayList(u8){};
    defer title_buf.deinit(alloc);
    try title_buf.appendSlice(alloc, "Docz Preview");

    var it = std.mem.splitScalar(u8, dcz, '\n');
    while (it.next()) |raw_line| {
        const line = std.mem.trim(u8, raw_line, " \t\r");

        // Block terminator
        if (std.mem.eql(u8, line, "@end")) {
            if (in_style) {
                in_style = false;
                continue;
            }

            if (in_code) {
                try body.appendSlice(alloc, "</code></pre>\n");
                in_code = false;
                continue;
            }

            if (in_math) {
                // finalize one KaTeX display block
                const mb = math_buf.items;
                var end = mb.len;
                while (end > 0 and (mb[end - 1] == ' ' or mb[end - 1] == '\t')) end -= 1;

                const esc = try htmlEscape(alloc, mb[0..end]);
                defer alloc.free(esc);

                try body.appendSlice(alloc, "<p>$$ ");
                try body.appendSlice(alloc, esc);
                try body.appendSlice(alloc, " $$</p>\n");

                math_buf.clearRetainingCapacity();
                in_math = false;
                continue;
            }
        }

        // Inside blocks
        if (in_style) continue;

        if (in_code) {
            const esc = try htmlEscape(alloc, raw_line);
            defer alloc.free(esc);
            try body.appendSlice(alloc, esc);
            try body.append(alloc, '\n');
            continue;
        }

        if (in_math) {
            if (line.len != 0) {
                if (math_buf.items.len != 0) try math_buf.append(alloc, ' ');
                try math_buf.appendSlice(alloc, line);
            }
            continue;
        }

        // Block starters
        if (std.mem.startsWith(u8, line, "@style")) {
            try flushParagraph(&para, &body, alloc);
            in_style = true;
            continue;
        }

        if (std.mem.startsWith(u8, line, "@meta")) {
            try flushParagraph(&para, &body, alloc);
            if (std.mem.indexOfScalar(u8, line, '(')) |lp| {
                if (std.mem.indexOfScalarPos(u8, line, lp, ')')) |rp| {
                    const inside = line[lp + 1 .. rp];
                    if (std.mem.indexOf(u8, inside, "title:\"")) |p0| {
                        const start = p0 + 7; // after title:"
                        if (std.mem.indexOfScalarPos(u8, inside, start, '"')) |p1| {
                            title_buf.clearRetainingCapacity();
                            const t_esc = try htmlEscape(alloc, inside[start..p1]);
                            defer alloc.free(t_esc);
                            try title_buf.appendSlice(alloc, t_esc);
                        }
                    }
                }
            }
            continue;
        }

        if (std.mem.startsWith(u8, line, "@code")) {
            try flushParagraph(&para, &body, alloc);

            code_lang = "text";
            if (std.mem.indexOfScalar(u8, line, '(')) |lp| {
                if (std.mem.indexOfScalarPos(u8, line, lp, ')')) |rp| {
                    const inside = line[lp + 1 .. rp];
                    if (std.mem.indexOf(u8, inside, "lang:\"")) |p0| {
                        const start = p0 + 6; // after lang:"
                        if (std.mem.indexOfScalarPos(u8, inside, start, '"')) |p1| {
                            code_lang = inside[start..p1];
                        }
                    }
                }
            }
            const lang_esc = try htmlEscape(alloc, code_lang);
            defer alloc.free(lang_esc);
            try body.appendSlice(alloc, "<pre><code class=\"language-");
            try body.appendSlice(alloc, lang_esc);
            try body.appendSlice(alloc, "\">");
            in_code = true;
            continue;
        }

        if (std.mem.startsWith(u8, line, "@math")) {
            try flushParagraph(&para, &body, alloc);
            in_math = true;
            continue;
        }

        // Blank line ⇒ paragraph break
        if (line.len == 0) {
            try flushParagraph(&para, &body, alloc);
            continue;
        }

        // Headings
        if (std.mem.startsWith(u8, line, "### ")) {
            try flushParagraph(&para, &body, alloc);
            const h = try inlineFormat(alloc, line[4..]);
            defer alloc.free(h);
            try body.appendSlice(alloc, "<h3>");
            try body.appendSlice(alloc, h);
            try body.appendSlice(alloc, "</h3>\n");
            continue;
        }
        if (std.mem.startsWith(u8, line, "## ")) {
            try flushParagraph(&para, &body, alloc);
            const h = try inlineFormat(alloc, line[3..]);
            defer alloc.free(h);
            try body.appendSlice(alloc, "<h2>");
            try body.appendSlice(alloc, h);
            try body.appendSlice(alloc, "</h2>\n");
            continue;
        }
        if (std.mem.startsWith(u8, line, "# ")) {
            try flushParagraph(&para, &body, alloc);
            const h = try inlineFormat(alloc, line[2..]);
            defer alloc.free(h);
            try body.appendSlice(alloc, "<h1>");
            try body.appendSlice(alloc, h);
            try body.appendSlice(alloc, "</h1>\n");
            continue;
        }

        // Normal line → part of current paragraph
        const frag = try inlineFormat(alloc, line);
        defer alloc.free(frag);
        if (para.items.len != 0) try para.append(alloc, ' ');
        try para.appendSlice(alloc, frag);
    }

    // flush trailing paragraph
    try flushParagraph(&para, &body, alloc);

    // wrap document with computed title
    var doc = std.ArrayList(u8){};
    errdefer doc.deinit(alloc);

    try doc.appendSlice(alloc,
        \\<!DOCTYPE html>
        \\<html>
        \\  <head>
        \\    <meta charset="utf-8">
        \\    <meta name="viewport" content="width=device-width, initial-scale=1" />
        \\    <title>
    );
    try doc.appendSlice(alloc, title_buf.items);
    try doc.appendSlice(alloc,
        \\</title>
        \\  </head>
        \\  <body>
        \\
    );
    try doc.appendSlice(alloc, body.items);
    try doc.appendSlice(alloc,
        \\  </body>
        \\</html>
        \\
    );

    return doc.toOwnedSlice(alloc);
}

<<<

`html_ops.zig`: >>>

const std = @import("std");

// Insert a <link rel="stylesheet" href="..."> before </head>
// (or prefix the document if no </head> exists).
pub fn insertCssLinkBeforeHeadClose(
    alloc: std.mem.Allocator,
    html: []const u8,
    href: []const u8,
) ![]u8 {
    const needle = "</head>";
    const idx_opt = std.mem.indexOf(u8, html, needle);
    if (idx_opt == null) {
        return try std.fmt.allocPrint(alloc, "<link rel=\"stylesheet\" href=\"{s}\">\n{s}", .{ href, html });
    }
    const idx = idx_opt.?;

    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);

    try out.appendSlice(alloc, html[0..idx]);
    try out.appendSlice(alloc, "<link rel=\"stylesheet\" href=\"");
    try out.appendSlice(alloc, href);
    try out.appendSlice(alloc, "\">\n");
    try out.appendSlice(alloc, html[idx..]);

    return out.toOwnedSlice(alloc);
}

pub fn insertBeforeHeadClose(
    alloc: std.mem.Allocator,
    html: []const u8,
    snippet: []const u8,
) ![]u8 {
    const needle = "</head>";
    if (std.mem.indexOf(u8, html, needle)) |idx| {
        var out = std.ArrayList(u8){};
        errdefer out.deinit(alloc);
        try out.appendSlice(alloc, html[0..idx]);
        try out.appendSlice(alloc, snippet);
        try out.appendSlice(alloc, html[idx..]);
        return out.toOwnedSlice(alloc);
    }
    return std.fmt.allocPrint(alloc, "{s}{s}", .{ snippet, html });
}

// Hot-reload marker + script
pub fn writeHotMarker(alloc: std.mem.Allocator, out_dir: []const u8, marker_name: []const u8) !void {
    const path = try std.fs.path.join(alloc, &.{ out_dir, marker_name });
    defer alloc.free(path);

    const t: i128 = std.time.nanoTimestamp();
    var hasher = std.hash.Wyhash.init(0);
    hasher.update(std.mem.asBytes(&t));
    const seed: u64 = hasher.final();

    var prng = std.Random.DefaultPrng.init(seed);
    const r = prng.random().int(u64);

    const payload = try std.fmt.allocPrint(alloc, "{d}-{x}\n", .{ std.time.milliTimestamp(), r });
    defer alloc.free(payload);

    var f = try std.fs.cwd().createFile(path, .{ .truncate = true });
    defer f.close();
    try f.writeAll(payload);
}

pub fn injectLiveScript(alloc: std.mem.Allocator, html: []const u8, marker_name: []const u8) ![]u8 {
    const script =
        \\<script>
        \\(function(){
        \\  var URL = "__DOCZ_HOT__";
        \\  var last = null;
        \\  function tick(){
        \\    fetch(URL, {cache: 'no-store'}).then(function(r){return r.text()}).then(function(t){
        \\      if (last === null) last = t;
        \\      else if (t !== last) location.reload();
        \\    }).catch(function(_){}).finally(function(){ setTimeout(tick, 500); });
        \\  }
        \\  tick();
        \\})();
        \\</script>
        \\
    ;

    const idx_opt = std.mem.indexOf(u8, html, "</body>");
    const tag = try std.fmt.allocPrint(alloc, "{s}", .{script});
    defer alloc.free(tag);

    const with_url = try std.mem.replaceOwned(u8, alloc, tag, "__DOCZ_HOT__", marker_name);
    errdefer alloc.free(with_url);

    if (idx_opt) |idx| {
        var out = std.ArrayList(u8){};
        errdefer out.deinit(alloc);
        try out.appendSlice(alloc, html[0..idx]);
        try out.appendSlice(alloc, with_url);
        try out.appendSlice(alloc, html[idx..]);
        return out.toOwnedSlice(alloc);
    }

    // Fallback: append at end if no </body>
    return std.fmt.allocPrint(alloc, "{s}\n{s}", .{ html, with_url });
}

// Lightweight pretty printer for readability in dev
pub fn prettyHtml(alloc: std.mem.Allocator, html: []const u8) ![]u8 {
    var out = std.ArrayList(u8){};
    errdefer out.deinit(alloc);

    var indent: usize = 0;
    var i: usize = 0;

    while (i < html.len) {
        const line_start = i;
        while (i < html.len and html[i] != '\n') : (i += 1) {}
        const raw = html[line_start..i];
        if (i < html.len and html[i] == '\n') i += 1;

        const line = std.mem.trim(u8, raw, " \t\r");
        if (line.len == 0) {
            try out.append(alloc, '\n');
            continue;
        }

        var j: usize = 0;
        while (j < line.len and (line[j] == ' ' or line[j] == '\t' or line[j] == '\r')) : (j += 1) {}
        const starts_with_lt = (j < line.len and line[j] == '<');

        var pre_decr: usize = 0;
        var post_incr: usize = 0;

        if (starts_with_lt) {
            const after_lt = j + 1;
            const is_close = after_lt < line.len and line[after_lt] == '/';
            const is_decl = after_lt < line.len and (line[after_lt] == '!' or line[after_lt] == '?');

            var name_start: usize = after_lt;
            if (is_close) name_start += 1;
            while (name_start < line.len and (line[name_start] == ' ' or line[name_start] == '\t' or line[name_start] == '\r')) : (name_start += 1) {}

            var name_end = name_start;
            while (name_end < line.len) : (name_end += 1) {
                const ch = line[name_end];
                if (ch == '>' or ch == '/' or ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n') break;
            }
            const tag_name = if (name_end > name_start) line[name_start..name_end] else line[name_start..name_start];

            const voidish =
                std.mem.eql(u8, tag_name, "meta") or
                std.mem.eql(u8, tag_name, "link") or
                std.mem.eql(u8, tag_name, "br") or
                std.mem.eql(u8, tag_name, "img") or
                std.mem.eql(u8, tag_name, "hr");
            const self_closed = line.len >= 2 and line[line.len - 2] == '/' and line[line.len - 1] == '>';
            const has_inline_close = std.mem.indexOf(u8, line, "</") != null;

            if (is_close and !is_decl) {
                if (indent > 0) pre_decr = 1;
            } else if (!is_decl and !self_closed and !voidish and !has_inline_close) {
                post_incr = 1;
            }
        }

        if (pre_decr > 0 and indent >= pre_decr) indent -= pre_decr;

        try out.appendNTimes(alloc, ' ', indent * 2);
        try out.appendSlice(alloc, line);
        try out.append(alloc, '\n');

        indent += post_incr;
    }

    return out.toOwnedSlice(alloc);
}

<<<

`preview.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const web_preview = @import("web_preview");

// -----------------------------------------------------------------------------
// Tiny settings loader (flat JSON, no std.json dependency)
// Reads: root (string), port (int), open (bool). CLI flags override these.
// -----------------------------------------------------------------------------

const FileSettings = struct {
    root: []const u8 = ".",
    port: u16 = 5173,
    open: bool = true,
};

fn readFileAlloc(alloc: std.mem.Allocator, path: []const u8, max: usize) ![]u8 {
    // Zig 0.16: Dir.readFileAlloc(path, allocator, Io.Limit)
    return std.fs.cwd().readFileAlloc(path, alloc, @enumFromInt(max));
}

fn skipWs(buf: []const u8, start: usize) usize {
    var i = start;
    while (i < buf.len and (buf[i] == ' ' or buf[i] == '\t' or buf[i] == '\r' or buf[i] == '\n')) : (i += 1) {}
    return i;
}

fn findJsonStringValue(buf: []const u8, key: []const u8) ?[]const u8 {
    // Build the `"key"` pattern using a tiny fixed buffer (no heap leaks).
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;
    var i: usize = key_i + quoted_key.len;

    i = skipWs(buf, i);
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1;

    i = skipWs(buf, i);
    if (i >= buf.len or buf[i] != '"') return null;
    i += 1;

    const start = i;
    while (i < buf.len and buf[i] != '"') : (i += 1) {}
    if (i >= buf.len) return null;

    return buf[start..i];
}

fn findJsonIntValue(comptime T: type, buf: []const u8, key: []const u8) ?T {
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;
    var i: usize = key_i + quoted_key.len;

    i = skipWs(buf, i);
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1;

    i = skipWs(buf, i);
    if (i >= buf.len) return null;

    const start = i;
    while (i < buf.len and (buf[i] >= '0' and buf[i] <= '9')) : (i += 1) {}
    if (i == start) return null;

    return std.fmt.parseInt(T, buf[start..i], 10) catch null;
}

fn findJsonBoolValue(buf: []const u8, key: []const u8) ?bool {
    var pat_buf: [128]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&pat_buf);
    const A = fba.allocator();
    const quoted_key = std.fmt.allocPrint(A, "\"{s}\"", .{key}) catch return null;

    const key_i = std.mem.indexOf(u8, buf, quoted_key) orelse return null;
    var i: usize = key_i + quoted_key.len;

    i = skipWs(buf, i);
    if (i >= buf.len or buf[i] != ':') return null;
    i += 1;

    i = skipWs(buf, i);
    if (i >= buf.len) return null;

    if (std.mem.startsWith(u8, buf[i..], "true")) return true;
    if (std.mem.startsWith(u8, buf[i..], "false")) return false;
    return null;
}

fn loadFileSettings(alloc: std.mem.Allocator, path_opt: ?[]const u8) !FileSettings {
    var s: FileSettings = .{};
    const path = path_opt orelse "docz.settings.json";

    const buf = readFileAlloc(alloc, path, 1 << 16) catch |e| {
        if (e == error.FileNotFound) return s; // defaults if missing
        return e;
    };
    defer alloc.free(buf);

    if (findJsonStringValue(buf, "root")) |v| s.root = try alloc.dupe(u8, v);
    if (findJsonIntValue(u16, buf, "port")) |p| s.port = p;
    if (findJsonBoolValue(buf, "open")) |b| s.open = b;

    return s;
}

// -----------------------------------------------------------------------------
// URL helpers
// -----------------------------------------------------------------------------

fn isUnreserved(ch: u8) bool {
    return (ch >= 'A' and ch <= 'Z') or (ch >= 'a' and ch <= 'z') or (ch >= '0' and ch <= '9') or ch == '-' or ch == '_' or ch == '.' or ch == '~' or ch == '/'; // keep slashes in path
}

fn urlEncode(alloc: std.mem.Allocator, s: []const u8) ![]u8 {
    // Worst-case 3x expansion
    var out = try alloc.alloc(u8, s.len * 3);
    var j: usize = 0;

    var i: usize = 0;
    while (i < s.len) : (i += 1) {
        const c = s[i];
        if (isUnreserved(c)) {
            out[j] = c;
            j += 1;
        } else {
            out[j + 0] = '%';
            out[j + 1] = "0123456789ABCDEF"[(c >> 4) & 0xF];
            out[j + 2] = "0123456789ABCDEF"[c & 0xF];
            j += 3;
        }
    }
    return alloc.realloc(out, j);
}

// -----------------------------------------------------------------------------
// CLI
// -----------------------------------------------------------------------------

pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    // Defaults (overridden by config file if present, and then by CLI flags)
    var cfg_path: ?[]const u8 = null;
    var fs = try loadFileSettings(alloc, cfg_path);

    var doc_root: []const u8 = fs.root;
    var port: u16 = fs.port;
    var open_browser: bool = fs.open;

    var path: []const u8 = "docs/SPEC.dcz";
    var have_positional = false;

    // Parse: [<path>] [--root|-r DIR] [--port|-p N] [--no-open] [--config <file>] [--help|-h]
    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--help") or std.mem.eql(u8, arg, "-h")) {
            return printUsage();
        } else if (std.mem.eql(u8, arg, "--config")) {
            const v = it.next() orelse {
                std.debug.print("preview: --config requires a value\n", .{});
                return error.Invalid;
            };
            cfg_path = v;
            fs = try loadFileSettings(alloc, cfg_path);
            // Re-apply config defaults unless already overridden by flags seen earlier
            doc_root = fs.root;
            port = fs.port;
            open_browser = fs.open;
        } else if (std.mem.eql(u8, arg, "--root") or std.mem.eql(u8, arg, "-r")) {
            const v = it.next() orelse {
                std.debug.print("preview: --root requires a value\n", .{});
                return error.Invalid;
            };
            doc_root = v;
        } else if (std.mem.eql(u8, arg, "--port") or std.mem.eql(u8, arg, "-p")) {
            const v = it.next() orelse {
                std.debug.print("preview: --port requires a value\n", .{});
                return error.Invalid;
            };
            port = std.fmt.parseInt(u16, v, 10) catch {
                std.debug.print("preview: invalid port: {s}\n", .{v});
                return error.Invalid;
            };
        } else if (std.mem.eql(u8, arg, "--no-open")) {
            open_browser = false;
        } else if (arg.len > 0 and arg[0] != '-') {
            if (have_positional) {
                std.debug.print("preview: unknown arg: {s}\n", .{arg});
                return error.Invalid;
            }
            path = arg;
            have_positional = true;
        } else {
            std.debug.print("preview: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    // Start server (module is `web_preview`; type is `PreviewServer`)
    var server = try web_preview.PreviewServer.init(alloc, doc_root);
    defer server.deinit();

    // Optionally open the browser
    if (open_browser) {
        try openBrowser(alloc, port, path);
    }

    // Block and serve
    try server.listenAndServe(port);
}

fn openBrowser(alloc: std.mem.Allocator, port: u16, path: []const u8) !void {
    // Always navigate via the view endpoint so Docz renders .dcz directly.
    const enc = try urlEncode(alloc, path);
    defer alloc.free(enc);

    const url = try std.fmt.allocPrint(alloc, "http://127.0.0.1:{d}/view?path={s}", .{ port, enc });
    defer alloc.free(url);

    const os = @import("builtin").os.tag;
    const argv = switch (os) {
        .windows => &[_][]const u8{ "cmd", "/c", "start", "", url }, // empty title
        .macos => &[_][]const u8{ "open", url },
        else => &[_][]const u8{ "xdg-open", url },
    };

    var child = std.process.Child.init(argv, alloc);
    _ = child.spawn() catch {}; // best-effort; ignore failures
}

fn printUsage() void {
    std.debug.print(
        \\Usage: docz preview [<path>] [--root <dir>] [--port <num>] [--no-open] [--config <file>]
        \\
        \\Options:
        \\  <path>            .dcz to open initially (default: docs/SPEC.dcz)
        \\  -r, --root <dir>  Document root to serve   (default: ".", or from config)
        \\  -p, --port <num>  Port to listen on        (default: 5173, or from config)
        \\      --no-open     Do not open a browser (useful when spawned by `docz run`)
        \\      --config      Path to a settings JSON (default: docz.settings.json if present)
        \\  -h, --help        Show this help
        \\
        \\Examples:
        \\  docz preview
        \\  docz preview docs/SPEC.dcz
        \\  docz preview --root docs --port 8787 docs/guide.dcz
        \\  docz preview --config my.settings.json
        \\
    , .{});
}

test "preview.cli compiles and usage prints" {
    // Smoke test: just call printUsage; nothing to assert.
    printUsage();
}

<<<

`run.zig`: >>>

const std = @import("std");
const docz = @import("docz");
const common = @import("./common.zig");

const assets = @import("./assets.zig");
const html_ops = @import("./html_ops.zig");
const fallback = @import("./fallback.zig");

// ─────────────────────────────────────────────────────────────
// Embedded core CSS (shipped with Docz)
// ─────────────────────────────────────────────────────────────
const CORE_CSS_BYTES: []const u8 = docz.assets.core_css;
const CORE_CSS_NAME: []const u8 = "docz.core.css";
const TAILWIND_CSS_NAME: []const u8 = "docz.tailwind.css";

// ───────── Live reload marker name ─────────
const LIVE_MARKER = "__docz_hot.txt";

const CssMode = enum { inline_css, file };

const GenerateOpts = struct {
    css_mode: CssMode = .inline_css,
    pretty: bool = true,
    live_reload: bool = true,
    css_file_name: []const u8 = "docz.css",
};

// ─────────────────────────────────────────────────────────────
// Preview helpers (spawn/open)
// ─────────────────────────────────────────────────────────────

fn spawnPreview(alloc: std.mem.Allocator, root_dir: []const u8, port: u16) !std.process.Child {
    const exe_path = try std.fs.selfExePathAlloc(alloc);
    defer alloc.free(exe_path);

    var argv = std.ArrayList([]const u8){};
    errdefer argv.deinit(alloc);

    try argv.append(alloc, exe_path);
    try argv.append(alloc, "preview");
    try argv.append(alloc, "--root");
    try argv.append(alloc, root_dir);
    try argv.append(alloc, "--port");
    const port_str = try std.fmt.allocPrint(alloc, "{}", .{port});
    defer alloc.free(port_str);
    try argv.append(alloc, port_str);
    try argv.append(alloc, "--no-open"); // run opens the browser

    var child = std.process.Child.init(argv.items, alloc);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;
    try child.spawn();

    return child;
}

fn openBrowserToIndex(alloc: std.mem.Allocator, port: u16) !void {
    const url = try std.fmt.allocPrint(alloc, "http://127.0.0.1:{d}/index.html", .{port});
    defer alloc.free(url);

    const os = @import("builtin").os.tag;
    const argv = switch (os) {
        .windows => &[_][]const u8{ "cmd", "/c", "start", url },
        .macos => &[_][]const u8{ "open", url },
        else => &[_][]const u8{ "xdg-open", url },
    };

    var child = std.process.Child.init(argv, alloc);
    _ = child.spawn() catch {};
}

// ─────────────────────────────────────────────────────────────
// One-shot generate to .zig-cache/docz-run
// ─────────────────────────────────────────────────────────────

fn generateOnce(
    alloc: std.mem.Allocator,
    dcz_path: []const u8,
    out_dir: []const u8,
    opts: GenerateOpts,
) !void {
    // 0) Read input and render a full HTML document (<head> + <body>)
    const input = try common.readFileAlloc(alloc, dcz_path);
    defer alloc.free(input);

    var final_html = try fallback.render(alloc, input);
    defer alloc.free(final_html);

    // 1) Core CSS — write file and link FIRST
    {
        const core_out = try std.fs.path.join(alloc, &.{ out_dir, CORE_CSS_NAME });
        defer alloc.free(core_out);
        try common.writeFile(core_out, CORE_CSS_BYTES);

        const linked_core = try html_ops.insertCssLinkBeforeHeadClose(alloc, final_html, CORE_CSS_NAME);
        alloc.free(final_html);
        final_html = linked_core;
    }

    // 2) Optional external CSS (empty/stub or user-provided path name)
    if (opts.css_mode == .file) {
        const css_out = try std.fs.path.join(alloc, &.{ out_dir, opts.css_file_name });
        defer alloc.free(css_out);
        // Write an empty file if caller didn't already generate one upstream.
        try common.writeFile(css_out, "");

        const linked = try html_ops.insertCssLinkBeforeHeadClose(alloc, final_html, opts.css_file_name);
        alloc.free(final_html);
        final_html = linked;
    }

    // 3) Tailwind (vendored or monorepo build) — link LAST among CSS if discovered
    if (assets.findTailwindCss(alloc) catch null) |src_tw| {
        defer alloc.free(src_tw);

        const tw_out = try std.fs.path.join(alloc, &.{ out_dir, TAILWIND_CSS_NAME });
        defer alloc.free(tw_out);
        try assets.copyFileStreaming(src_tw, tw_out);

        const linked_tw = try html_ops.insertCssLinkBeforeHeadClose(alloc, final_html, TAILWIND_CSS_NAME);
        alloc.free(final_html);
        final_html = linked_tw;
    }

    // 4) KaTeX (vendored) — inject assets + init script if available
    if (assets.findKatexAssets(alloc) catch null) |k| {
        defer {
            alloc.free(k.css_href);
            alloc.free(k.js_href);
            alloc.free(k.auto_href);
        }

        var sn = std.ArrayList(u8){};
        errdefer sn.deinit(alloc);

        // <link rel="stylesheet" href="...katex.min.css">
        try sn.appendSlice(alloc, "<link rel=\"stylesheet\" href=\"");
        try sn.appendSlice(alloc, k.css_href);
        try sn.appendSlice(alloc, "\">\n");

        // <script defer src="...katex.min.js"></script>
        try sn.appendSlice(alloc, "<script defer src=\"");
        try sn.appendSlice(alloc, k.js_href);
        try sn.appendSlice(alloc, "\"></script>\n");

        // <script defer src="...auto-render.min.js"></script>
        try sn.appendSlice(alloc, "<script defer src=\"");
        try sn.appendSlice(alloc, k.auto_href);
        try sn.appendSlice(alloc, "\"></script>\n");

        // Inline init (trust: true so \htmlClass/\htmlId/\htmlStyle/\htmlData work)
        // + gentle strictness and throwOnError:false for authoring friendliness.
        // Also add a convenience macro \class → \htmlClass for nicer authoring.
        try sn.appendSlice(alloc,
            \\<script>
            \\document.addEventListener('DOMContentLoaded', function () {
            \\  if (!window.renderMathInElement) return;
            \\  renderMathInElement(document.body, {
            \\    delimiters: [
            \\      {left: "$$", right: "$$", display: true},
            \\      {left: "$",  right: "$",  display: false},
            \\      {left: "\\(", right: "\\)", display: false},
            \\      {left: "\\[", right: "\\]", display: true}
            \\    ],
            \\    throwOnError: false,
            \\    strict: "ignore",
            \\    trust: true,
            \\    macros: {
            \\      "\\\\class": "\\\\htmlClass"
            \\    }
            \\  });
            \\});
            \\</script>
            \\
        );

        const snippet = try sn.toOwnedSlice(alloc);
        const injected = try html_ops.insertBeforeHeadClose(alloc, final_html, snippet);
        alloc.free(final_html);
        final_html = injected;
        alloc.free(snippet);
    }

    // 5) Live reload (dev) — small script + hot marker file
    if (opts.live_reload) {
        const with_live = try html_ops.injectLiveScript(alloc, final_html, LIVE_MARKER);
        alloc.free(final_html);
        final_html = with_live;
    }

    // 6) Pretty print (optional, cheap)
    if (opts.pretty) {
        const pretty = try html_ops.prettyHtml(alloc, final_html);
        alloc.free(final_html);
        final_html = pretty;
    }

    // 7) Write HTML and update hot marker last (after file is fully written)
    const html_out = try std.fs.path.join(alloc, &.{ out_dir, "index.html" });
    defer alloc.free(html_out);
    try common.writeFile(html_out, final_html);

    if (opts.live_reload) try html_ops.writeHotMarker(alloc, out_dir, LIVE_MARKER);
}

// -----------------------------------------------------------------------------
// CLI
// -----------------------------------------------------------------------------

pub fn run(alloc: std.mem.Allocator, it: *std.process.ArgIterator) !void {
    const usage =
        \\Usage: docz run <path.dcz> [--port <num>] [--css inline|file] [--no-pretty] [--no-live] [--config <file>]
        \\Notes:
        \\  - Compiles to a temp dir and serves it via `docz preview`
        \\  - Rebuilds + auto-reloads the browser when the .dcz changes
        \\
    ;

    const dcz_path = it.next() orelse {
        std.debug.print("{s}", .{usage});
        return error.Invalid;
    };

    // Defaults, optionally from config file
    var cfg_path: ?[]const u8 = null;
    var port_overridden = false;

    var settings = common.Settings{}; // defaults
    settings = common.loadSettings(alloc, null) catch settings;

    var port: u16 = settings.port;

    var css_mode: CssMode = .inline_css;
    var pretty: bool = true;
    var live_reload: bool = true;

    while (it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--port")) {
            const v = it.next() orelse {
                std.debug.print("run: --port requires a value\n", .{});
                return error.Invalid;
            };
            port = std.fmt.parseInt(u16, v, 10) catch {
                std.debug.print("run: invalid port: {s}\n", .{v});
                return error.Invalid;
            };
            port_overridden = true;
        } else if (std.mem.eql(u8, arg, "--css")) {
            const v = it.next() orelse {
                std.debug.print("run: --css requires a value: inline|file\n", .{});
                return error.Invalid;
            };
            if (std.mem.eql(u8, v, "inline")) css_mode = .inline_css else if (std.mem.eql(u8, v, "file")) css_mode = .file else {
                std.debug.print("run: --css must be 'inline' or 'file' (got '{s}')\n", .{v});
                return error.Invalid;
            }
        } else if (std.mem.eql(u8, arg, "--no-pretty")) {
            pretty = false;
        } else if (std.mem.eql(u8, arg, "--no-live")) {
            live_reload = false;
        } else if (std.mem.eql(u8, arg, "--config")) {
            const v = it.next() orelse {
                std.debug.print("run: --config requires a value\n", .{});
                return error.Invalid;
            };
            cfg_path = v;
            const s2 = common.loadSettings(alloc, cfg_path) catch settings;
            settings = s2;
            if (!port_overridden) port = settings.port;
        } else {
            std.debug.print("run: unknown arg: {s}\n", .{arg});
            return error.Invalid;
        }
    }

    // temp out dir inside zig-cache (portable & disposable)
    const tmp_root = try std.fs.path.join(alloc, &.{ ".zig-cache", "docz-run" });
    defer alloc.free(tmp_root);
    try std.fs.cwd().makePath(tmp_root);

    // initial build
    try generateOnce(alloc, dcz_path, tmp_root, .{
        .css_mode = css_mode,
        .pretty = pretty,
        .live_reload = live_reload,
    });

    // start preview server
    var preview = try spawnPreview(alloc, tmp_root, port);
    defer {
        _ = preview.kill() catch {};
        _ = preview.wait() catch {};
    }

    // open browser directly to the compiled HTML
    openBrowserToIndex(alloc, port) catch {};

    std.debug.print(
        "Serving on http://127.0.0.1:{d}  (dir: {s})  [live={any}]\n",
        .{ port, tmp_root, live_reload },
    );

    // watch loop (poll .dcz mtime)
    var last = try assets.fileMTime(dcz_path);
    while (true) {
        std.Thread.sleep(250 * std.time.ns_per_ms);

        const now = assets.fileMTime(dcz_path) catch continue;
        if (now != last) {
            last = now;
            generateOnce(alloc, dcz_path, tmp_root, .{
                .css_mode = css_mode,
                .pretty = pretty,
                .live_reload = live_reload,
            }) catch |e| {
                std.debug.print("run: rebuild failed: {s}\n", .{@errorName(e)});
            };
        }
    }
}

<<<

`all-directives.dcz`: >>>

@meta(title="All Directives Example", version="1.0", author="Docz") @end

@heading(level=1) Docz All Directives Demo @end

@heading(level=2) Metadata & Heading @end
This section shows meta + heading usage.

@heading(level=2) Style System @end
@style-def()
heading-level-1: font-size=36px, font-weight=bold, color=#000
body-text: font-family="Inter", line-height=1.6
@end

@style(color=blue, font-size=18px)
This text is styled inline.
@end

@heading(level=2) Data Directive @end
@data(format="json")
{
    "name": "Docz",
    "version": "1.0"
}
@end

@heading(level=2) Code Block @end
@code(language="zig", execute=true)
const x: i32 = 42;
@print(x);
@end

@heading(level=2) Math & Plot @end
@math()
E = mc^2
@end

@plot(type="line")
x: [1, 2, 3, 4]
y: [1, 4, 9, 16]
@end

@heading(level=2) Media @end
@image(src="img/logo.png", width="200px") @end
@video(src="demo.mp4", controls=true) @end
@audio(src="sound.mp3", controls=true) @end
@pdf(src="paper.pdf") @end

@heading(level=2) Embed & Logic @end
@embed(type="zeno-scene", source="scenes/fluid.zscene", width="800px") @end

@logic()
function hello() {
    alert("Hello from Docz!");
}
@end

@heading(level=2) Graph & Query @end
@graph(type="imports")
nodes: [main.dcz, intro.dcz]
edges: [main.dcz -> intro.dcz]
@end

ZUQL Example:
@code(language="sql")
SELECT docs WHERE tag="math";
@end
<<<

`example.dcz`: >>>

@meta(title="Docz Guide", author="Team") @end
@heading(level=2) Welcome @end
@code(language="zig")
const x = 42;
@end
@math()
E = mc^2
@end
@image(src="img/logo.png") @end

<<<

`hello.dcz`: >>>

@meta(title:"Docz Hello", author:"You")

@style(mode:"global")
heading-level-1: font-size=36px, font-weight=bold
body-text: line-height=1.6
@end

# Hello, Docz!
This is **bold**, *italic*, and a [link](https://ziglang.org).

@math
E = mc^2
@end

@code(lang:"zig")
const std = @import("std");
pub fn main() !void { std.debug.print("hi\n", .{}); }
@end
<<<

`minimal.dcz`: >>>

@meta(title="Minimal Doc", author="Docz Team") @end
@heading(level=1) Hello Docz @end
Welcome to the minimal example.
<<<

`sample.dcz`: >>>

@heading(level=2) Welcome to Docz @end
Hello World
<<<

`docz.core.css`: >>>

/* ─────────────────────────────────────────────────────────────
   Docz Core Styles (no Tailwind required)
   Location: assets/css/docz.core.css
   Purpose : Opinionated, readable defaults for .dcz → HTML
   Notes   : Tailwind themes (if vendored) are linked AFTER this file.
   License : Public Domain / Unlicense
   ───────────────────────────────────────────────────────────── */

/* ---------- CSS variables & base palette ---------- */
:root {
  color-scheme: light dark;

  /* Typography */
  --docz-font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",
                    Arial, "Noto Sans", "Liberation Sans", system-ui, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  --docz-font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
                    "Courier New", monospace;

  /* Layout (fluid & responsive)
     - Minimum: 80ch for tight views
     - Fluid middle: grows ~ with 8vw
     - Cap: 120ch (expanded vs last version) */
  --docz-max-width: clamp(80ch, 8vw + 82ch, 120ch);
  --docz-side-pad: 20px;
  --docz-line-height: 1.6;

  /* Colors (light) */
  --docz-bg: #ffffff;
  --docz-fg: #121316;
  --docz-muted: #5b616b;
  --docz-border: #e6e8eb;
  --docz-accent: #0d6efd;
  --docz-code-bg: #f6f8fa;
  --docz-code-fg: #0f1419;
  --docz-mark-bg: #fffb91;

  /* Components */
  --docz-quote-bar: #d8dde3;
  --docz-table-stripe: #fafbfc;
  --docz-kbd-bg: #f3f4f6;
  --docz-kbd-border: #e5e7eb;
}

/* Unlock even more width on very large displays */
@media (min-width: 1600px) {
  :root { --docz-max-width: clamp(86ch, 7vw + 90ch, 126ch); }
}
@media (min-width: 2000px) {
  :root { --docz-max-width: clamp(92ch, 6vw + 98ch, 132ch); }
}

/* Dark scheme overrides */
@media (prefers-color-scheme: dark) {
  :root {
    --docz-bg: #0f1115;
    --docz-fg: #e8e9ec;
    --docz-muted: #a4a8b3;
    --docz-border: #23262d;
    --docz-accent: #71a7ff;
    --docz-code-bg: #171a21;
    --docz-code-fg: #e6e9ef;
    --docz-mark-bg: #3a3f19;

    --docz-quote-bar: #2b2f37;
    --docz-table-stripe: #13161c;
    --docz-kbd-bg: #1b1f28;
    --docz-kbd-border: #2a2f3a;
  }
}

/* ---------- Page frame ---------- */
html, body {
  height: 100%;
  background: var(--docz-bg);
  color: var(--docz-fg);
}

body {
  margin: 0;
  font-family: var(--docz-font-sans);
  line-height: var(--docz-line-height);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;

  /* Centered reading column (fluid width) */
  max-width: var(--docz-max-width);
  margin-inline: auto;
  padding: 24px var(--docz-side-pad) 64px;
}

/* Optional wrapper class if your template uses it */
.docz-container {
  box-sizing: border-box;
  max-width: var(--docz-max-width);
  margin: 0 auto;
  padding: 24px var(--docz-side-pad) 64px;
}

/* Make all content respect box sizing */
*, *::before, *::after { box-sizing: border-box; }

/* Trim the very first element’s top margin for nicer page starts */
body > :first-child { margin-top: 0 !important; }

/* ---------- Headings (slightly tighter) ---------- */
h1, h2, h3, h4, h5, h6 {
  line-height: 1.25;
  margin: 1.3em 0 0.55em;
  font-weight: 700;
}

h1 { font-size: clamp(1.9rem, 2.2vw + 1rem, 2.6rem); }
h2 { font-size: clamp(1.6rem, 1.6vw + 1rem, 2.1rem); }
h3 { font-size: clamp(1.32rem, 1.0vw + 1rem, 1.55rem); }
h4 { font-size: 1.18rem; }
h5 { font-size: 1.04rem; }
h6 { font-size: 0.95rem; color: var(--docz-muted); }

h1 + h2 { margin-top: 1em; }

/* ---------- Paragraphs & inline ---------- */
p { margin: 0.8em 0; }

b, strong { font-weight: 700; }
em, i { font-style: italic; }
u { text-underline-offset: 3px; }
del { text-decoration: line-through; }

mark {
  background: var(--docz-mark-bg);
  padding: 0 .15em;
  border-radius: 2px;
}

/* Links */
a {
  color: var(--docz-accent);
  text-decoration: underline;
  text-decoration-thickness: 1.1px;
  text-underline-offset: 2px;
}
a:hover { text-decoration-thickness: 2px; }

/* Keyboard keys */
kbd {
  font-family: var(--docz-font-mono);
  font-size: 0.9em;
  background: var(--docz-kbd-bg);
  border: 1px solid var(--docz-kbd-border);
  border-bottom-width: 2px;
  padding: 0.15em 0.35em;
  border-radius: 4px;
}

/* Sup/sub spacing */
sup, sub { line-height: 0; }

/* ---------- Lists ---------- */
ul, ol { padding-left: 1.2em; margin: 0.8em 0; }
li + li { margin-top: 0.22em; }

/* Task lists (GitHub style) */
ul.task-list { list-style: none; padding-left: 0; }
ul.task-list li { margin-left: 1.2em; }
ul.task-list input[type="checkbox"] {
  margin: 0 0.6em 0 -1.2em;
  vertical-align: middle;
}

/* ---------- Code ---------- */
code, pre, samp {
  font-family: var(--docz-font-mono);
  font-variant-ligatures: none;
}

/* Slim, Markdown-like inline code */
code {
  background: var(--docz-code-bg);
  color: var(--docz-code-fg);
  padding: .06em .28em;
  border-radius: 3px;
  border: 0;
}

/* Blocks */
pre {
  background: var(--docz-code-bg);
  color: var(--docz-code-fg);
  padding: 12px 14px;
  border-radius: 6px;
  border: 1px solid var(--docz-border);
  overflow: auto;
  margin: 1em 0;
  line-height: 1.5;
  -webkit-overflow-scrolling: touch;
}
pre code {
  background: transparent;
  border: 0;
  padding: 0;
  white-space: pre;
}

/* Line highlight helper (optional) */
pre .line-highlight {
  display: block;
  background: color-mix(in srgb, var(--docz-accent) 12%, transparent);
  margin: 0 -14px;
  padding: 0 14px;
}

/* ---------- Blockquotes ---------- */
blockquote {
  margin: 0.9em 0;
  padding: .55em .9em;
  border-left: 4px solid var(--docz-quote-bar);
  background: color-mix(in srgb, var(--docz-quote-bar) 12%, transparent);
}
blockquote > :first-child { margin-top: 0; }
blockquote > :last-child { margin-bottom: 0; }

/* ---------- Tables ---------- */
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  margin: 1.1em 0;
  border: 1px solid var(--docz-border);
  border-radius: 6px;
  overflow: hidden;
}

thead th {
  background: color-mix(in srgb, var(--docz-border) 50%, transparent);
  text-align: left;
  font-weight: 700;
  padding: 8px 10px;
  border-bottom: 1px solid var(--docz-border);
}

tbody td {
  padding: 8px 10px;
  border-bottom: 1px solid var(--docz-border);
}

tbody tr:nth-child(even) td { background: var(--docz-table-stripe); }
tbody tr:last-child td { border-bottom: 0; }

/* ---------- Horizontal rule ---------- */
hr {
  border: 0;
  height: 1px;
  background: var(--docz-border);
  margin: 1.6em 0;
}

/* ---------- Images / Figures ---------- */
img, svg, video, canvas {
  max-width: 100%;
  height: auto;
}

figure { margin: 1.1em 0; }
figcaption {
  color: var(--docz-muted);
  font-size: 0.95em;
  text-align: center;
  margin-top: .35em;
}

/* ---------- Math (KaTeX helpers) ---------- */
.math, .docz-math, .katex-display {
  margin: 0.9em 0;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
.katex { font-size: 1em; }
.docz-math-inline { display: inline-block; }

/* ---------- Details/Summary ---------- */
details {
  border: 1px solid var(--docz-border);
  border-radius: 6px;
  padding: .45em .75em;
  margin: 0.9em 0;
}
details[open] { padding-bottom: .75em; }
summary {
  cursor: pointer;
  font-weight: 600;
}

/* ---------- Small utility classes ---------- */
.center { text-align: center; }
.right  { text-align: right; }
.mono   { font-family: var(--docz-font-mono); }
.lead   { font-size: 1.06em; color: var(--docz-muted); }
.small  { font-size: 0.9em; }

/* ---------- Print tweaks ---------- */
@media print {
  :root { --docz-side-pad: 0px; }
  body  {
    background: #fff;
    color: #000;
    padding: 0;
    max-width: none;
    margin: 12mm 10mm;
  }
  a     { color: #000; text-decoration: underline; }
  pre   { page-break-inside: avoid; }
  img, table { page-break-inside: avoid; }
}

<<<

`katex-dozenal.css`: >>>

@font-face{
  font-family: "LumaSymbols";
  src: url("../fonts/LumaSymbols-Dozenal.woff2") format("woff2");
  font-display: swap;
  unicode-range: U+218A, U+218B; /* ↊, ↋ */
}

/* Make KaTeX text prefer the tiny 2-glyph font for ↊/↋, then fall back */
.katex .text, .katex .mord.text, .katex .mtext {
  font-family: "LumaSymbols", KaTeX_Main, KaTeX_Math,
               "Noto Sans Symbols 2", "Segoe UI Symbol", "Apple Symbols",
               "DejaVu Sans", sans-serif;
}

/* (Optional) Let prose outside math also show ↊/↋ reliably */
body { font-family: "LumaSymbols", var(--docz-font-sans); }

<<<

`CONTRIBUTING.md`: >>>

# Contributing to Docz

Welcome to the future of documentation.  
**Docz is not just a tool—it is a foundation for the next era of knowledge.**

Where Markdown (`.md`) gave us simplicity, Docz (`.dcz`) gives us **structure, security, and extensibility**—a documentation engine built for humans and machines, for timelessness and clarity.

Thank you for considering contributing to this mission.

---

## 1. The Why: What Is Docz?

Docz is a **Zig-based documentation engine** that:
- Parses `.dcz` files into a structured AST.
- Executes embedded logic in a **secure WASM sandbox**.
- Outputs formats for any renderer—**including but not limited to Quartz**, a separate knowledge platform that uses `.dcz` as its core.

**Important:**  
- **Docz ≠ Quartz.** Quartz is a consumer of Docz, much like VSCode consumes TypeScript.  
- Docz stands alone as a complete CLI-driven documentation system with optional GUI components and a plugin ecosystem.

---

## 2. Principles of Contribution

Before writing a line of code, understand what makes Docz different:
- **Deterministic by Design:** Every build must be reproducible and cryptographically verifiable.
- **Secure by Default:** WASM sandboxing is non-negotiable.
- **Extensible through Plugins:** Keep the core minimal. Everything else is modular.
- **Readable, Maintainable, Timeless:** Code and docs must age well.

If your contribution aligns with these principles, you’re in the right place.

---

## 3. Quick Setup (With Context)

### Why Zig?
Zig provides:
- Safety without garbage collection.
- Direct WASM compilation.
- Deterministic builds.

### Prerequisites:
- Install Zig ≥ 0.13.0 → [https://ziglang.org/download](https://ziglang.org/download)

### Install & Build:
```bash
git clone https://github.com/zigadel/docz.git
cd docz
zig build
```

### Run Tests:
```bash
zig build test
```

---

## 4. Development Workflow

We use a branching strategy that prioritizes **stability and clarity**:
- `main` → Stable releases only.
- `dev` → Integration branch for new features.
- `feature/<name>` → Isolated work in progress.

### Why this matters:
- `main` must always be production-ready.
- Code review ensures **architectural integrity** and **security compliance**.

For full details, see [WORKFLOW.md](../docs/WORKFLOW.md).

---

## 5. Code & Style Conventions

Consistency is not cosmetic—it’s structural integrity:
- **Zig:** Use `zig fmt` and follow [STYLE_GUIDE.md](../docs/STYLE_GUIDE.md).
- **Docz Syntax (`.dcz`):**
    - Explicit directives (`@heading(level=1)`) instead of ambiguous symbols.
    - Parameterized styles over inline hacks.
    - Always close block directives with `@end`.

Why? Because structure > shortcuts. Readable code and docs are future-proof.

---

## 6. Testing as Integrity

Docz treats tests as part of the code—not an afterthought:
- Inline tests inside Zig files.
- 100% coverage goal for parser, CLI, and core logic.
- Why inline? Because tests should live **where the logic lives**.

Example:
```zig
test "parse heading directive" {
    const result = try parseDocz("@heading(level=2) Title @end");
    try expectEqual(result[0].node_type, NodeType.Heading);
}
```

Run all tests:
```bash
zig build test
```

---

## 7. Plugins Are the Future

Docz is a **plugin-first ecosystem**:
- Plugins extend functionality without inflating the core.
- All major features—math, diagrams, simulation—live as plugins.
- Every plugin:
    - Declares hooks (`onRegister`, `onParse`, `onRender`).
    - Has a `plugin.zon` manifest.
    - Includes inline tests.

Start here: [PLUGIN_GUIDE.md](../docs/PLUGIN_GUIDE.md).

---

## 8. Security & Responsibility

Docz is built for **trust in reproducible builds**:
- All dependencies must be hash-verified.
- WASM execution is sandboxed.
- No unchecked file or network I/O.

If you add code that touches security boundaries, **please document and justify every line**.

---

## 9. The Contributor’s Ethos

Contributing to Docz is not just about features—it’s about shaping an **infrastructure of understanding** that will outlast trends.

Every `.dcz` document you enable, every directive you define, every security guarantee you enforce makes Docz:
- **The future default** for documentation.
- A platform that elevates clarity, logic, and trust.

Welcome aboard. We're creating the new de facto for storing, searching, and presenting knowledge!

---

### Related Docs
- [ROADMAP.md](../docs/ROADMAP.md) – Strategic phases.
- [WORKFLOW.md](../docs/WORKFLOW.md) – Branching, CI/CD, PR standards.
- [STYLE_GUIDE.md](../docs/STYLE_GUIDE.md) – Code and syntax rules.

<<<

`PULL_REQUEST_TEMPLATE.md`: >>>

### Summary
Briefly describe your changes.

### Changes
- [ ] New feature
- [ ] Bug fix
- [ ] Documentation update
- [ ] Other: ___________

### Checklist
- [ ] Code compiles (`zig build`)
- [ ] Tests added (`zig build test`)
- [ ] Lint passes (`zig fmt` and `.dcz` syntax check)
- [ ] Docs updated

### Related Issues
<<<

`ci.yml`: >>>

name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Zig
        run: |
          sudo apt update && sudo apt install -y curl
          curl -L https://ziglang.org/download/index.json | grep 'tarball' # Replace with actual install
      - name: Build
        run: zig build
      - name: Test
        run: zig build test
      - name: Lint
        run: zig fmt --check .

<<<

`core-publish.yml`: >>>


<<<

`extension-publish.yml`: >>>


<<<

`release.yml`: >>>

name: Release

on:
  push:
    tags:
      - "v*"

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Release Artifacts
        run: |
          zig build -Drelease-safe
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: zig-out/bin/qz

<<<

`bug_report.md`: >>>

---
name: Bug Report
about: Report an issue with Docz or Quartz
title: "[BUG] "
labels: bug
assignees: ""
---

### Description
A clear and concise description of the issue.

### Steps to Reproduce
1. Run `qz preview README.dcz`
2. Observe error

### Expected Behavior
What did you expect to happen?

### Screenshots
If applicable, add screenshots to help explain.

### Environment
- OS: [e.g. macOS 14, Ubuntu 22.04]
- Zig Version: `zig version`
- Docz Version: `qz --version`

### Additional Context
Add any extra details here.

<<<

`config.yml`: >>>

blank_issues_enabled: false
contact_links:
  - name: Documentation
    url: https://docz.dev/docs # https://www.namecheap.com/domains/registration/results/?domain=docz
    about: Read the official documentation
  - name: Discussions
    url: https://github.com/zigadel/docz/discussions
    about: Ask questions or start a discussion

<<<

`feature_request.md`: >>>

---
name: Feature Request
about: Suggest a new feature for Docz or Quartz
title: "[FEATURE] "
labels: enhancement
assignees: ""
---

### Feature Description
What feature would you like to see added?

### Why is it Needed?
Explain the use case or problem this solves.

### Alternatives
Any alternatives or workarounds?

### Additional Context
Screenshots, mockups, or references.
<<<

`question.md`: >>>


<<<

